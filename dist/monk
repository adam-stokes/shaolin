#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Applify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPLIFY';
  package Applify;use strict;use warnings;use Carp ();use File::Basename ();use Scalar::Util 'blessed';use constant SUB_NAME_IS_AVAILABLE=>$INC{'App/FatPacker/Trace.pm'}? 0 : eval 'use Sub::Name; 1' ? 1 : 0;our$INSTANTIATING=0;our$PERLDOC='perldoc';our$SUBCMD_PREFIX='command';our$VERSION='0.21';my$ANON=0;sub app {my$self=shift;$self->{app}=shift if @_;local@ARGV=@ARGV;shift@ARGV if$self->_subcommand_activate($ARGV[0]);my (%argv,@spec);$self->_run_hook(before_options_parsing=>\@ARGV);for my$option (@{$self->options},@{$self->_default_options}){push@spec,$self->_calculate_option_spec($option);$argv{$option->{name}}=$option->{n_of}? []: undef}my$got_valid_options=$self->option_parser->getoptions(\%argv,@spec);delete$argv{$_}for grep {!defined$argv{$_}|| ref$argv{$_}eq 'ARRAY' &&!@{$argv{$_}}}keys%argv;if (!$got_valid_options){$self->_exit(1)}elsif ($argv{help}){$self->print_help;$self->_exit('help')}elsif ($argv{man}){system$PERLDOC=>$self->documentation;$self->_exit($? >> 8)}elsif ($argv{version}){$self->print_version;$self->_exit('version')}local$INSTANTIATING=1;local $@;my$app=eval {$self->{application_class}||= $self->_generate_application_class;$self->{application_class}->new(\%argv)}or do {$@ =~ s!\sat\s.*!!s unless$ENV{APPLIFY_VERBOSE};$self->print_help;local $!=1;die "\nInvalid input:\n\n$@\n"};return$app if defined wantarray;$self->_exit($app->run(@ARGV))}sub documentation {return $_[0]->{documentation}if @_==1;$_[0]->{documentation}=$_[1]or die 'Usage: documentation $file|$module_name;';return $_[0]}sub extends {my$self=shift;$self->{extends}=[@_];return$self}sub hook {my ($self,$name,$cb)=@_;push @{$self->{hook}{$name}},$cb;return$self}sub import {my ($class,%args)=@_;my@caller=caller;my$self=$class->new({caller=>\@caller});my$ns=$caller[0].'::';my%export;strict->import;warnings->import;no strict 'refs';$self->{skip_subs}{$_}=1 for keys %$ns;for my$k (qw(app extends hook option version documentation subcommand)){$self->{skip_subs}{$k}=1;my$name=$args{$k}// $k;next unless$name;$export{$k}=$name =~ /::/ ? $name : "$caller[0]\::$name"}no warnings 'redefine';*{$export{app}}=sub (&) {$self->app(@_)};*{$export{hook}}=sub {$self->hook(@_)};*{$export{option}}=sub {$self->option(@_)};*{$export{version}}=sub {$self->version(@_)};*{$export{documentation}}=sub {$self->documentation(@_)};*{$export{extends}}=sub {$self->extends(@_)};*{$export{subcommand}}=sub {$self->subcommand(@_)}}sub new {my$class=shift;my$self=bless @_ ? @_ > 1 ? {@_}: {%{$_[0]}}: {},ref$class || $class;$self->{options}||= [];$self->{caller}or die 'Usage: $self->new({ caller => [...], ... })';return$self}sub option {my$self=shift;my$type=shift or die 'Usage: option $type => ...';my$name=shift or die 'Usage: option $type => $name => ...';my$documentation=shift or die 'Usage: option $type => $name => $documentation, ...';my%option=@_ % 2 ? (default=>@_): @_;$option{alias}=[$option{alias}]if$option{alias}and!ref$option{alias};$option{arg}=do {local $_=$name;s!_!-!g;$_}unless$option{arg};$option{default}//=!!0 if$type eq 'bool';push @{$self->options},{%option,type=>$type,name=>$name,documentation=>$documentation};return$self}sub option_parser {my$self=shift;return do {$self->{option_parser}=shift;$self}if @_;my@config=qw(no_auto_help no_auto_version pass_through);push@config,'debug' if$ENV{APPLIFY_DEBUG};return$self->{option_parser}||= do {require Getopt::Long;Getopt::Long::Parser->new(config=>\@config)}}sub options {$_[0]->{options}}sub print_help {my$self=shift;my@options=(@{$self->options},{},@{$self->_default_options},{});my$width=0;my%notes;$self->_print_synopsis;OPTION: for my$option (@options){my$length=length($option->{name}|| '');$width=$length if$width < $length}print "Usage:\n";if (%{$self->{subcommands}|| {}}){my$subcmds=[sort {$a->{name}cmp $b->{name}}values %{$self->{subcommands}}];my ($width)=sort {$b <=> $a}map {length($_->{name})}@$subcmds;print "\n    ",File::Basename::basename($0)," [command] [options]\n";print "\nCommands:\n";printf("    %-${width}s  %s\n",@{$_}{'name','desc'})for @$subcmds;print "\nOptions:\n"}$width += 2;OPTION: for my$option (@options){my$arg=$option->{arg}or do {print "\n";next OPTION};my$prefix =($option->{required}and $option->{n_of})? '++' : $option->{required}? '*' : $option->{n_of}? '+' : '';$notes{$prefix}++ if$prefix;printf " %-2s %-${width}s  %s\n",$prefix,_option_with_dashes($arg),$option->{documentation}}print "Notes:\n" if%notes;print " *  denotes a required option\n" if$notes{'*'};print " +  denotes an option that accepts multiple values\n" if$notes{'+'};print " ++ denotes an option that accepts multiple values and is required\n" if$notes{'++'};return$self}sub print_version {my$self=shift;my$version=$self->version or die 'Cannot print version without version()';unless ($version =~ m!^\d!){local $@;eval "require $version; 1" or die "Could not load $version: $@";$version=$version->VERSION}printf "%s version %s\n",File::Basename::basename($0),$version}sub subcommand {my ($self,$name)=(shift,shift);return$self->{subcommand}unless @_;$self->{subcommands}{$name}={name=>$name,desc=>$_[0],adaptation=>$_[1]};return$self}sub version {return $_[0]->{version}if @_==1;$_[0]->{version}=$_[1]or die 'Usage: version $module_name|$num;';return $_[0]}sub _app_new {my$self=bless {},shift;my$attrs=ref $_[0]eq 'HASH' ? shift : {@_};$self->$_($attrs->{$_})for grep {$self->can($_)}keys %$attrs;return$self}sub _app_run {my ($app,@extra)=@_;my$self=$app->_script;if (my@missing=grep {$_->{required}&&!exists$app->{$_->{name}}}@{$self->options}){my$missing=join ', ',map {_option_with_dashes($_->{arg})}@missing;$self->print_help;die "Required attribute missing: $missing\n"}my$code=$self->_subcommand_code($app)|| $self->{app};return$app->$code(@extra)}sub _calculate_option_spec {my ($self,$option)=@_;my$spec=$option->{name};$spec .= "|$option->{arg}" if$option->{name}ne $option->{arg};$spec .= join '|','',@{$option->{alias}}if ref$option->{alias}eq 'ARRAY';if ($option->{type}=~ /^(?:bool|flag)/i){$spec .= '!'}elsif ($option->{type}=~ /^inc/){$spec .= '+'}elsif ($option->{type}=~ /^str/){$spec .= '=s'}elsif ($option->{type}=~ /^int/i){$spec .= '=i'}elsif ($option->{type}=~ /^num/i){$spec .= '=f'}elsif ($option->{type}=~ /^file/){$spec .= '=s'}elsif ($option->{type}=~ /^dir/){$spec .= '=s'}else {die 'Usage: option {bool|flag|inc|str|int|num|file|dir} ...'}if (blessed$option->{isa}){$spec =~ s!=\w$!=s!}if (my$n_of=$option->{n_of}){$spec .= $n_of eq '@' ? $n_of : "{$n_of}";$option->{default}||= []}return$spec}sub _default_options {my$self=shift;my@default;push@default,{name=>'help',documentation=>'Print this help text'};push@default,{name=>'man',documentation=>'Display manual for this application'}if$self->documentation;push@default,{name=>'version',documentation=>'Print application name and version'}if$self->version;return [map {$_->{type}='bool';$_->{arg}=$_->{name};$_}@default]}sub _documentation_class_handle {my ($self,$inc_entry,$inc_key)=@_;return$inc_entry->INC($inc_key)if ((ref($inc_entry)|| 'CODE')!~ m/(CODE|ARRAY)/);open my$fh,'<',$inc_entry or die "Failed to read synopsis from $inc_entry: $@";return$fh}sub _exit {my ($self,$reason)=@_;my$exit_value=$reason =~ /^\d+$/ ? $reason : 0;$self->_run_hook(before_exit=>$exit_value);exit$exit_value}sub _generate_attribute_accessor {my ($self,$option)=@_;my$default=ref$option->{default}eq 'CODE' ? $option->{default}: sub {$option->{default}};my$isa=$option->{isa};my$name=$option->{name};if (blessed$isa and $isa->can('check')){my$assert_method=$isa->has_coercion ? 'assert_coerce' : 'assert_return';my$prefix=$isa->has_coercion ? 'Could not coerce' : 'Failed check for';return sub {@_==1 && return exists $_[0]{$name}? $_[0]{$name}: ($_[0]{$name}=$_[0]->$default);eval {$_[0]{$name}=$isa->$assert_method($_[1]);1}or do {my$human=$INSTANTIATING ? _option_with_dashes($option->{arg}): qq("$name");die qq($prefix $human: $@)}}}elsif (my$class=_load_class($isa)){return sub {@_==1 && exists $_[0]{$name}&& return $_[0]{$name};my$val=@_ > 1 ? $_[1]: $_[0]->$default;$_[0]{$name}=ref$val eq 'ARRAY' ? [map {$class->new($_)}@$val]: defined($val)? $class->new($val): undef}}else {return sub {@_==1 && return exists $_[0]{$name}? $_[0]{$name}: ($_[0]{$name}=$_[0]->$default);$_[0]{$name}=$_[1]}}}sub _generate_application_class {my ($self,$code)=@_;my$application_class=$self->{caller}[1];my$extends=$self->{extends}|| [];$ANON++;$application_class =~ s!\W!_!g;$application_class=join '::',ref($self),"__ANON__${ANON}__",$application_class;local $@;eval qq[package $application_class; use base qw(@$extends); 1] or die "Failed to generate application class: $@";_sub("$application_class\::new"=>\&_app_new)unless grep {$_->can('new')}@$extends;_sub("$application_class\::run"=>\&_app_run);_sub("$application_class\::_script"=>sub {$self});for ('app',$self->{caller}[0]){my$ns=do {no strict 'refs';\%{"$_\::"}};for my$name (keys %$ns){$self->{skip_subs}{$name}and next;my$code=eval {ref$ns->{$name}eq 'CODE' ? $ns->{$name}: *{$ns->{$name}}{CODE}}or next;my$fqn=join '::',$application_class,$name;_sub($fqn=>$code);delete$ns->{$name}}}my$meta=$application_class->meta if$application_class->isa('Moose::Object')and $application_class->can('meta');for my$option (@{$self->options}){my$name=$option->{name};if ($meta){my%attr_options=(is=>'rw',predicate=>1,required=>$option->{required});$attr_options{default}=$option->{default}if$option->{default};$attr_options{isa}=$option->{isa}if$option->{isa};$meta->add_attribute($name=>\%attr_options)unless$meta->find_attribute_by_name($name)}else {my$accessor=join '::',$application_class,$name;_sub($accessor=>$self->_generate_attribute_accessor($option));my$predicator=join '::',$application_class,join '_',has=>$name;_sub($predicator=>sub {!!defined $_[0]->{$name}})}}return$application_class}sub _load_class {my$class=shift or return undef;return$class if$class->can('new');local $@;return eval "require $class; 1" ? $class : ""}sub _option_with_dashes {length($_[0])> 1 ? "--$_[0]" : "-$_[0]"}sub _print_synopsis {my$self=shift;my$documentation=$self->documentation or return;my ($print,$classpath);unless (-e $documentation){local $@;eval "require $documentation; 1" or die "Could not load $documentation: $@";$documentation =~ s!::!/!g;$documentation=$INC{$classpath="$documentation.pm"}}my$FH=$self->_documentation_class_handle($documentation,$classpath);while (<$FH>){last if$print and /^=(?:cut|head1)/;print if$print;$print=1 if /^=head1 SYNOPSIS/}}sub _run_hook {my ($self,$name,@args)=@_;return unless my$cbs=$self->{hook}{$name};for my$cb (@$cbs){$self->$cb(@args)}}sub _sub {my ($fqn,$code)=@_;no strict 'refs';return if *$fqn{CODE};*$fqn=SUB_NAME_IS_AVAILABLE ? Sub::Name::subname($fqn,$code): $code}sub _subcommand_activate {my ($self,$name)=@_;return undef unless$name and $name =~ /^\w+/;return undef unless$self->{subcommands}{$name};$self->{subcommand}=$name;{no warnings 'redefine';local*Applify::app=sub {Carp::confess("Looks like you have a typo in your script! Cannot have app{} inside a subcommand options block.")};$self->{subcommands}{$name}{adaptation}->($self)}return 1}sub _subcommand_code {my ($self,$app,$name)=(shift,shift);return undef unless$name=$self->subcommand;return$app->can("${SUBCMD_PREFIX}_${name}")}1;
APPLIFY

$fatpacked{"B/Hooks/EndOfScope.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE';
  package B::Hooks::EndOfScope;use strict;use warnings;our$VERSION='0.24';use 5.006001;BEGIN {use Module::Implementation 0.05;Module::Implementation::build_loader_sub(implementations=>['XS','PP' ],symbols=>['on_scope_end' ],)->()}use Sub::Exporter::Progressive 0.001006 -setup=>{exports=>['on_scope_end' ],groups=>{default=>['on_scope_end']},};1;
B_HOOKS_ENDOFSCOPE

$fatpacked{"B/Hooks/EndOfScope/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP';
  package B::Hooks::EndOfScope::PP;use warnings;use strict;our$VERSION='0.24';use constant _PERL_VERSION=>"$]";BEGIN {if (_PERL_VERSION =~ /^5\.009/){die "By design B::Hooks::EndOfScope does not operate in pure-perl mode on perl 5.9.X\n"}elsif (_PERL_VERSION < '5.010'){require B::Hooks::EndOfScope::PP::HintHash;*on_scope_end=\&B::Hooks::EndOfScope::PP::HintHash::on_scope_end}else {require B::Hooks::EndOfScope::PP::FieldHash;*on_scope_end=\&B::Hooks::EndOfScope::PP::FieldHash::on_scope_end}}use Sub::Exporter::Progressive 0.001006 -setup=>{exports=>['on_scope_end'],groups=>{default=>['on_scope_end']},};sub __invoke_callback {local $@;eval {$_[0]->();1}or do {my$err=$@;require Carp;Carp::cluck((join ' ','A scope-end callback raised an exception, which can not be propagated when','B::Hooks::EndOfScope operates in pure-perl mode. Your program will CONTINUE','EXECUTION AS IF NOTHING HAPPENED AFTER THIS WARNING. Below is the complete','exception text, followed by a stack-trace of the callback execution:',)."\n\n$err\n\r");sleep 1 if -t *STDERR}}1;
B_HOOKS_ENDOFSCOPE_PP

$fatpacked{"B/Hooks/EndOfScope/PP/FieldHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP_FIELDHASH';
  package B::Hooks::EndOfScope::PP::FieldHash;use strict;use warnings;our$VERSION='0.24';use Tie::Hash ();use Hash::Util::FieldHash 'fieldhash';fieldhash my%hh;{package B::Hooks::EndOfScope::PP::_TieHintHashFieldHash;our@ISA=('Tie::StdHash');sub DELETE {my$ret=shift->SUPER::DELETE(@_);B::Hooks::EndOfScope::PP::__invoke_callback($_)for @$ret;$ret}}sub on_scope_end (&) {$^H |= 0x020000;tie(%hh,'B::Hooks::EndOfScope::PP::_TieHintHashFieldHash')unless tied%hh;push @{$hh{\%^H}||= []},$_[0]}1;
B_HOOKS_ENDOFSCOPE_PP_FIELDHASH

$fatpacked{"B/Hooks/EndOfScope/PP/HintHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP_HINTHASH';
  package B::Hooks::EndOfScope::PP::HintHash;use strict;use warnings;our$VERSION='0.24';use Scalar::Util ();use constant _NEEDS_MEMORY_CORRUPTION_FIXUP=>("$]" >= 5.008 and "$]" < 5.008004)? 1 : 0;use constant _PERL_VERSION=>"$]";sub on_scope_end (&) {$^H |= 0x020000 if _PERL_VERSION >= 5.008;local %^H=%^H if _PERL_VERSION < 5.008;bless \%^H,'B::Hooks::EndOfScope::PP::HintHash::__GraveyardTransport' if (_NEEDS_MEMORY_CORRUPTION_FIXUP and ref \%^H eq 'HASH');push @{$^H{sprintf '__B_H_EOS__guardstack_0X%x',Scalar::Util::refaddr(\%^H)}||= bless ([],'B::Hooks::EndOfScope::PP::_SG_STACK')},$_[0]}sub B::Hooks::EndOfScope::PP::_SG_STACK::DESTROY {B::Hooks::EndOfScope::PP::__invoke_callback($_)for @{$_[0]}}{my@Hint_Hash_Graveyard;push@Hint_Hash_Graveyard,\@Hint_Hash_Graveyard if _NEEDS_MEMORY_CORRUPTION_FIXUP;sub B::Hooks::EndOfScope::PP::HintHash::__GraveyardTransport::DESTROY {push@Hint_Hash_Graveyard,$_[0];bless $_[0],'B::Hooks::EndOfScope::PP::HintHash::__DeactivateGraveyardTransport';%{$_[0]}=()}}1;
B_HOOKS_ENDOFSCOPE_PP_HINTHASH

$fatpacked{"B/Hooks/EndOfScope/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_XS';
  package B::Hooks::EndOfScope::XS;use strict;use warnings;our$VERSION='0.24';use 5.008004;use Variable::Magic 0.48 ();use Sub::Exporter::Progressive 0.001006 -setup=>{exports=>['on_scope_end'],groups=>{default=>['on_scope_end']},};my$wiz=Variable::Magic::wizard data=>sub {[$_[1]]},free=>sub {$_->()for @{$_[1]};()},local=>\undef ;sub on_scope_end (&) {$^H |= 0x020000;if (my$stack=Variable::Magic::getdata %^H,$wiz){push @{$stack},$_[0]}else {Variable::Magic::cast %^H,$wiz,$_[0]}}1;
B_HOOKS_ENDOFSCOPE_XS

$fatpacked{"CI/Repo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CI_REPO';
  package CI::Repo;use Moo;use namespace::autoclean;use Data::Dumper;has layer_list=>(is=>'ro');has charm_list=>(is=>'ro');sub sync_upstream {my ($self,$args)=@_;print "Syncing upstream\n"}1;
CI_REPO

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;use strict;use warnings;package Capture::Tiny;our$VERSION='0.48';use Carp ();use Exporter ();use IO::Handle ();use File::Spec ();use File::Temp qw/tempfile tmpnam/;use Scalar::Util qw/reftype blessed/;BEGIN {local $@;eval {require PerlIO;PerlIO->can('get_layers')}or *PerlIO::get_layers=sub {return ()}}my%api=(capture=>[1,1,0,0],capture_stdout=>[1,0,0,0],capture_stderr=>[0,1,0,0],capture_merged=>[1,1,1,0],tee=>[1,1,0,1],tee_stdout=>[1,0,0,1],tee_stderr=>[0,1,0,1],tee_merged=>[1,1,1,1],);for my$sub (keys%api){my$args=join q{, },@{$api{$sub}};eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"}our@ISA=qw/Exporter/;our@EXPORT_OK=keys%api;our%EXPORT_TAGS=('all'=>\@EXPORT_OK);my$IS_WIN32=$^O eq 'MSWin32';our$TIMEOUT=30;my@cmd=($^X,'-C0','-e',<<'HERE');sub _relayer {my ($fh,$apply_layers)=@_;binmode($fh,":raw");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")}my@to_apply=@$apply_layers;shift@to_apply;binmode($fh,":" .join(":",@to_apply))}sub _name {my$glob=shift;no strict 'refs';return *{$glob}{NAME}}sub _open {open $_[0],$_[1]or Carp::confess "Error from open(" .join(q{, },@_)."): $!"}sub _close {close $_[0]or Carp::confess "Error from close(" .join(q{, },@_)."): $!"}my%dup;my%proxy_count;sub _proxy_std {my%proxies;if (!defined fileno STDIN){$proxy_count{stdin}++;if (defined$dup{stdin}){_open \*STDIN,"<&=" .fileno($dup{stdin})}else {_open \*STDIN,"<" .File::Spec->devnull;_open$dup{stdin}=IO::Handle->new,"<&=STDIN"}$proxies{stdin}=\*STDIN;binmode(STDIN,':utf8')if $] >= 5.008}if (!defined fileno STDOUT){$proxy_count{stdout}++;if (defined$dup{stdout}){_open \*STDOUT,">&=" .fileno($dup{stdout})}else {_open \*STDOUT,">" .File::Spec->devnull;_open$dup{stdout}=IO::Handle->new,">&=STDOUT"}$proxies{stdout}=\*STDOUT;binmode(STDOUT,':utf8')if $] >= 5.008}if (!defined fileno STDERR){$proxy_count{stderr}++;if (defined$dup{stderr}){_open \*STDERR,">&=" .fileno($dup{stderr})}else {_open \*STDERR,">" .File::Spec->devnull;_open$dup{stderr}=IO::Handle->new,">&=STDERR"}$proxies{stderr}=\*STDERR;binmode(STDERR,':utf8')if $] >= 5.008}return%proxies}sub _unproxy {my (%proxies)=@_;for my$p (keys%proxies){$proxy_count{$p}--;if (!$proxy_count{$p}){_close$proxies{$p};_close$dup{$p}unless $] < 5.008;delete$dup{$p}}}}sub _copy_std {my%handles;for my$h (qw/stdout stderr stdin/){next if$h eq 'stdin' &&!$IS_WIN32;my$redir=$h eq 'stdin' ? "<&" : ">&";_open$handles{$h}=IO::Handle->new(),$redir .uc($h)}return \%handles}sub _open_std {my ($handles)=@_;_open \*STDIN,"<&" .fileno$handles->{stdin}if defined$handles->{stdin};_open \*STDOUT,">&" .fileno$handles->{stdout}if defined$handles->{stdout};_open \*STDERR,">&" .fileno$handles->{stderr}if defined$handles->{stderr}}sub _start_tee {my ($which,$stash)=@_;$stash->{$_}{$which}=IO::Handle->new for qw/tee reader/;pipe$stash->{reader}{$which},$stash->{tee}{$which};select((select($stash->{tee}{$which}),$|=1)[0]);$stash->{new}{$which}=$stash->{tee}{$which};$stash->{child}{$which}={stdin=>$stash->{reader}{$which},stdout=>$stash->{old}{$which},stderr=>$stash->{capture}{$which},};$stash->{flag_files}{$which}=scalar(tmpnam()).$$;if ($IS_WIN32){my$old_eval_err=$@;undef $@;eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";my$os_fhandle=GetOsFHandle($stash->{tee}{$which});my$result=SetHandleInformation($os_fhandle,HANDLE_FLAG_INHERIT(),0);_open_std($stash->{child}{$which});$stash->{pid}{$which}=system(1,@cmd,$stash->{flag_files}{$which});$@=$old_eval_err}else {_fork_exec($which,$stash)}}sub _fork_exec {my ($which,$stash)=@_;my$pid=fork;if (not defined$pid){Carp::confess "Couldn't fork(): $!"}elsif ($pid==0){untie*STDIN;untie*STDOUT;untie*STDERR;_close$stash->{tee}{$which};_open_std($stash->{child}{$which});exec@cmd,$stash->{flag_files}{$which}}$stash->{pid}{$which}=$pid}my$have_usleep=eval "use Time::HiRes 'usleep'; 1";sub _files_exist {return 1 if @_==grep {-f}@_;Time::HiRes::usleep(1000)if$have_usleep;return 0}sub _wait_for_tees {my ($stash)=@_;my$start=time;my@files=values %{$stash->{flag_files}};my$timeout=defined$ENV{PERL_CAPTURE_TINY_TIMEOUT}? $ENV{PERL_CAPTURE_TINY_TIMEOUT}: $TIMEOUT;1 until _files_exist(@files)|| ($timeout && (time - $start > $timeout));Carp::confess "Timed out waiting for subprocesses to start" if!_files_exist(@files);unlink $_ for@files}sub _kill_tees {my ($stash)=@_;if ($IS_WIN32){close($_)for values %{$stash->{tee}};my$start=time;1 until wait==-1 || (time - $start > 30)}else {_close $_ for values %{$stash->{tee}};waitpid $_,0 for values %{$stash->{pid}}}}sub _slurp {my ($name,$stash)=@_;my ($fh,$pos)=map {$stash->{$_}{$name}}qw/capture pos/;seek($fh,$pos,0)or die "Couldn't seek on capture handle for $name\n";my$text=do {local $/;scalar readline$fh};return defined($text)? $text : ""}sub _capture_tee {my ($do_stdout,$do_stderr,$do_merge,$do_tee,$code,@opts)=@_;my%do=($do_stdout ? (stdout=>1): (),$do_stderr ? (stderr=>1): ());Carp::confess("Custom capture options must be given as key/value pairs\n")unless@opts % 2==0;my$stash={capture=>{@opts }};for (keys %{$stash->{capture}}){my$fh=$stash->{capture}{$_};Carp::confess "Custom handle for $_ must be seekable\n" unless ref($fh)eq 'GLOB' || (blessed($fh)&& $fh->isa("IO::Seekable"))}local*CT_ORIG_STDIN=*STDIN ;local*CT_ORIG_STDOUT=*STDOUT;local*CT_ORIG_STDERR=*STDERR;my%layers=(stdin=>[PerlIO::get_layers(\*STDIN)],stdout=>[PerlIO::get_layers(\*STDOUT,output=>1)],stderr=>[PerlIO::get_layers(\*STDERR,output=>1)],);$layers{stdout}=[PerlIO::get_layers(tied*STDOUT)]if tied(*STDOUT)&& (reftype tied*STDOUT eq 'GLOB');$layers{stderr}=[PerlIO::get_layers(tied*STDERR)]if tied(*STDERR)&& (reftype tied*STDERR eq 'GLOB');my%localize;$localize{stdin}++,local(*STDIN)if grep {$_ eq 'scalar'}@{$layers{stdin}};$localize{stdout}++,local(*STDOUT)if$do_stdout && grep {$_ eq 'scalar'}@{$layers{stdout}};$localize{stderr}++,local(*STDERR)if ($do_stderr || $do_merge)&& grep {$_ eq 'scalar'}@{$layers{stderr}};$localize{stdin}++,local(*STDIN),_open(\*STDIN,"<&=0")if tied*STDIN && $] >= 5.008;$localize{stdout}++,local(*STDOUT),_open(\*STDOUT,">&=1")if$do_stdout && tied*STDOUT && $] >= 5.008;$localize{stderr}++,local(*STDERR),_open(\*STDERR,">&=2")if ($do_stderr || $do_merge)&& tied*STDERR && $] >= 5.008;my%proxy_std=_proxy_std();$layers{stdout}=[PerlIO::get_layers(\*STDOUT,output=>1)]if$proxy_std{stdout};$layers{stderr}=[PerlIO::get_layers(\*STDERR,output=>1)]if$proxy_std{stderr};$stash->{old}=_copy_std();$stash->{new}={%{$stash->{old}}};for (keys%do){$stash->{new}{$_}=($stash->{capture}{$_}||= File::Temp->new);seek($stash->{capture}{$_},0,2)or die "Could not seek on capture handle for $_\n";$stash->{pos}{$_}=tell$stash->{capture}{$_};_start_tee($_=>$stash)if$do_tee}_wait_for_tees($stash)if$do_tee;$stash->{new}{stderr}=$stash->{new}{stdout}if$do_merge;_open_std($stash->{new});my ($exit_code,$inner_error,$outer_error,$orig_pid,@result);{$orig_pid=$$;local*STDIN=*CT_ORIG_STDIN if$localize{stdin};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;my$old_eval_err=$@;undef $@;eval {@result=$code->();$inner_error=$@};$exit_code=$?;$outer_error=$@;STDOUT->flush if$do_stdout;STDERR->flush if$do_stderr;$@=$old_eval_err}_open_std($stash->{old});_close($_)for values %{$stash->{old}};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;_unproxy(%proxy_std);_kill_tees($stash)if$do_tee;my%got;if ($orig_pid==$$ and (defined wantarray or ($do_tee && keys%localize))){for (keys%do){_relayer($stash->{capture}{$_},$layers{$_});$got{$_}=_slurp($_,$stash)}print CT_ORIG_STDOUT$got{stdout}if$do_stdout && $do_tee && $localize{stdout};print CT_ORIG_STDERR$got{stderr}if$do_stderr && $do_tee && $localize{stderr}}$?=$exit_code;$@=$inner_error if$inner_error;die$outer_error if$outer_error;return unless defined wantarray;my@return;push@return,$got{stdout}if$do_stdout;push@return,$got{stderr}if$do_stderr &&!$do_merge;push@return,@result;return wantarray ? @return : $return[0]}1;
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
CAPTURE_TINY

$fatpacked{"Class/Method/Modifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_METHOD_MODIFIERS';
  use strict;use warnings;package Class::Method::Modifiers;our$VERSION='2.13';use base 'Exporter';our@EXPORT=qw(before after around);our@EXPORT_OK=(@EXPORT,qw(fresh install_modifier));our%EXPORT_TAGS=(moose=>[qw(before after around)],all=>\@EXPORT_OK,);BEGIN {*_HAS_READONLY=$] >= 5.008 ? sub(){1}: sub(){0}}our%MODIFIER_CACHE;sub _install_modifier;*_install_modifier=\&install_modifier;sub install_modifier {my$into=shift;my$type=shift;my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';return _fresh($into,$code,@names)if$type eq 'fresh';for my$name (@names){my$hit=$into->can($name)or do {require Carp;Carp::confess("The method '$name' is not found in the inheritance hierarchy for class $into")};my$qualified=$into.'::'.$name;my$cache=$MODIFIER_CACHE{$into}{$name}||= {before=>[],after=>[],around=>[],};if (!exists($cache->{"orig"})){no strict 'refs';$cache->{"orig"}=*{$qualified}{CODE};$cache->{"wrapped"}=$cache->{"orig"}|| $hit}if ($type eq 'after'){push @{$cache->{$type}},$code}else {unshift @{$cache->{$type}},$code}if ($type eq 'around'){my$method=$cache->{wrapped};my$attrs=_sub_attrs($code);$cache->{wrapped}=eval "package $into; +sub $attrs { \$code->(\$method, \@_); };"}if (@{$cache->{$type}}==1){my$before=$cache->{"before"};my$after=$cache->{"after"};my$wrapped=\$cache->{"wrapped"};my$attrs=_sub_attrs($cache->{wrapped});my$generated="package $into;\n";$generated .= "sub $name $attrs {";if (@$before){$generated .= '
                      for my $method (@$before) {
                          $method->(@_);
                      }
                  '}if (@$after){$generated .= '
                      my $ret;
                      if (wantarray) {
                          $ret = [$$wrapped->(@_)];
                          '.(_HAS_READONLY ? 'Internals::SvREADONLY(@$ret, 1);' : '').'
                      }
                      elsif (defined wantarray) {
                          $ret = \($$wrapped->(@_));
                      }
                      else {
                          $$wrapped->(@_);
                      }
  
                      for my $method (@$after) {
                          $method->(@_);
                      }
  
                      wantarray ? @$ret : $ret ? $$ret : ();
                  '}else {$generated .= '$$wrapped->(@_);'}$generated .= '}';no strict 'refs';no warnings 'redefine';no warnings 'closure';eval$generated}}}sub before {_install_modifier(scalar(caller),'before',@_)}sub after {_install_modifier(scalar(caller),'after',@_)}sub around {_install_modifier(scalar(caller),'around',@_)}sub fresh {my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';_fresh(scalar(caller),$code,@names)}sub _fresh {my ($into,$code,@names)=@_;for my$name (@names){if ($name !~ /\A [a-zA-Z_] [a-zA-Z0-9_]* \z/xms){require Carp;Carp::confess("Invalid method name '$name'")}if ($into->can($name)){require Carp;Carp::confess("Class $into already has a method named '$name'")}if (_is_in_package($code,$into)){no strict 'refs';*{"$into\::$name"}=$code}else {no warnings 'closure';my$attrs=_sub_attrs($code);eval "package $into; sub $name $attrs { \$code->(\@_) }"}}}sub _sub_attrs {my ($coderef)=@_;local*_sub=$coderef;local $@;(eval 'return 1; &_sub = 1')? ':lvalue' : ''}sub _is_in_package {my ($coderef,$package)=@_;require B;my$cv=B::svref_2object($coderef);return$cv->GV->STASH->NAME eq $package}1;
CLASS_METHOD_MODIFIERS

$fatpacked{"Command/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER';
  package Command::Runner;use strict;use warnings;use Capture::Tiny ();use Command::Runner::Format ();use Command::Runner::LineBuffer;use Command::Runner::Quote ();use Config ();use IO::Select;use POSIX ();use Time::HiRes ();use constant WIN32=>$^O eq 'MSWin32';our$VERSION='0.102';our$TICK=0.02;sub new {my ($class,%option)=@_;my$command=delete$option{command};my$commandf=delete$option{commandf};die "Cannot specify both command and commandf" if$command && $commandf;if (!$command && $commandf){$command=Command::Runner::Format::commandf @$commandf}bless {keep=>1,_buffer=>{},%option,($command ? (command=>$command): ()),},$class}for my$attr (qw(command redirect timeout keep stdout stderr env)){no strict 'refs';*$attr=sub {my$self=shift;$self->{$attr}=$_[0];$self}}sub commandf {my ($self,$format,@args)=@_;$self->{command}=Command::Runner::Format::commandf$format,@args;$self}sub run {my$self=shift;local%ENV=%{$self->{env}}if$self->{env};my$command=$self->{command};if (ref$command eq 'CODE'){$self->_wrap(sub {$self->_run_code($command)})}elsif (WIN32){$self->_wrap(sub {$self->_system_win32($command)})}else {$self->_exec($command)}}sub _wrap {my ($self,$code)=@_;my ($stdout,$stderr,$res);if ($self->{redirect}){($stdout,$res)=&Capture::Tiny::capture_merged($code)}else {($stdout,$stderr,$res)=&Capture::Tiny::capture($code)}if (length$stdout and my$sub=$self->{stdout}){my$buffer=Command::Runner::LineBuffer->new(buffer=>$stdout);my@line=$buffer->get(1);$sub->($_)for@line}if (!$self->{redirect}and length$stderr and my$sub=$self->{stderr}){my$buffer=Command::Runner::LineBuffer->new(buffer=>$stderr);my@line=$buffer->get(1);$sub->($_)for@line}if ($self->{keep}){$res->{stdout}=$stdout;$res->{stderr}=$stderr}return$res}sub _run_code {my ($self,$code)=@_;if (!$self->{timeout}){my$result=$code->();return {pid=>$$,result=>$result }}my ($result,$err);{local$SIG{__DIE__}='DEFAULT';local$SIG{ALRM}=sub {die "__TIMEOUT__\n"};eval {alarm$self->{timeout};$result=$code->()};$err=$@;alarm 0}if (!$err){return {pid=>$$,result=>$result,}}elsif ($err eq "__TIMEOUT__\n"){return {pid=>$$,result=>$result,timeout=>1 }}else {die$err}}sub _system_win32 {my ($self,$command)=@_;my$pid;if (ref$command){my@cmd=map {Command::Runner::Quote::quote_win32($_)}@$command;$pid=system {$command->[0]}1,@cmd}else {$pid=system 1,$command}my$timeout_at=$self->{timeout}? Time::HiRes::time()+ $self->{timeout}: undef;my$INT;local$SIG{INT}=sub {$INT++};my ($result,$timeout);while (1){if ($INT){kill INT=>$pid;$INT=0}my$res=waitpid$pid,POSIX::WNOHANG();if ($res==-1){warn "waitpid($pid, POSIX::WNOHANG()) returns unexpectedly -1";last}elsif ($res > 0){$result=$?;last}else {if ($timeout_at){my$now=Time::HiRes::time();if ($timeout_at <= $now){$timeout=1;kill TERM=>$pid}}Time::HiRes::sleep($TICK)}}return {pid=>$pid,result=>$result,timeout=>$timeout }}sub _exec {my ($self,$command)=@_;pipe my$stdout_read,my$stdout_write;$self->{_buffer}{stdout}=Command::Runner::LineBuffer->new(keep=>$self->{keep});my ($stderr_read,$stderr_write);if (!$self->{redirect}){pipe$stderr_read,$stderr_write;$self->{_buffer}{stderr}=Command::Runner::LineBuffer->new(keep=>$self->{keep})}my$pid=fork;die "fork: $!" unless defined$pid;if ($pid==0){close $_ for grep $_,$stdout_read,$stderr_read;open STDOUT,">&",$stdout_write;if ($self->{redirect}){open STDERR,">&",\*STDOUT}else {open STDERR,">&",$stderr_write}if ($Config::Config{d_setpgrp}){POSIX::setpgid(0,0)or die "setpgid: $!"}if (ref$command){exec {$command->[0]}@$command}else {exec$command}exit 127}close $_ for grep $_,$stdout_write,$stderr_write;my$signal_pid=$Config::Config{d_setpgrp}? -$pid : $pid;my$INT;local$SIG{INT}=sub {$INT++};my$timeout;my$timeout_at=$self->{timeout}? Time::HiRes::time()+ $self->{timeout}: undef;my$select=IO::Select->new(grep $_,$stdout_read,$stderr_read);while ($select->count){if ($INT){kill INT=>$signal_pid;$INT=0}if ($timeout_at and!$timeout){my$now=Time::HiRes::time();if ($now > $timeout_at){$timeout++;kill TERM=>$signal_pid}}for my$ready ($select->can_read($TICK)){my$type=$ready==$stdout_read ? "stdout" : "stderr";my$len=sysread$ready,my$buf,64*1024;if ($len){my$buffer=$self->{_buffer}{$type};$buffer->add($buf);next unless my@line=$buffer->get;next unless my$sub=$self->{$type};$sub->($_)for@line}else {warn "sysread $type pipe failed: $!" unless defined$len;$select->remove($ready);close$ready}}}for my$type (qw(stdout stderr)){next unless my$sub=$self->{$type};my$buffer=$self->{_buffer}{$type}or next;my@line=$buffer->get(1)or next;$sub->($_)for@line}close $_ for$select->handles;waitpid$pid,0;my$res={pid=>$pid,result=>$?,timeout=>$timeout,stdout=>$self->{_buffer}{stdout}? $self->{_buffer}{stdout}->raw : "",stderr=>$self->{_buffer}{stderr}? $self->{_buffer}{stderr}->raw : "",};$self->{_buffer}=+{};return$res}1;
COMMAND_RUNNER

$fatpacked{"Command/Runner/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER_FORMAT';
  package Command::Runner::Format;use strict;use warnings;use Command::Runner::Quote 'quote';use Exporter 'import';our@EXPORT_OK=qw(commandf);my$regex=qr/
                 (%             # leading '%'                    $1
                  (-)?          # left-align, rather than right  $2
                  (\d*)?        # (optional) minimum field width $3
                  (?:\.(\d*))?  # (optional) maximum field width $4
                  (\{.*?\})?    # (optional) stuff inside        $5
                  (\S)          # actual format character        $6
               )/x;sub commandf {my ($format,@args)=@_;my$i=0;$format =~ s{$regex}{
          $6 eq '%' ? '%' : _replace($args[$i++], $1, $6)
      }ge;$format}sub _replace {my ($arg,$all,$char)=@_;if ($char eq 'q'){return quote$arg}else {return sprintf$all,$arg}}1;
COMMAND_RUNNER_FORMAT

$fatpacked{"Command/Runner/LineBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER_LINEBUFFER';
  package Command::Runner::LineBuffer;use strict;use warnings;sub new {my ($class,%args)=@_;my$buffer=exists$args{buffer}? $args{buffer}: "";bless {buffer=>$buffer,$args{keep}? (keep=>$buffer): (),},$class}sub raw {my$self=shift;exists$self->{keep}? $self->{keep}: undef}sub add {my ($self,$buffer)=@_;$self->{buffer}.= $buffer;$self->{keep}.= $buffer if exists$self->{keep};$self}sub get {my ($self,$drain)=@_;if ($drain){if (length$self->{buffer}){my@line=$self->get;if (length$self->{buffer}and $self->{buffer}ne "\x0d"){$self->{buffer}=~ s/[\x0d\x0a]+\z//;push@line,$self->{buffer}}$self->{buffer}="";return@line}else {return}}my@line;while ($self->{buffer}=~ s/\A(.*?(?:\x0d\x0a|\x0d|\x0a))//sm){my$line=$1;next if$line eq "\x0d";$line =~ s/[\x0d\x0a]+\z//;push@line,$line}return@line}1;
COMMAND_RUNNER_LINEBUFFER

$fatpacked{"Command/Runner/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER_QUOTE';
  package Command::Runner::Quote;use strict;use warnings;use Win32::ShellQuote ();use String::ShellQuote ();use Exporter 'import';our@EXPORT_OK=qw(quote quote_win32 quote_unix);sub quote_win32 {my$str=shift;Win32::ShellQuote::quote_literal($str,1)}sub quote_unix {my$str=shift;String::ShellQuote::shell_quote_best_effort($str)}if ($^O eq 'MSWin32'){*quote=\&quote_win32}else {*quote=\&quote_unix}1;
COMMAND_RUNNER_QUOTE

$fatpacked{"Dist/CheckConflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_CHECKCONFLICTS';
  package Dist::CheckConflicts;BEGIN {$Dist::CheckConflicts::AUTHORITY='cpan:DOY'}$Dist::CheckConflicts::VERSION='0.11';use strict;use warnings;use 5.006;use base 'Exporter';our@EXPORT=our@EXPORT_OK=(qw(conflicts check_conflicts calculate_conflicts dist));use Carp;use Module::Runtime 0.009 'module_notional_filename','require_module';my%CONFLICTS;my%HAS_CONFLICTS;my%DISTS;sub import {my$pkg=shift;my$for=caller;my ($conflicts,$alsos,$dist);($conflicts,@_)=_strip_opt('-conflicts'=>@_);($alsos,@_)=_strip_opt('-also'=>@_);($dist,@_)=_strip_opt('-dist'=>@_);my%conflicts=%{$conflicts || {}};for my$also (@{$alsos || []}){eval {require_module($also)}or next;if (!exists$CONFLICTS{$also}){$also .= '::Conflicts';eval {require_module($also)}or next}if (!exists$CONFLICTS{$also}){next}my%also_confs=$also->conflicts;for my$also_conf (keys%also_confs){$conflicts{$also_conf}=$also_confs{$also_conf}if!exists$conflicts{$also_conf}|| $conflicts{$also_conf}lt $also_confs{$also_conf}}}$CONFLICTS{$for}=\%conflicts;$DISTS{$for}=$dist || $for;if (grep {$_ eq ':runtime'}@_){for my$conflict (keys%conflicts){$HAS_CONFLICTS{$conflict}||= [];push @{$HAS_CONFLICTS{$conflict}},$for}for my$conflict (keys%conflicts){if (exists$INC{module_notional_filename($conflict)}){_check_version([$for],$conflict)}}@INC=grep {!(ref($_)eq 'ARRAY' && @$_ > 1 && $_->[1]==\%CONFLICTS)}@INC;unshift@INC,[sub {my ($sub,$file)=@_;(my$mod=$file)=~ s{\.pm$}{};$mod =~ s{/}{::}g;return unless$mod =~ /[\w:]+/;return unless defined$HAS_CONFLICTS{$mod};{local$HAS_CONFLICTS{$mod};require$file}_check_version($HAS_CONFLICTS{$mod},$mod);my$called;return sub {return 0 if$called;$_="1;";$called=1;return 1}},\%CONFLICTS,]}$pkg->export_to_level(1,@_)}sub _strip_opt {my ($opt,@args)=@_;my$val;for my$idx (0 .. $#args - 1){if (defined$args[$idx]&& $args[$idx]eq $opt){$val=(splice@args,$idx,2)[1];last}}return ($val,@args)}sub _check_version {my ($fors,$mod)=@_;for my$for (@$fors){my$conflict_ver=$CONFLICTS{$for}{$mod};my$version=do {no strict 'refs';${${$mod .'::'}{VERSION}}};if ($version le $conflict_ver){warn <<EOF;return}}}sub conflicts {my$package=shift;return %{$CONFLICTS{$package }}}sub dist {my$package=shift;return$DISTS{$package }}sub check_conflicts {my$package=shift;my$dist=$package->dist;my@conflicts=$package->calculate_conflicts;return unless@conflicts;my$err="Conflicts detected for $dist:\n";for my$conflict (@conflicts){$err .= "  $conflict->{package} is version " ."$conflict->{installed}, but must be greater than version " ."$conflict->{required}\n"}die$err}sub calculate_conflicts {my$package=shift;my%conflicts=$package->conflicts;my@ret;CONFLICT: for my$conflict (keys%conflicts){my$success=do {local$SIG{__WARN__}=sub {};eval {require_module($conflict)}};my$error=$@;my$file=module_notional_filename($conflict);next if not $success and $error =~ /Can't locate \Q$file\E in \@INC/;warn "Warning: $conflict did not compile" if not $success;my$installed=$success ? $conflict->VERSION : 'unknown';push@ret,{package=>$conflict,installed=>$installed,required=>$conflicts{$conflict},}if not $success or $installed le $conflicts{$conflict}}return sort {$a->{package}cmp $b->{package}}@ret}1;
  Conflict detected for $DISTS{$for}:
    $mod is version $version, but must be greater than version $conflict_ver
  EOF
DIST_CHECKCONFLICTS

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;use Moo::_strictures;use Moo::_Utils qw(_load_module _maybe_load_module _install_coderef);use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quoted_from_sub quotify sanitize_identifier);use Scalar::Util 'blessed';use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Moo::_Utils)}BEGIN {*_CAN_WEAKEN_READONLY=("$]" < 5.008_003 or $ENV{MOO_TEST_PRE_583})? sub(){0}: sub(){1};our$CAN_HAZ_XS=!$ENV{MOO_XS_DISABLE}&& _maybe_load_module('Class::XSAccessor')&& (eval {Class::XSAccessor->VERSION('1.07')});our$CAN_HAZ_XS_PRED=$CAN_HAZ_XS && (eval {Class::XSAccessor->VERSION('1.17')})}BEGIN {package Method::Generate::Accessor::_Generated;$Carp::Internal{+__PACKAGE__}=1}my$module_name_only=qr/\A$Module::Runtime::module_name_rx\z/;sub _die_overwrite {my ($pkg,$method,$type)=@_;croak "You cannot overwrite a locally defined method ($method) with " .($type || 'an accessor')}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$quote_opts={no_defer=>1,package=>'Method::Generate::Accessor::_Generated',%{$quote_opts||{}},};$spec->{allow_overwrite}++ if$name =~ s/^\+//;croak "Must have an is" unless my$is=$spec->{is};if ($is eq 'ro'){$spec->{reader}=$name unless exists$spec->{reader}}elsif ($is eq 'rw'){$spec->{accessor}=$name unless exists$spec->{accessor}or ($spec->{reader}and $spec->{writer})}elsif ($is eq 'lazy'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{lazy}=1;$spec->{builder}||= '_build_'.$name unless exists$spec->{default}}elsif ($is eq 'rwp'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{writer}="_set_${name}" unless exists$spec->{writer}}elsif ($is ne 'bare'){croak "Unknown is ${is}"}if (exists$spec->{builder}){if(ref$spec->{builder}){$self->_validate_codulatable('builder',$spec->{builder},"$into->$name",'or a method name');$spec->{builder_sub}=$spec->{builder};$spec->{builder}=1}$spec->{builder}='_build_'.$name if ($spec->{builder}||0)eq 1;croak "Invalid builder for $into->$name - not a valid method name" if$spec->{builder}!~ $module_name_only}if (($spec->{predicate}||0)eq 1){$spec->{predicate}=$name =~ /^_/ ? "_has${name}" : "has_${name}"}if (($spec->{clearer}||0)eq 1){$spec->{clearer}=$name =~ /^_/ ? "_clear${name}" : "clear_${name}"}if (($spec->{trigger}||0)eq 1){$spec->{trigger}=quote_sub('shift->_trigger_'.$name.'(@_)')}if (($spec->{coerce}||0)eq 1){my$isa=$spec->{isa};if (blessed$isa and $isa->can('coercion')){$spec->{coerce}=$isa->coercion}elsif (blessed$isa and $isa->can('coerce')){$spec->{coerce}=sub {$isa->coerce(@_)}}else {croak "Invalid coercion for $into->$name - no appropriate type constraint"}}for my$setting (qw(isa coerce)){next if!exists$spec->{$setting};$self->_validate_codulatable($setting,$spec->{$setting},"$into->$name")}if (exists$spec->{default}){if (ref$spec->{default}){$self->_validate_codulatable('default',$spec->{default},"$into->$name",'or a non-ref')}}if (exists$spec->{moosify}){if (ref$spec->{moosify}ne 'ARRAY'){$spec->{moosify}=[$spec->{moosify}]}for my$spec (@{$spec->{moosify}}){$self->_validate_codulatable('moosify',$spec,"$into->$name")}}my%methods;if (my$reader=$spec->{reader}){_die_overwrite($into,$reader,'a reader')if!$spec->{allow_overwrite}&& defined &{"${into}::${reader}"};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)){$methods{$reader}=$self->_generate_xs(getters=>$into,$reader,$name,$spec)}else {$self->{captures}={};$methods{$reader}=quote_sub "${into}::${reader}" =>'    Carp::croak("'.$reader.' is a read-only accessor") if @_ > 1;'."\n" .$self->_generate_get($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$accessor=$spec->{accessor}){_die_overwrite($into,$accessor,'an accessor')if!$spec->{allow_overwrite}&& defined &{"${into}::${accessor}"};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)&& $self->is_simple_set($name,$spec)){$methods{$accessor}=$self->_generate_xs(accessors=>$into,$accessor,$name,$spec)}else {$self->{captures}={};$methods{$accessor}=quote_sub "${into}::${accessor}" =>$self->_generate_getset($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$writer=$spec->{writer}){_die_overwrite($into,$writer,'a writer')if!$spec->{allow_overwrite}&& defined &{"${into}::${writer}"};if (our$CAN_HAZ_XS && $self->is_simple_set($name,$spec)){$methods{$writer}=$self->_generate_xs(setters=>$into,$writer,$name,$spec)}else {$self->{captures}={};$methods{$writer}=quote_sub "${into}::${writer}" =>$self->_generate_set($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$pred=$spec->{predicate}){_die_overwrite($into,$pred,'a predicate')if!$spec->{allow_overwrite}&& defined &{"${into}::${pred}"};if (our$CAN_HAZ_XS && our$CAN_HAZ_XS_PRED){$methods{$pred}=$self->_generate_xs(exists_predicates=>$into,$pred,$name,$spec)}else {$self->{captures}={};$methods{$pred}=quote_sub "${into}::${pred}" =>$self->_generate_simple_has('$_[0]',$name,$spec)."\n" =>delete$self->{captures}=>$quote_opts }}if (my$builder=delete$spec->{builder_sub}){_install_coderef("${into}::$spec->{builder}"=>$builder)}if (my$cl=$spec->{clearer}){_die_overwrite($into,$cl,'a clearer')if!$spec->{allow_overwrite}&& defined &{"${into}::${cl}"};$self->{captures}={};$methods{$cl}=quote_sub "${into}::${cl}" =>$self->_generate_simple_clear('$_[0]',$name,$spec)."\n" =>delete$self->{captures}=>$quote_opts }if (my$hspec=$spec->{handles}){my$asserter=$spec->{asserter}||= '_assert_'.$name;my@specs=do {if (ref($hspec)eq 'ARRAY'){map [$_=>$_ ],@$hspec}elsif (ref($hspec)eq 'HASH'){map [$_=>ref($hspec->{$_})? @{$hspec->{$_}}: $hspec->{$_}],keys %$hspec}elsif (!ref($hspec)){require Moo::Role;_load_module$hspec;map [$_=>$_ ],Moo::Role->methods_provided_by($hspec)}else {croak "You gave me a handles of ${hspec} and I have no idea why"}};for my$delegation_spec (@specs){my ($proxy,$target,@args)=@$delegation_spec;_die_overwrite($into,$proxy,'a delegation')if!$spec->{allow_overwrite}&& defined &{"${into}::${proxy}"};$self->{captures}={};$methods{$proxy}=quote_sub "${into}::${proxy}" =>$self->_generate_delegation($asserter,$target,\@args)=>delete$self->{captures}=>$quote_opts }}if (my$asserter=$spec->{asserter}){_die_overwrite($into,$asserter,'an asserter')if!$spec->{allow_overwrite}&& defined &{"${into}::${asserter}"};local$self->{captures}={};$methods{$asserter}=quote_sub "${into}::${asserter}" =>$self->_generate_asserter($name,$spec)=>delete$self->{captures}=>$quote_opts }\%methods}sub merge_specs {my ($self,@specs)=@_;my$spec=shift@specs;for my$old_spec (@specs){for my$key (keys %$old_spec){if ($key eq 'handles'){}elsif ($key eq 'moosify'){$spec->{$key}=[map {ref $_ eq 'ARRAY' ? @$_ : $_}grep defined,($old_spec->{$key},$spec->{$key})]}elsif ($key eq 'builder' || $key eq 'default'){$spec->{$key}=$old_spec->{$key}if!(exists$spec->{builder}|| exists$spec->{default})}elsif (!exists$spec->{$key}){$spec->{$key}=$old_spec->{$key}}}}$spec}sub is_simple_attribute {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(lazy default builder coerce isa trigger predicate weak_ref)}sub is_simple_get {my ($self,$name,$spec)=@_;!($spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub is_simple_set {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(coerce isa trigger weak_ref)}sub has_default {my ($self,$name,$spec)=@_;$spec->{builder}or exists$spec->{default}or (($spec->{is}||'')eq 'lazy')}sub has_eager_default {my ($self,$name,$spec)=@_;(!$spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub _generate_get {my ($self,$name,$spec)=@_;my$simple=$self->_generate_simple_get('$_[0]',$name,$spec);if ($self->is_simple_get($name,$spec)){$simple}else {$self->_generate_use_default('$_[0]',$name,$spec,$self->_generate_simple_has('$_[0]',$name,$spec),)}}sub generate_simple_has {my$self=shift;$self->{captures}={};my$code=$self->_generate_simple_has(@_);($code,delete$self->{captures})}sub _generate_simple_has {my ($self,$me,$name)=@_;"exists ${me}->{${\quotify $name}}"}sub _generate_simple_clear {my ($self,$me,$name)=@_;"    delete ${me}->{${\quotify $name}}\n"}sub generate_get_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_get_default(@_);($code,delete$self->{captures})}sub generate_use_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_use_default(@_);($code,delete$self->{captures})}sub _generate_use_default {my ($self,$me,$name,$spec,$test)=@_;my$get_value=$self->_generate_get_default($me,$name,$spec);if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce})}$test." ? \n" .$self->_generate_simple_get($me,$name,$spec)."\n:" .($spec->{isa}? "    do {\n      my \$value = ".$get_value.";\n" ."      ".$self->_generate_isa_check($name,'$value',$spec->{isa}).";\n" ."      ".$self->_generate_simple_set($me,$name,$spec,'$value')."\n" ."    }\n" : '    ('.$self->_generate_simple_set($me,$name,$spec,$get_value).")\n")}sub _generate_get_default {my ($self,$me,$name,$spec)=@_;if (exists$spec->{default}){ref$spec->{default}? $self->_generate_call_code($name,'default',$me,$spec->{default}): quotify$spec->{default}}else {"${me}->${\$spec->{builder}}"}}sub generate_simple_get {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_simple_get(@args);($code,delete$self->{captures})}sub _generate_simple_get {my ($self,$me,$name)=@_;my$name_str=quotify$name;"${me}->{${name_str}}"}sub _generate_set {my ($self,$name,$spec)=@_;my ($me,$source)=('$_[0]','$_[1]');if ($self->is_simple_set($name,$spec)){return$self->_generate_simple_set($me,$name,$spec,$source)}my ($coerce,$trigger,$isa_check)=@{$spec}{qw(coerce trigger isa)};if ($coerce){$source=$self->_generate_coerce($name,$source,$coerce)}if ($isa_check){'scalar do { my $value = '.$source.";\n" .'  ('.$self->_generate_isa_check($name,'$value',$isa_check)."),\n" .'  ('.$self->_generate_simple_set($me,$name,$spec,'$value')."),\n" .($trigger ? '('.$self->_generate_trigger($name,$me,'$value',$trigger)."),\n" : '').'  ('.$self->_generate_simple_get($me,$name,$spec)."),\n" ."}"}elsif ($trigger){my$set=$self->_generate_simple_set($me,$name,$spec,$source);"scalar (\n" .'  ('.$self->_generate_trigger($name,$me,"($set)",$trigger)."),\n" .'  ('.$self->_generate_simple_get($me,$name,$spec)."),\n" .")"}else {'('.$self->_generate_simple_set($me,$name,$spec,$source).')'}}sub generate_coerce {my$self=shift;$self->{captures}={};my$code=$self->_generate_coerce(@_);($code,delete$self->{captures})}sub _attr_desc {my ($name,$init_arg)=@_;return quotify($name)if!defined($init_arg)or $init_arg eq $name;return quotify($name).' (constructor argument: '.quotify($init_arg).')'}sub _generate_coerce {my ($self,$name,$value,$coerce,$init_arg)=@_;$self->_wrap_attr_exception($name,"coercion",$init_arg,$self->_generate_call_code($name,'coerce',"${value}",$coerce),1,)}sub generate_trigger {my$self=shift;$self->{captures}={};my$code=$self->_generate_trigger(@_);($code,delete$self->{captures})}sub _generate_trigger {my ($self,$name,$obj,$value,$trigger)=@_;$self->_generate_call_code($name,'trigger',"${obj}, ${value}",$trigger)}sub generate_isa_check {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_isa_check(@args);($code,delete$self->{captures})}sub _wrap_attr_exception {my ($self,$name,$step,$arg,$code,$want_return)=@_;my$prefix=quotify("${step} for "._attr_desc($name,$arg).' failed: ');"do {\n" .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n" .'    init_arg => '.quotify($arg).",\n" .'    name     => '.quotify($name).",\n" .'    step     => '.quotify($step).",\n" ."  };\n" .($want_return ? '  (my $_return),'."\n" : '').'  (my $_error), (my $_old_error = $@);'."\n" ."  (eval {\n" .'    ($@ = $_old_error),'."\n" .'    (' .($want_return ? '$_return ='."\n" : '').$code."),\n" ."    1\n" ."  } or\n" .'    $_error = CORE::ref $@ ? $@ : '.$prefix.'.$@);'."\n" .'  ($@ = $_old_error),'."\n" .'  (defined $_error and CORE::die $_error);'."\n" .($want_return ? '  $_return;'."\n" : '')."}\n"}sub _generate_isa_check {my ($self,$name,$value,$check,$init_arg)=@_;$self->_wrap_attr_exception($name,"isa check",$init_arg,$self->_generate_call_code($name,'isa_check',$value,$check))}sub _generate_call_code {my ($self,$name,$type,$values,$sub)=@_;$sub=\&{$sub}if blessed($sub);if (my$quoted=quoted_from_sub($sub)){my$local=1;if ($values eq '@_' || $values eq '$_[0]'){$local=0;$values='@_'}my$code=$quoted->[1];if (my$captures=$quoted->[2]){my$cap_name=qq{\$${type}_captures_for_}.sanitize_identifier($name);$self->{captures}->{$cap_name}=\$captures;Sub::Quote::inlinify($code,$values,Sub::Quote::capture_unroll($cap_name,$captures,6),$local)}else {Sub::Quote::inlinify($code,$values,undef,$local)}}else {my$cap_name=qq{\$${type}_for_}.sanitize_identifier($name);$self->{captures}->{$cap_name}=\$sub;"${cap_name}->(${values})"}}sub _sanitize_name {sanitize_identifier($_[1])}sub generate_populate_set {my$self=shift;$self->{captures}={};my$code=$self->_generate_populate_set(@_);($code,delete$self->{captures})}sub _generate_populate_set {my ($self,$me,$name,$spec,$source,$test,$init_arg)=@_;my$has_default=$self->has_eager_default($name,$spec);if (!($has_default || $test)){return ''}if ($has_default){my$get_default=$self->_generate_get_default($me,$name,$spec);$source=$test ? "(\n  ${test}\n" ."   ? ${source}\n   : " .$get_default .")" : $get_default}if ($spec->{coerce}){$source=$self->_generate_coerce($name,$source,$spec->{coerce},$init_arg)}if ($spec->{isa}){$source='scalar do { my $value = '.$source.";\n" .'  ('.$self->_generate_isa_check($name,'$value',$spec->{isa},$init_arg)."),\n" ."  \$value\n" ."}\n"}my$set=$self->_generate_simple_set($me,$name,$spec,$source);my$trigger=$spec->{trigger}? $self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger}): undef;if ($has_default){"($set)," .($trigger && $test ? "($test and $trigger)," : '')."\n"}else {"($test and ($set)" .($trigger ? ", ($trigger)" : '')."),\n"}}sub _generate_core_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;"${me}->{${name_str}} = ${value}"}sub _generate_simple_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;my$simple=$self->_generate_core_set($me,$name,$spec,$value);if ($spec->{weak_ref}){require Scalar::Util;my$get=$self->_generate_simple_get($me,$name,$spec);my$weak_simple=_CAN_WEAKEN_READONLY ? "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }" : <<"EOC"}else {$simple}}sub _generate_getset {my ($self,$name,$spec)=@_;q{(@_ > 1}."\n      ? ".$self->_generate_set($name,$spec)."\n      : ".$self->_generate_get($name,$spec)."\n    )"}sub _generate_asserter {my ($self,$name,$spec)=@_;my$name_str=quotify($name);"do {\n" ."  my \$val = ".$self->_generate_get($name,$spec).";\n" ."  ".$self->_generate_simple_has('$_[0]',$name,$spec)."\n" ."    or Carp::croak(q{Attempted to access '}.${name_str}.q{' but it is not set});\n" ."  \$val;\n" ."}\n"}sub _generate_delegation {my ($self,$asserter,$target,$args)=@_;my$arg_string=do {if (@$args){$self->{captures}{'@curries'}=$args;'@curries, @_'}else {'@_'}};"shift->${asserter}->${target}(${arg_string});"}sub _generate_xs {my ($self,$type,$into,$name,$slot)=@_;Class::XSAccessor->import(class=>$into,$type=>{$name=>$slot },replace=>1,);$into->can($name)}sub default_construction_string {'{}'}sub _validate_codulatable {my ($self,$setting,$value,$into,$appended)=@_;my$error;if (blessed$value){local $@;no warnings 'void';eval {\&$value;1}and return 1;$error="could not be converted to a coderef: $@"}elsif (ref$value eq 'CODE'){return 1}else {$error='is not a coderef or code-convertible object'}croak "Invalid $setting '" .($INC{'overload.pm'}? overload::StrVal($value): $value)."' for $into " .$error .($appended ? " $appended" : '')}1;
          ( eval { Scalar::Util::weaken($simple); 1 }
            ? do { no warnings 'void'; $get }
            : do {
              if( \$@ =~ /Modification of a read-only value attempted/) {
                require Carp;
                Carp::croak( sprintf (
                  'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                  $name_str,
                ) );
              } else {
                die \$@;
              }
            }
          )
  EOC
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;use Moo::_strictures;use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quotify);use Moo::_Utils qw(_getglob);use Moo::_mro;sub generate_method {my ($self,$into)=@_;quote_sub "${into}::BUILDALL" =>join('',$self->_handle_subbuild($into),qq{    my \$self = shift;\n},$self->buildall_body_for($into,'$self','@_'),qq{    return \$self\n},)=>{}=>{no_defer=>1 }}sub _handle_subbuild {my ($self,$into)=@_;'    if (ref($_[0]) ne '.quotify($into).') {'."\n".'      return shift->Moo::Object::BUILDALL(@_)'.";\n".'    }'."\n"}sub buildall_body_for {my ($self,$into,$me,$args)=@_;my@builds=grep *{_getglob($_)}{CODE},map "${_}::BUILD",reverse @{mro::get_linear_isa($into)};'    (('.$args.')[0]->{__no_BUILD__} or ('."\n" .join('',map qq{      ${me}->${_}(${args}),\n},@builds)."    )),\n"}1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;use Moo::_strictures;use Sub::Quote qw(quote_sub quotify);use Sub::Defer;use Moo::_Utils qw(_getstash _getglob);use Moo::_mro;use Scalar::Util qw(weaken);use Carp qw(croak);use Carp::Heavy ();BEGIN {our@CARP_NOT=qw(Sub::Defer)}BEGIN {local$Moo::sification::disabled=1;require Moo;Moo->import}sub register_attribute_specs {my ($self,@new_specs)=@_;$self->assert_constructor;my$specs=$self->{attribute_specs}||={};my$ag=$self->accessor_generator;while (my ($name,$new_spec)=splice@new_specs,0,2){if ($name =~ s/^\+//){croak "has '+${name}' given but no ${name} attribute already exists" unless my$old_spec=$specs->{$name};$ag->merge_specs($new_spec,$old_spec)}if ($new_spec->{required}&&!($ag->has_default($name,$new_spec)||!exists$new_spec->{init_arg}|| defined$new_spec->{init_arg})){croak "You cannot have a required attribute (${name})" ." without a default, builder, or an init_arg"}$new_spec->{index}=scalar keys %$specs unless defined$new_spec->{index};$specs->{$name}=$new_spec}$self}sub all_attribute_specs {$_[0]->{attribute_specs}}sub accessor_generator {$_[0]->{accessor_generator}}sub construction_string {my ($self)=@_;$self->{construction_string}||= $self->_build_construction_string}sub buildall_generator {require Method::Generate::BuildAll;Method::Generate::BuildAll->new}sub _build_construction_string {my ($self)=@_;my$builder=$self->{construction_builder};$builder ? $self->$builder : 'bless(' .$self->accessor_generator->default_construction_string .', $class);'}sub install_delayed {my ($self)=@_;$self->assert_constructor;my$package=$self->{package};my (undef,@isa)=@{mro::get_linear_isa($package)};my$isa=join ',',@isa;my (undef,$from_file,$from_line)=caller(Carp::short_error_loc());my$constructor=defer_sub "${package}::new"=>sub {my (undef,@new_isa)=@{mro::get_linear_isa($package)};if (join(',',@new_isa)ne $isa){my ($expected_new)=grep {*{_getglob($_.'::new')}{CODE}}@isa;my ($found_new)=grep {*{_getglob($_.'::new')}{CODE}}@new_isa;if (($found_new||'')ne ($expected_new||'')){$found_new ||= 'none';$expected_new ||= 'none';croak "Expected parent constructor of $package to be" ." $expected_new, but found $found_new: changing the inheritance" ." chain (\@ISA) at runtime (after $from_file line $from_line) is unsupported"}}my$constructor=$self->generate_method($package,'new',$self->{attribute_specs},{no_install=>1,no_defer=>1 });$self->{inlined}=1;weaken($self->{constructor}=$constructor);$constructor};$self->{inlined}=0;weaken($self->{constructor}=$constructor);$self}sub current_constructor {my ($self,$package)=@_;return *{_getglob("${package}::new")}{CODE}}sub assert_constructor {my ($self)=@_;my$package=$self->{package}or return 1;my$current=$self->current_constructor($package)or return 1;my$constructor=$self->{constructor}or croak "Unknown constructor for $package already exists";croak "Constructor for $package has been replaced with an unknown sub" if$constructor!=$current;croak "Constructor for $package has been inlined and cannot be updated" if$self->{inlined}}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$quote_opts={%{$quote_opts||{}},package=>$into,};for my$no_init (grep!exists($spec->{$_}{init_arg}),keys %$spec){$spec->{$no_init}{init_arg}=$no_init}local$self->{captures}={};my$into_buildargs=$into->can('BUILDARGS');my$body ='    my $invoker = CORE::shift();'."\n" .'    my $class = CORE::ref($invoker) ? CORE::ref($invoker) : $invoker;'."\n" .$self->_handle_subconstructor($into,$name).($into_buildargs && $into_buildargs!=\&Moo::Object::BUILDARGS ? $self->_generate_args_via_buildargs : $self->_generate_args).$self->_check_required($spec).'    my $new = '.$self->construction_string.";\n" .$self->_assign_new($spec).($into->can('BUILD')? $self->buildall_generator->buildall_body_for($into,'$new','$args'): '').'    return $new;'."\n";if ($into->can('DEMOLISH')){require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new->generate_method($into)}quote_sub "${into}::${name}"=>$body,$self->{captures},$quote_opts||{}}sub _handle_subconstructor {my ($self,$into,$name)=@_;if (my$gen=$self->{subconstructor_handler}){'    if ($class ne '.quotify($into).') {'."\n".$gen.'    }'."\n"}else {''}}sub _cap_call {my ($self,$code,$captures)=@_;@{$self->{captures}}{keys %$captures}=values %$captures if$captures;$code}sub _generate_args_via_buildargs {my ($self)=@_;q{    my $args = $class->BUILDARGS(@_);}."\n" .q{    Carp::croak("BUILDARGS did not return a hashref") unless CORE::ref($args) eq 'HASH';} ."\n"}sub _generate_args {my ($self)=@_;return <<'_EOA'}sub _assign_new {my ($self,$spec)=@_;my$ag=$self->accessor_generator;my%test;NAME: foreach my$name (sort keys %$spec){my$attr_spec=$spec->{$name};next NAME unless defined($attr_spec->{init_arg})or $ag->has_eager_default($name,$attr_spec);$test{$name}=$attr_spec->{init_arg}}join '',map {my$arg=$test{$_};my$arg_key=quotify($arg);my$test=defined$arg ? "exists \$args->{$arg_key}" : undef;my$source=defined$arg ? "\$args->{$arg_key}" : undef;my$attr_spec=$spec->{$_};$self->_cap_call($ag->generate_populate_set('$new',$_,$attr_spec,$source,$test,$arg,))}sort keys%test}sub _check_required {my ($self,$spec)=@_;my@required_init=map$spec->{$_}{init_arg},grep {my$s=$spec->{$_};$s->{required}and not($s->{builder}or exists$s->{default})}sort keys %$spec;return '' unless@required_init;'    if (my @missing = grep !exists $args->{$_}, ' .join(', ',map quotify($_),@required_init).') {'."\n" .q{      Carp::croak("Missing required arguments: ".CORE::join(', ', sort @missing));}."\n" ."    }\n"}sub new {my$class=shift;delete _getstash(__PACKAGE__)->{new};bless$class->BUILDARGS(@_),$class}Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(attribute_specs=>{is=>'ro',reader=>'all_attribute_specs',},accessor_generator=>{is=>'ro' },construction_string=>{is=>'lazy' },construction_builder=>{is=>'bare' },subconstructor_handler=>{is=>'ro' },package=>{is=>'bare' },);if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for(__PACKAGE__)}1;
      my $args = scalar @_ == 1
        ? CORE::ref $_[0] eq 'HASH'
          ? { %{ $_[0] } }
          : Carp::croak("Single parameters to new() must be a HASH ref"
              . " data => ". $_[0])
        : @_ % 2
          ? Carp::croak("The new() method for $class expects a hash reference or a"
              . " key/value list. You passed an odd number of arguments")
          : {@_}
      ;
  _EOA
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;use Moo::_strictures;use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quotify);use Moo::_Utils qw(_getglob);use Moo::_mro;BEGIN {*_USE_DGD="$]" < 5.014 ? sub(){1}: sub(){0};require Devel::GlobalDestruction if _USE_DGD()}sub generate_method {my ($self,$into)=@_;quote_sub "${into}::DEMOLISHALL",join '',$self->_handle_subdemolish($into),qq{    my \$self = shift;\n},$self->demolishall_body_for($into,'$self','@_'),qq{    return \$self\n};quote_sub "${into}::DESTROY",join '',q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;!.(_USE_DGD ? q!
        require Devel::GlobalDestruction;! : '').q!
        package !.$into.q!;
        eval {
          $self->DEMOLISHALL(!.(_USE_DGD ? 'Devel::GlobalDestruction::in_global_destruction()' : q[${^GLOBAL_PHASE} eq 'DESTRUCT']).q!);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !}sub demolishall_body_for {my ($self,$into,$me,$args)=@_;my@demolishers=grep *{_getglob($_)}{CODE},map "${_}::DEMOLISH",@{mro::get_linear_isa($into)};join '',qq{    package $into;\n},map qq{    ${me}->${_}(${args});\n},@demolishers}sub _handle_subdemolish {my ($self,$into)=@_;'    if (ref($_[0]) ne '.quotify($into).') {'."\n"."      package $into;\n".'      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".'    }'."\n"}1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Module/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD';
  package Module::Build;use 5.006;use strict;use warnings;use File::Spec ();use File::Path ();use File::Basename ();use Perl::OSType ();use Module::Build::Base;our@ISA=qw(Module::Build::Base);our$VERSION='0.4229';$VERSION=eval$VERSION;sub _interpose_module {my ($self,$mod)=@_;eval "use $mod";die $@ if $@;no strict 'refs';my$top_class=$mod;while (@{"${top_class}::ISA"}){last if ${"${top_class}::ISA"}[0]eq $ISA[0];$top_class=${"${top_class}::ISA"}[0]}@{"${top_class}::ISA"}=@ISA;@ISA=($mod)}if (grep {-e File::Spec->catfile($_,qw(Module Build Platform),$^O).'.pm'}@INC){__PACKAGE__->_interpose_module("Module::Build::Platform::$^O")}elsif (my$ostype=os_type()){__PACKAGE__->_interpose_module("Module::Build::Platform::$ostype")}else {warn "Unknown OS type '$^O' - using default settings\n"}sub os_type {return Perl::OSType::os_type()}sub is_vmsish {return Perl::OSType::is_os_type('VMS')}sub is_windowsish {return Perl::OSType::is_os_type('Windows')}sub is_unixish {return Perl::OSType::is_os_type('Unix')}1;
MODULE_BUILD

$fatpacked{"Module/Build/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_BASE';
  package Module::Build::Base;use 5.006;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Carp;use Cwd ();use File::Copy ();use File::Find ();use File::Path ();use File::Basename ();use File::Spec 0.82 ();use File::Compare ();use Module::Build::Dumper ();use Text::ParseWords ();use Module::Metadata;use Module::Build::Notes;use Module::Build::Config;use version;sub new {my$self=shift()->_construct(@_);$self->{invoked_action}=$self->{action}||= 'Build_PL';$self->cull_args(@ARGV);die "Too early to specify a build action '$self->{action}'.  Do 'Build $self->{action}' instead.\n" if$self->{action}&& $self->{action}ne 'Build_PL';$self->check_manifest;$self->auto_require;if(grep {!$_}$self->check_prereq,$self->check_autofeatures){$self->log_warn(<<EOF);unless ($self->dist_name eq 'Module-Build' || $ENV{PERL5_CPANPLUS_IS_RUNNING}|| $ENV{PERL5_CPAN_IS_RUNNING}){$self->log_warn("Run 'Build installdeps' to install missing prerequisites.\n\n")}}$self->{properties}{_added_to_INC}=[$self->_added_to_INC ];$self->set_bundle_inc;$self->dist_name;$self->dist_version;$self->release_status;$self->_guess_module_name unless$self->module_name;$self->_find_nested_builds;return$self}sub resume {my$package=shift;my$self=$package->_construct(@_);$self->read_config;my@added_earlier=@{$self->{properties}{_added_to_INC}|| []};@INC=($self->_added_to_INC,@added_earlier,$self->_default_INC);unless ($package->isa($self->build_class)){my$build_class=$self->build_class;my$config_dir=$self->config_dir || '_build';my$build_lib=File::Spec->catdir($config_dir,'lib');unshift(@INC,$build_lib);unless ($build_class->can('new')){eval "require $build_class; 1" or die "Failed to re-load '$build_class': $@"}return$build_class->resume(@_)}unless ($self->_perl_is_same($self->{properties}{perl})){my$perl=$self->find_perl_interpreter;die(<<"DIEFATAL")}$self->cull_args(@ARGV);unless ($self->allow_mb_mismatch){my$mb_version=$Module::Build::VERSION;if ($mb_version ne $self->{properties}{mb_version}){$self->log_warn(<<"MISMATCH")}}$self->{invoked_action}=$self->{action}||= 'build';return$self}sub new_from_context {my ($package,%args)=@_;$package->run_perl_script('Build.PL',[],[$package->unparse_args(\%args)]);return$package->resume}sub current {local@ARGV;return shift()->resume}sub _construct {my ($package,%input)=@_;my$args=delete$input{args}|| {};my$config=delete$input{config}|| {};my$self=bless {args=>{%$args},config=>Module::Build::Config->new(values=>$config),properties=>{base_dir=>$package->cwd,mb_version=>$Module::Build::VERSION,%input,},phash=>{},stash=>{},},$package;$self->_set_defaults;my ($p,$ph)=($self->{properties},$self->{phash});for (qw(notes config_data features runtime_params cleanup auto_features)){my$file=File::Spec->catfile($self->config_dir,$_);$ph->{$_}=Module::Build::Notes->new(file=>$file);$ph->{$_}->restore if -e $file;if (exists$p->{$_}){my$vals=delete$p->{$_};for my$k (sort keys %$vals){$self->$_($k,$vals->{$k})}}}$p->{perl}=$self->find_perl_interpreter or $self->log_warn("Warning: Can't locate your perl binary");my$blibdir=sub {File::Spec->catdir($p->{blib},@_)};$p->{bindoc_dirs}||= [$blibdir->("script")];$p->{libdoc_dirs}||= [$blibdir->("lib"),$blibdir->("arch")];$p->{dist_author}=[$p->{dist_author}]if defined$p->{dist_author}and not ref$p->{dist_author};$p->{requires}=delete$p->{prereq}if defined$p->{prereq};$p->{script_files}=delete$p->{scripts}if defined$p->{scripts};for ('extra_compiler_flags','extra_linker_flags'){$p->{$_}=[$self->split_like_shell($p->{$_})]if exists$p->{$_}}for ('include_dirs'){$p->{$_}=[$p->{$_}]if exists$p->{$_}&&!ref$p->{$_}}$self->add_to_cleanup(@{delete$p->{add_to_cleanup}})if$p->{add_to_cleanup};return$self}sub log_info {my$self=shift;print @_ if ref($self)&& ($self->verbose ||!$self->quiet)}sub log_verbose {my$self=shift;print @_ if ref($self)&& $self->verbose}sub log_debug {my$self=shift;print @_ if ref($self)&& $self->debug}sub log_warn {shift;if (@_ and $_[-1]!~ /\n$/){my (undef,$file,$line)=caller();warn @_," at $file line $line.\n"}else {warn @_}}sub _default_install_paths {my$self=shift;my$c=$self->{config};my$p={};my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');my$bindoc=$c->get('installman1dir')|| undef;my$libdoc=$c->get('installman3dir')|| undef;my$binhtml=$c->get('installhtml1dir')|| $c->get('installhtmldir')|| undef;my$libhtml=$c->get('installhtml3dir')|| $c->get('installhtmldir')|| undef;$p->{install_sets}={core=>{lib=>$c->get('installprivlib'),arch=>$c->get('installarchlib'),bin=>$c->get('installbin'),script=>$c->get('installscript'),bindoc=>$bindoc,libdoc=>$libdoc,binhtml=>$binhtml,libhtml=>$libhtml,},site=>{lib=>$c->get('installsitelib'),arch=>$c->get('installsitearch'),bin=>$c->get('installsitebin')|| $c->get('installbin'),script=>$c->get('installsitescript')|| $c->get('installsitebin')|| $c->get('installscript'),bindoc=>$c->get('installsiteman1dir')|| $bindoc,libdoc=>$c->get('installsiteman3dir')|| $libdoc,binhtml=>$c->get('installsitehtml1dir')|| $binhtml,libhtml=>$c->get('installsitehtml3dir')|| $libhtml,},vendor=>{lib=>$c->get('installvendorlib'),arch=>$c->get('installvendorarch'),bin=>$c->get('installvendorbin')|| $c->get('installbin'),script=>$c->get('installvendorscript')|| $c->get('installvendorbin')|| $c->get('installscript'),bindoc=>$c->get('installvendorman1dir')|| $bindoc,libdoc=>$c->get('installvendorman3dir')|| $libdoc,binhtml=>$c->get('installvendorhtml1dir')|| $binhtml,libhtml=>$c->get('installvendorhtml3dir')|| $libhtml,},};$p->{original_prefix}={core=>$c->get('installprefixexp')|| $c->get('installprefix')|| $c->get('prefixexp')|| $c->get('prefix')|| '',site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',};$p->{original_prefix}{site}||= $p->{original_prefix}{core};$p->{install_base_relpaths}={lib=>['lib','perl5'],arch=>['lib','perl5',$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],};$p->{prefix_relpaths}={core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},};return$p}sub _find_nested_builds {my$self=shift;my$r=$self->recurse_into or return;my ($file,@r);if (!ref($r)&& $r eq 'auto'){local*DH;opendir DH,$self->base_dir or die "Can't scan directory " .$self->base_dir ." for nested builds: $!";while (defined($file=readdir DH)){my$subdir=File::Spec->catdir($self->base_dir,$file);next unless -d $subdir;push@r,$subdir if -e File::Spec->catfile($subdir,'Build.PL')}}$self->recurse_into(\@r)}sub cwd {return Cwd::cwd()}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;\\|'"\[\]\{\}]+$/){push@quoted,$_}else {s/('+)/'"$1"'/g;push@quoted,qq('$_')}}return join " ",@quoted}sub _backticks {my ($self,@cmd)=@_;if ($self->have_forkpipe){local*FH;my$pid=open*FH,"-|";if ($pid){return wantarray ? <FH> : join '',<FH>}else {die "Can't execute @cmd: $!\n" unless defined$pid;exec {$cmd[0]}@cmd}}else {my$cmd=$self->_quote_args(@cmd);return `$cmd`}}sub have_forkpipe {1}sub _perl_is_same {my ($self,$perl)=@_;my@cmd=($perl);if ($ENV{PERL_CORE}){push@cmd,'-I' .File::Spec->catdir(File::Basename::dirname($perl),'lib')}push@cmd,qw(-MConfig=myconfig -e print -e myconfig);return$self->_backticks(@cmd)eq Config->myconfig}{my$known_perl;sub find_perl_interpreter {my$self=shift;return$known_perl if defined($known_perl);return$known_perl=$self->_discover_perl_interpreter}}sub _discover_perl_interpreter {my$proto=shift;my$c=ref($proto)? $proto->{config}: 'Module::Build::Config';my$perl=$^X;my$perl_basename=File::Basename::basename($perl);my@potential_perls;push(@potential_perls,$perl)if File::Spec->file_name_is_absolute($perl);my$abs_perl=File::Spec->rel2abs($perl);push(@potential_perls,$abs_perl);if ($ENV{PERL_CORE}){require ExtUtils::CBuilder;my$perl_src=Cwd::realpath(ExtUtils::CBuilder->perl_src);if (defined($perl_src)&& length($perl_src)){my$uninstperl=File::Spec->rel2abs(File::Spec->catfile($perl_src,$perl_basename));push(@potential_perls,$uninstperl)}}else {push(@potential_perls,$c->get('perlpath'));push(@potential_perls,map File::Spec->catfile($_,$perl_basename),File::Spec->path())}my$exe=$c->get('exe_ext');for my$thisperl (@potential_perls){if (defined$exe){$thisperl .= $exe unless$thisperl =~ m/$exe$/i}if (-f $thisperl && $proto->_perl_is_same($thisperl)){return$thisperl}}my@paths=map File::Basename::dirname($_),@potential_perls;die "Can't locate the perl binary used to run this script " ."in (@paths)\n"}sub find_command {my ($self,$command)=@_;if(File::Spec->file_name_is_absolute($command)){return$self->_maybe_command($command)}else {for my$dir (File::Spec->path){my$abs=File::Spec->catfile($dir,$command);return$abs if$abs=$self->_maybe_command($abs)}}}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d $file;return}sub _is_interactive {return -t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT))}sub _is_unattended {my$self=shift;return$ENV{PERL_MM_USE_DEFAULT}|| (!$self->_is_interactive && eof STDIN)}sub _readline {my$self=shift;return undef if$self->_is_unattended;my$answer=<STDIN>;chomp$answer if defined$answer;return$answer}sub prompt {my$self=shift;my$mess=shift or die "prompt() called without a prompt message";my@def;@def=(shift)if @_;my@dispdef=scalar(@def)? ('[',(defined($def[0])? $def[0].' ' : ''),']'): (' ','');local $|=1;print "$mess ",@dispdef;if ($self->_is_unattended &&!@def){die <<EOF}my$ans=$self->_readline();if (!defined($ans)or!length($ans)){print "$dispdef[1]\n";$ans=scalar(@def)? $def[0]: ''}return$ans}sub y_n {my$self=shift;my ($mess,$def)=@_;die "y_n() called without a prompt message" unless$mess;die "Invalid default value: y_n() default must be 'y' or 'n'" if$def && $def !~ /^[yn]/i;my$answer;while (1){$answer=$self->prompt(@_);return 1 if$answer =~ /^y/i;return 0 if$answer =~ /^n/i;local $|=1;print "Please answer 'y' or 'n'.\n"}}sub current_action {shift->{action}}sub invoked_action {shift->{invoked_action}}sub notes {shift()->{phash}{notes}->access(@_)}sub config_data {shift()->{phash}{config_data}->access(@_)}sub runtime_params {shift->{phash}{runtime_params}->read(@_ ? shift : ())}sub auto_features {shift()->{phash}{auto_features}->access(@_)}sub features {my$self=shift;my$ph=$self->{phash};if (@_){my$key=shift;if ($ph->{features}->exists($key)){return$ph->{features}->access($key,@_)}if (my$info=$ph->{auto_features}->access($key)){my$disabled;for my$type (@{$self->prereq_action_types}){next if$type eq 'description' || $type eq 'recommends' ||!exists$info->{$type};my$prereqs=$info->{$type};for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}return$ph->{features}->access($key,@_)}my%features;my%auto_features=$ph->{auto_features}->access();while (my ($name,$info)=each%auto_features){my$failures=$self->prereq_failures($info);my$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$features{$name}=$disabled ? 0 : 1}%features=(%features,$ph->{features}->access());return wantarray ? %features : \%features}BEGIN {*feature=\&features}sub _mb_feature {my$self=shift;if (($self->module_name || '')eq 'Module::Build'){return$self->feature(@_)}else {require Module::Build::ConfigData;return Module::Build::ConfigData->feature(@_)}}sub _warn_mb_feature_deps {my$self=shift;my$name=shift;$self->log_warn("The '$name' feature is not available.  Please install missing\n" ."feature dependencies and try again.\n".$self->_feature_deps_msg($name)."\n")}sub add_build_element {my ($self,$elem)=@_;my$elems=$self->build_elements;push @$elems,$elem unless grep {$_ eq $elem}@$elems}sub ACTION_config_data {my$self=shift;return unless$self->has_config_data;my$module_name=$self->module_name or die "The config_data feature requires that 'module_name' be set";my$notes_name=$module_name .'::ConfigData';my$notes_pm=File::Spec->catfile($self->blib,'lib',split /::/,"$notes_name.pm");return if$self->up_to_date(['Build.PL',$self->config_file('config_data'),$self->config_file('features')],$notes_pm);$self->log_verbose("Writing config notes to $notes_pm\n");File::Path::mkpath(File::Basename::dirname($notes_pm));Module::Build::Notes->write_config_data (file=>$notes_pm,module=>$module_name,config_module=>$notes_name,config_data=>scalar$self->config_data,feature=>scalar$self->{phash}{features}->access(),auto_features=>scalar$self->auto_features,)}{my%valid_properties=(__PACKAGE__,{});my%additive_properties;sub _mb_classes {my$class=ref($_[0])|| $_[0];return ($class,$class->mb_parents)}sub valid_property {my ($class,$prop)=@_;return grep exists($valid_properties{$_}{$prop}),$class->_mb_classes}sub valid_properties {return keys %{shift->valid_properties_defaults()}}sub valid_properties_defaults {my%out;for my$class (reverse shift->_mb_classes){@out{keys %{$valid_properties{$class}}}=map {$_->()}values %{$valid_properties{$class}}}return \%out}sub array_properties {map {exists$additive_properties{$_}->{ARRAY}? @{$additive_properties{$_}->{ARRAY}}: ()}shift->_mb_classes}sub hash_properties {map {exists$additive_properties{$_}->{HASH}? @{$additive_properties{$_}->{HASH}}: ()}shift->_mb_classes}sub add_property {my ($class,$property)=(shift,shift);die "Property '$property' already exists" if$class->valid_property($property);my%p=@_==1 ? (default=>shift): @_;my$type=ref$p{default};$valid_properties{$class}{$property}=$type eq 'CODE' ? $p{default}: $type eq 'HASH' ? sub {return {%{$p{default}}}}: $type eq 'ARRAY'? sub {return [@{$p{default}}]}: sub {return$p{default}};push @{$additive_properties{$class}->{$type}},$property if$type;unless ($class->can($property)){my$sub=$type eq 'HASH' ? _make_hash_accessor($property,\%p): _make_accessor($property,\%p);no strict 'refs';*{"$class\::$property"}=$sub}return$class}sub property_error {my$self=shift;die 'ERROR: ',@_}sub _set_defaults {my$self=shift;$self->{properties}{build_class}||= ref$self;$self->{properties}{orig_dir}||= $self->{properties}{base_dir};my$defaults=$self->valid_properties_defaults;for my$prop (keys %$defaults){$self->{properties}{$prop}=$defaults->{$prop}unless exists$self->{properties}{$prop}}for my$prop ($self->array_properties){$self->{properties}{$prop}=[@{$defaults->{$prop}}]unless exists$self->{properties}{$prop}}for my$prop ($self->hash_properties){$self->{properties}{$prop}={%{$defaults->{$prop}}}unless exists$self->{properties}{$prop}}}}sub _make_hash_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;my$prop=$x->{$property};if (defined $_[0]&&!ref $_[0]){if (@_==1){return exists$prop->{$_[0]}? $prop->{$_[0]}: undef}elsif (@_ % 2==0){my%new=(%{$prop},@_);local $_=\%new;$x->{$property}=\%new if$check->($self);return$x->{$property}}else {die "Unexpected arguments for property '$property'\n"}}else {die "Unexpected arguments for property '$property'\n" if defined $_[0]&& ref $_[0]ne 'HASH';local $_=$_[0];$x->{$property}=shift if$check->($self)}}}sub _make_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;local $_=$_[0];$x->{$property}=shift if$check->($self);return$x->{$property}}}__PACKAGE__->add_property(auto_configure_requires=>1);__PACKAGE__->add_property(blib=>'blib');__PACKAGE__->add_property(build_class=>'Module::Build');__PACKAGE__->add_property(build_elements=>[qw(PL support pm xs share_dir pod script)]);__PACKAGE__->add_property(build_script=>'Build');__PACKAGE__->add_property(build_bat=>0);__PACKAGE__->add_property(bundle_inc=>[]);__PACKAGE__->add_property(bundle_inc_preload=>[]);__PACKAGE__->add_property(config_dir=>'_build');__PACKAGE__->add_property(dynamic_config=>1);__PACKAGE__->add_property(include_dirs=>[]);__PACKAGE__->add_property(license=>'unknown');__PACKAGE__->add_property(metafile=>'META.yml');__PACKAGE__->add_property(mymetafile=>'MYMETA.yml');__PACKAGE__->add_property(metafile2=>'META.json');__PACKAGE__->add_property(mymetafile2=>'MYMETA.json');__PACKAGE__->add_property(recurse_into=>[]);__PACKAGE__->add_property(use_rcfile=>1);__PACKAGE__->add_property(create_packlist=>1);__PACKAGE__->add_property(allow_mb_mismatch=>0);__PACKAGE__->add_property(config=>undef);__PACKAGE__->add_property(test_file_exts=>['.t']);__PACKAGE__->add_property(use_tap_harness=>0);__PACKAGE__->add_property(cpan_client=>'cpan');__PACKAGE__->add_property(tap_harness_args=>{});__PACKAGE__->add_property(pureperl_only=>0);__PACKAGE__->add_property(allow_pureperl=>0);__PACKAGE__->add_property('installdirs',default=>'site',check=>sub {return 1 if /^(core|site|vendor)$/;return shift->property_error($_ eq 'perl' ? 'Perhaps you meant installdirs to be "core" rather than "perl"?' : 'installdirs must be one of "core", "site", or "vendor"');return shift->property_error("Perhaps you meant 'core'?")if $_ eq 'perl';return 0},);{__PACKAGE__->add_property(html_css=>'')}{my@prereq_action_types=qw(requires build_requires test_requires conflicts recommends);for my$type (@prereq_action_types){__PACKAGE__->add_property($type=>{})}__PACKAGE__->add_property(prereq_action_types=>\@prereq_action_types)}__PACKAGE__->add_property($_=>{})for qw(get_options install_base_relpaths install_path install_sets meta_add meta_merge original_prefix prefix_relpaths configure_requires);__PACKAGE__->add_property($_)for qw(PL_files autosplit base_dir bindoc_dirs c_source cover create_license create_makefile_pl create_readme debugger destdir dist_abstract dist_author dist_name dist_suffix dist_version dist_version_from extra_compiler_flags extra_linker_flags has_config_data install_base libdoc_dirs magic_number mb_version module_name needs_compiler orig_dir perl pm_files pod_files pollute prefix program_name quiet recursive_test_files release_status script_files scripts share_dir sign test_files verbose debug xs_files extra_manify_args);sub config {my$self=shift;my$c=ref($self)? $self->{config}: 'Module::Build::Config';return$c->all_config unless @_;my$key=shift;return$c->get($key)unless @_;my$val=shift;return$c->set($key=>$val)}sub mb_parents {my@in_stack=(shift);my%seen=($in_stack[0]=>1);my ($current,@out);while (@in_stack){next unless defined($current=shift@in_stack)&& $current->isa('Module::Build::Base');push@out,$current;next if$current eq 'Module::Build::Base';no strict 'refs';unshift@in_stack,map {my$c=$_;substr($c,0,2)="main::" if substr($c,0,2)eq '::';$seen{$c}++ ? (): $c}@{"$current\::ISA"}}shift@out;return@out}sub extra_linker_flags {shift->_list_accessor('extra_linker_flags',@_)}sub extra_compiler_flags {shift->_list_accessor('extra_compiler_flags',@_)}sub _list_accessor {(my$self,local $_)=(shift,shift);my$p=$self->{properties};$p->{$_}=[@_]if @_;$p->{$_}=[]unless exists$p->{$_};return ref($p->{$_})? $p->{$_}: [$p->{$_}]}sub subclass {my ($pack,%opts)=@_;my$build_dir='_build';$pack->delete_filetree($build_dir)if -e $build_dir;die "Must provide 'code' or 'class' option to subclass()\n" unless$opts{code}or $opts{class};$opts{code}||= '';$opts{class}||= 'MyModuleBuilder';my$filename=File::Spec->catfile($build_dir,'lib',split '::',$opts{class}).'.pm';my$filedir=File::Basename::dirname($filename);$pack->log_verbose("Creating custom builder $filename in $filedir\n");File::Path::mkpath($filedir);die "Can't create directory $filedir: $!" unless -d $filedir;open(my$fh,'>',$filename)or die "Can't create $filename: $!";print$fh <<EOF;close$fh;unshift@INC,File::Spec->catdir(File::Spec->rel2abs($build_dir),'lib');eval "use $opts{class}";die $@ if $@;return$opts{class}}sub _guess_module_name {my$self=shift;my$p=$self->{properties};return if$p->{module_name};if ($p->{dist_version_from}&& -e $p->{dist_version_from}){my$mi=Module::Metadata->new_from_file($self->dist_version_from);$p->{module_name}=$mi->name}else {my$mod_path=my$mod_name=$p->{dist_name};$mod_name =~ s{-}{::}g;$mod_path =~ s{-}{/}g;$mod_path .= ".pm";if (-e $mod_path || -e "lib/$mod_path"){$p->{module_name}=$mod_name}else {$self->log_warn(<< 'END_WARN')}}}sub dist_name {my$self=shift;my$p=$self->{properties};my$me='dist_name';return$p->{$me}if defined$p->{$me};die "Can't determine distribution name, must supply either 'dist_name' or 'module_name' parameter" unless$self->module_name;($p->{$me}=$self->module_name)=~ s/::/-/g;return$p->{$me}}sub release_status {my ($self)=@_;my$me='release_status';my$p=$self->{properties};if (!defined$p->{$me}){$p->{$me}=$self->_is_dev_version ? 'testing' : 'stable'}unless ($p->{$me}=~ qr/\A(?:stable|testing|unstable)\z/){die "Illegal value '$p->{$me}' for $me\n"}if ($p->{$me}eq 'stable' && $self->_is_dev_version){my$version=$self->dist_version;die "Illegal value '$p->{$me}' with version '$version'\n"}return$p->{$me}}sub dist_suffix {my ($self)=@_;my$p=$self->{properties};my$me='dist_suffix';return$p->{$me}if defined$p->{$me};if ($self->release_status eq 'stable'){$p->{$me}=""}else {$p->{$me}=$self->_is_dev_version ? "" : "TRIAL" }return$p->{$me}}sub dist_version_from {my ($self)=@_;my$p=$self->{properties};my$me='dist_version_from';if ($self->module_name){$p->{$me}||= join('/','lib',split(/::/,$self->module_name)).'.pm'}return$p->{$me}|| undef}sub dist_version {my ($self)=@_;my$p=$self->{properties};my$me='dist_version';return$p->{$me}if defined$p->{$me};if (my$dist_version_from=$self->dist_version_from){my$version_from=File::Spec->catfile(split(qr{/},$dist_version_from));my$pm_info=Module::Metadata->new_from_file($version_from)or die "Can't find file $version_from to determine version";$p->{$me}=$self->normalize_version($pm_info->version());unless (defined$p->{$me}){die "Can't determine distribution version from $version_from"}}die ("Can't determine distribution version, must supply either 'dist_version',\n"."'dist_version_from', or 'module_name' parameter")unless defined$p->{$me};return$p->{$me}}sub _is_dev_version {my ($self)=@_;my$dist_version=$self->dist_version;my$version_obj=eval {version->new($dist_version)};return $@ ? 0 : $version_obj->is_alpha}sub dist_author {shift->_pod_parse('author')}sub dist_abstract {shift->_pod_parse('abstract')}sub _pod_parse {my ($self,$part)=@_;my$p=$self->{properties};my$member="dist_$part";return$p->{$member}if defined$p->{$member};my$docfile=$self->_main_docfile or return;open(my$fh,'<',$docfile)or return;require Module::Build::PodParser;my$parser=Module::Build::PodParser->new(fh=>$fh);my$method="get_$part";return$p->{$member}=$parser->$method()}sub version_from_file {return Module::Metadata->new_from_file($_[1])->version()}sub find_module_by_name {return Module::Metadata->find_module_by_name(@_[1,2])}{my%unlink_list_for_pid;sub _unlink_on_exit {my$self=shift;for my$f (@_){push @{$unlink_list_for_pid{$$}},$f if -f $f}return 1}END {for my$f (map glob($_),@{$unlink_list_for_pid{$$}|| []}){next unless -e $f;File::Path::rmtree($f,0,0)}}}sub add_to_cleanup {my$self=shift;my%files=map {$self->localize_file_path($_),1}@_;$self->{phash}{cleanup}->write(\%files)}sub cleanup {my$self=shift;my$all=$self->{phash}{cleanup}->read;return wantarray ? sort keys %$all : keys %$all}sub config_file {my$self=shift;return unless -d $self->config_dir;return File::Spec->catfile($self->config_dir,@_)}sub read_config {my ($self)=@_;my$file=$self->config_file('build_params')or die "Can't find 'build_params' in " .$self->config_dir;open(my$fh,'<',$file)or die "Can't read '$file': $!";my$ref=eval do {local $/;<$fh>};die if $@;close$fh;my$c;($self->{args},$c,$self->{properties})=@$ref;$self->{config}=Module::Build::Config->new(values=>$c)}sub has_config_data {my$self=shift;return scalar grep$self->{phash}{$_}->has_data(),qw(config_data features auto_features)}sub _write_data {my ($self,$filename,$data)=@_;my$file=$self->config_file($filename);open(my$fh,'>',$file)or die "Can't create '$file': $!";unless (ref($data)){print$fh $data;return}print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}sub write_config {my ($self)=@_;File::Path::mkpath($self->{properties}{config_dir});-d $self->{properties}{config_dir}or die "Can't mkdir $self->{properties}{config_dir}: $!";my@items=@{$self->prereq_action_types};$self->_write_data('prereqs',{map {$_,$self->$_()}@items });$self->_write_data('build_params',[$self->{args},$self->{config}->values_set,$self->{properties}]);$self->_write_data('magicnum',$self->magic_number(int rand 1_000_000));$self->{phash}{$_}->write()foreach qw(notes cleanup features auto_features config_data runtime_params)}{my%packlist_map=('^File::Spec'=>'Cwd','^Devel::AssertOS'=>'Devel::CheckOS',);sub _find_packlist {my ($self,$inst,$mod)=@_;my$lookup=$mod;my$packlist=eval {$inst->packlist($lookup)};if (!$packlist){while (my ($re,$new_mod)=each%packlist_map){if ($mod =~ qr/$re/){$lookup=$new_mod;$packlist=eval {$inst->packlist($lookup)};last}}}return$packlist ? $lookup : undef}sub set_bundle_inc {my$self=shift;my$bundle_inc=$self->{properties}{bundle_inc};my$bundle_inc_preload=$self->{properties}{bundle_inc_preload};return unless inc::latest->can('loaded_modules');require ExtUtils::Installed;my$inst=eval {ExtUtils::Installed->new(extra_libs=>[@INC])};if ($@){$self->log_warn(<< "EUI_ERROR");return}my@bundle_list=map {[$_,0 ]}inc::latest->loaded_modules;while(@bundle_list){my ($mod,$prereq)=@{shift@bundle_list};my$lookup=$self->_find_packlist($inst,$mod);if (!$lookup){die << "NO_PACKLIST"}else {push @{$prereq ? $bundle_inc_preload : $bundle_inc},$lookup}}}}sub check_autofeatures {my ($self)=@_;my$features=$self->auto_features;return 1 unless %$features;my$longest=sub {my@str=@_ or croak("no strings given");my@len=map({length($_)}@str);my$max=0;my$longest;for my$i (0..$#len){($max,$longest)=($len[$i],$str[$i])if($len[$i]> $max)}return($longest)};my$max_name_len=length($longest->(keys %$features));my ($num_disabled,$log_text)=(0,"\nChecking optional features...\n");for my$name (sort keys %$features){$log_text .= $self->_feature_deps_msg($name,$max_name_len)}$num_disabled=()=$log_text =~ /disabled/g;if ($num_disabled){$self->log_warn($log_text);return 0}else {$self->log_verbose($log_text);return 1}}sub _feature_deps_msg {my ($self,$name,$max_name_len)=@_;$max_name_len ||= length$name;my$features=$self->auto_features;my$info=$features->{$name};my$feature_text="$name" .'.' x ($max_name_len - length($name)+ 4);my ($log_text,$disabled)=('','');if (my$failures=$self->prereq_failures($info)){$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$feature_text .= $disabled ? "disabled\n" : "enabled\n";for my$type (@{$self->prereq_action_types}){next unless exists$failures->{$type};$feature_text .= "  $type:\n";my$prereqs=$failures->{$type};for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$required=($type =~ /^(?:\w+_)?(?:requires|conflicts)$/)? 1 : 0;my$prefix=($required)? '!' : '*';$feature_text .= "    $prefix $status->{message}\n"}}}else {$feature_text .= "enabled\n"}$log_text .= $feature_text if$disabled || $self->verbose;return$log_text}sub auto_config_requires {my ($self)=@_;my$p=$self->{properties};if ($self->dist_name ne 'Module-Build' && $self->auto_configure_requires &&!exists$p->{configure_requires}{'Module::Build'}){(my$ver=$VERSION)=~ s/^(\d+\.\d\d).*$/$1/;$self->log_warn(<<EOM);$self->_add_prereq('configure_requires','Module::Build',$ver)}if (inc::latest->can('loaded_module')){for my$mod (inc::latest->loaded_modules){next if exists$p->{configure_requires}{$mod};$self->_add_prereq('configure_requires',$mod,$mod->VERSION)}}return}sub auto_require {my ($self)=@_;my$p=$self->{properties};my$xs_files=$self->find_xs_files;if (!defined$p->{needs_compiler}){if ($self->pureperl_only && $self->allow_pureperl){$self->needs_compiler(0)}else {$self->needs_compiler(keys %$xs_files || defined$self->c_source)}}if ($self->needs_compiler){$self->_add_prereq('build_requires','ExtUtils::CBuilder',0);if (!$self->have_c_compiler){$self->log_warn(<<'EOM')}}if ($self->share_dir){$self->_add_prereq('requires','File::ShareDir','1.00')}return}sub _add_prereq {my ($self,$type,$module,$version)=@_;my$p=$self->{properties};$version=0 unless defined$version;if (exists$p->{$type}{$module}){return if$self->compare_versions($version,'<=',$p->{$type}{$module})}$self->log_verbose("Adding to $type\: $module => $version\n");$p->{$type}{$module}=$version;return 1}sub prereq_failures {my ($self,$info)=@_;my@types=@{$self->prereq_action_types};$info ||= {map {$_,$self->$_()}@types};my$out;for my$type (@types){my$prereqs=$info->{$type};for my$modname (keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ($type =~ /^(?:\w+_)?conflicts$/){next if!$status->{ok};$status->{conflicts}=delete$status->{need};$status->{message}="$modname ($status->{have}) conflicts with this distribution"}elsif ($type =~ /^(?:\w+_)?recommends$/){next if$status->{ok};$status->{message}=(!ref($status->{have})&& $status->{have}eq '<none>' ? "$modname is not installed" : "$modname ($status->{have}) is installed, but we prefer to have $spec")}else {next if$status->{ok}}$out->{$type}{$modname}=$status}}return$out}sub _enum_prereqs {my$self=shift;my%prereqs;for my$type (@{$self->prereq_action_types}){if ($self->can($type)){my$prereq=$self->$type()|| {};$prereqs{$type}=$prereq if %$prereq}}return \%prereqs}sub check_prereq {my$self=shift;my$info=$self->_enum_prereqs;return 1 unless$info;my$log_text="Checking prerequisites...\n";my$failures=$self->prereq_failures($info);if ($failures){$self->log_warn($log_text);for my$type (@{$self->prereq_action_types}){my$prereqs=$failures->{$type};$self->log_warn("  ${type}:\n")if keys %$prereqs;for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$prefix=($type =~ /^(?:\w+_)?recommends$/)? "* " : "! ";$self->log_warn("    $prefix $status->{message}\n")}}return 0}else {$self->log_verbose($log_text ."Looks good\n\n");return 1}}sub perl_version {my ($self)=@_;return $^V ? $self->perl_version_to_float(sprintf "%vd",$^V): $]}sub perl_version_to_float {my ($self,$version)=@_;return$version if grep(/\./,$version)< 2;$version =~ s/\./../;$version =~ s/\.(\d+)/sprintf '%03d', $1/eg;return$version}sub _parse_conditions {my ($self,$spec)=@_;return ">= 0" if not defined$spec;if ($spec =~ /^\s*([\w.]+)\s*$/){return (">= $spec")}else {return split /\s*,\s*/,$spec}}sub try_require {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,defined($spec)? $spec : 0);return unless$status->{ok};my$path=$modname;$path =~ s{::}{/}g;$path .= ".pm";if (defined$INC{$path}){return 1}elsif (exists$INC{$path}){return}else {return eval "require $modname"}}sub check_installed_status {my ($self,$modname,$spec)=@_;my%status=(need=>$spec);if ($modname eq 'perl'){$status{have}=$self->perl_version}elsif (eval {no strict;$status{have}=${"${modname}::VERSION"}}){}else {my$pm_info=Module::Metadata->new_from_module($modname);unless (defined($pm_info)){@status{qw(have message) }=('<none>',"$modname is not installed");return \%status}$status{have}=eval {$pm_info->version()};if ($spec and!defined($status{have})){@status{qw(have message) }=(undef,"Couldn't find a \$VERSION in prerequisite $modname");return \%status}}my@conditions=$self->_parse_conditions($spec);for (@conditions){my ($op,$version)=/^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x or die "Invalid prerequisite condition '$_' for $modname";$version=$self->perl_version_to_float($version)if$modname eq 'perl';next if$op eq '>=' and!$version;unless ($self->compare_versions($status{have},$op,$version)){$status{message}="$modname ($status{have}) is installed, but we need version $op $version";return \%status}}$status{ok}=1;return \%status}sub compare_versions {my$self=shift;my ($v1,$op,$v2)=@_;$v1=version->new($v1)unless eval {$v1->isa('version')};my$eval_str="\$v1 $op \$v2";my$result=eval$eval_str;$self->log_warn("error comparing versions: '$eval_str' $@")if $@;return$result}sub check_installed_version {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,$spec);if ($status->{ok}){return$status->{have}if$status->{have}and "$status->{have}" ne '<none>';return '0 but true'}$@=$status->{message};return 0}sub make_executable {my$self=shift;for (@_){my$current_mode=(stat $_)[2];chmod$current_mode | oct(111),$_}}sub is_executable {my ($self,$file)=@_;return -x $file}sub _startperl {shift()->config('startperl')}sub _added_to_INC {my$self=shift;my%seen;$seen{$_}++ foreach$self->_default_INC;return grep!$seen{$_}++,@INC}{my@default_inc;sub _default_INC {my$self=shift;return@default_inc if@default_inc;local$ENV{PERL5LIB};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;my@inc=$self->_backticks($perl,'-le','print for @INC');chomp@inc;return@default_inc=@inc}}sub print_build_script {my ($self,$fh)=@_;my$build_package=$self->build_class;my$closedata="";my$config_requires;if (-f $self->metafile){my$meta=eval {$self->read_metafile($self->metafile)};$config_requires=$meta && $meta->{prereqs}{configure}{requires}{'Module::Build'}}$config_requires ||= 0;my%q=map {$_,$self->$_()}qw(config_dir base_dir);$q{base_dir}=Win32::GetShortPathName($q{base_dir})if$self->is_windowsish;$q{magic_numfile}=$self->config_file('magicnum');my@myINC=$self->_added_to_INC;for (@myINC,values%q){$_=File::Spec->canonpath($_)unless$self->is_vmsish;s/([\\\'])/\\$1/g}my$quoted_INC=join ",\n",map "     '$_'",@myINC;my$shebang=$self->_startperl;my$magic_number=$self->magic_number;my$dot_in_inc_code=$INC[-1]eq '.' ? <<'END' : '';print$fh <<EOF}sub create_mymeta {my ($self)=@_;my ($meta_obj,$mymeta);my@metafiles=($self->metafile2,$self->metafile,);my@mymetafiles=($self->mymetafile2,$self->mymetafile,);for my$f (@mymetafiles){if ($self->delete_filetree($f)){$self->log_verbose("Removed previous '$f'\n")}}if ($self->try_require("CPAN::Meta","2.142060")){for my$file (@metafiles){next unless -f $file;$meta_obj=eval {CPAN::Meta->load_file($file,{lazy_validation=>0 })};last if$meta_obj}}my$mymeta_obj;if ($meta_obj){my%updated=(%{$meta_obj->as_struct({version=>2.0 })},prereqs=>$self->_normalize_prereqs,dynamic_config=>0,generated_by=>"Module::Build version $Module::Build::VERSION",);$mymeta_obj=CPAN::Meta->new(\%updated,{lazy_validation=>0 })}else {$mymeta_obj=$self->_get_meta_object(quiet=>0,dynamic=>0,fatal=>1,auto=>0)}my@created=$self->_write_meta_files($mymeta_obj,'MYMETA');$self->log_warn("Could not create MYMETA files\n")unless@created;return 1}sub create_build_script {my ($self)=@_;$self->write_config;$self->create_mymeta;my ($build_script,$dist_name,$dist_version)=map$self->$_(),qw(build_script dist_name dist_version);if ($self->delete_filetree($build_script)){$self->log_verbose("Removed previous script '$build_script'\n")}$self->log_info("Creating new '$build_script' script for ","'$dist_name' version '$dist_version'\n");open(my$fh,'>',$build_script)or die "Can't create '$build_script': $!";$self->print_build_script($fh);close$fh;$self->make_executable($build_script);return 1}sub check_manifest {my$self=shift;return unless -e 'MANIFEST';require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);$self->log_verbose("Checking whether your kit is complete...\n");if (my@missed=ExtUtils::Manifest::manicheck()){$self->log_warn("WARNING: the following files are missing in your kit:\n","\t",join("\n\t",@missed),"\n","Please inform the author.\n\n")}else {$self->log_verbose("Looks good\n\n")}}sub dispatch {my$self=shift;local$self->{_completed_actions}={};if (@_){my ($action,%p)=@_;my$args=$p{args}? delete($p{args}): {};local$self->{invoked_action}=$action;local$self->{args}={%{$self->{args}},%$args};local$self->{properties}={%{$self->{properties}},%p};return$self->_call_action($action)}die "No build action specified" unless$self->{action};local$self->{invoked_action}=$self->{action};$self->_call_action($self->{action})}sub _call_action {my ($self,$action)=@_;return if$self->{_completed_actions}{$action}++;local$self->{action}=$action;my$method=$self->can_action($action);die "No action '$action' defined, try running the 'help' action.\n" unless$method;$self->log_debug("Starting ACTION_$action\n");my$rc=$self->$method();$self->log_debug("Finished ACTION_$action\n");return$rc}sub can_action {my ($self,$action)=@_;return$self->can("ACTION_$action")}sub cull_options {my$self=shift;my (@argv)=@_;return({},@argv)unless(ref($self));my$specs=$self->get_options;return({},@argv)unless($specs and %$specs);require Getopt::Long;my@specs;my$args={};for my$k (sort keys %$specs){my$v=$specs->{$k};die "Option specification '$k' conflicts with a " .ref$self ." option of the same name" if$self->valid_property($k);push@specs,$k .(defined$v->{type}? $v->{type}: '');push@specs,$v->{store}if exists$v->{store};$args->{$k}=$v->{default}if exists$v->{default}}local@ARGV=@argv;if (@specs){Getopt::Long::Configure('pass_through');Getopt::Long::GetOptions($args,@specs)}return$args,@ARGV}sub unparse_args {my ($self,$args)=@_;my@out;for my$k (sort keys %$args){my$v=$args->{$k};push@out,(ref$v eq 'HASH' ? map {+"--$k","$_=$v->{$_}"}sort keys %$v : ref$v eq 'ARRAY' ? map {+"--$k",$_}@$v : ("--$k",$v))}return@out}sub args {my$self=shift;return wantarray ? %{$self->{args}}: $self->{args}unless @_;my$key=shift;$self->{args}{$key}=shift if @_;return$self->{args}{$key}}sub _translate_option {my$self=shift;my$opt=shift;(my$tr_opt=$opt)=~ tr/-/_/;return$tr_opt if grep$tr_opt =~ /^(?:no_?)?$_$/,qw(create_license create_makefile_pl create_readme extra_compiler_flags extra_linker_flags install_base install_path meta_add meta_merge test_files use_rcfile use_tap_harness tap_harness_args cpan_client pureperl_only allow_pureperl);return$opt}my%singular_argument=map {($_=>1)}qw/install_base prefix destdir installdirs verbose quiet uninst debug sign/;sub _read_arg {my ($self,$args,$key,$val)=@_;$key=$self->_translate_option($key);if (exists$args->{$key}and not $singular_argument{$key}){$args->{$key}=[$args->{$key}]unless ref$args->{$key};push @{$args->{$key}},$val}else {$args->{$key}=$val}}sub _optional_arg {my$self=shift;my$opt=shift;my$argv=shift;$opt=$self->_translate_option($opt);my@bool_opts=qw(build_bat create_license create_readme pollute quiet uninst use_rcfile verbose debug sign use_tap_harness pureperl_only allow_pureperl);if (grep$opt =~ /^no[-_]?$_$/,@bool_opts){$opt =~ s/^no-?//;return ($opt,0)}return ($opt,shift(@$argv))unless grep $_ eq $opt,@bool_opts;my$arg=1;$arg=shift(@$argv)if @$argv && $argv->[0]=~ /^\d+$/;return ($opt,$arg)}sub read_args {my$self=shift;(my$args,@_)=$self->cull_options(@_);my%args=%$args;my$opt_re=qr/[\w\-]+/;my ($action,@argv);while (@_){local $_=shift;if (/^(?:--)?($opt_re)=(.*)$/){$self->_read_arg(\%args,$1,$2)}elsif (/^--($opt_re)$/){my($opt,$arg)=$self->_optional_arg($1,\@_);$self->_read_arg(\%args,$opt,$arg)}elsif (/^($opt_re)$/ and!defined($action)){$action=$1}else {push@argv,$_}}$args{ARGV}=\@argv;for ('extra_compiler_flags','extra_linker_flags'){$args{$_}=[$self->split_like_shell($args{$_})]if exists$args{$_}}for ('include_dirs'){$args{$_}=[$args{$_}]if exists$args{$_}&&!ref$args{$_}}for ($self->hash_properties,'config'){next unless exists$args{$_};my%hash;$args{$_}||= [];$args{$_}=[$args{$_}]unless ref$args{$_};for my$arg (@{$args{$_}}){$arg =~ /($opt_re)=(.*)/ or die "Malformed '$_' argument: '$arg' should be something like 'foo=bar'";$hash{$1}=$2}$args{$_}=\%hash}for my$key (qw(prefix install_base destdir)){next if!defined$args{$key};$args{$key}=$self->_detildefy($args{$key})}for my$key (qw(install_path)){next if!defined$args{$key};for my$subkey (keys %{$args{$key}}){next if!defined$args{$key}{$subkey};my$subkey_ext=$self->_detildefy($args{$key}{$subkey});if ($subkey eq 'html'){$args{$key}{binhtml}=$subkey_ext;$args{$key}{libhtml}=$subkey_ext}else {$args{$key}{$subkey}=$subkey_ext}}}if ($args{makefile_env_macros}){require Module::Build::Compat;%args=(%args,Module::Build::Compat->makefile_to_build_macros)}return \%args,$action}sub _detildefy {}sub _merge_arglist {my($self,$opts1,$opts2)=@_;$opts1 ||= {};$opts2 ||= {};my%new_opts=%$opts1;while (my ($key,$val)=each %$opts2){if (exists($opts1->{$key})){if (ref($val)eq 'HASH'){while (my ($k,$v)=each %$val){$new_opts{$key}{$k}=$v unless exists($opts1->{$key}{$k})}}}else {$new_opts{$key}=$val}}return%new_opts}sub _home_dir {my@home_dirs;push(@home_dirs,$ENV{HOME})if$ENV{HOME};push(@home_dirs,File::Spec->catpath($ENV{HOMEDRIVE},$ENV{HOMEPATH},''))if$ENV{HOMEDRIVE}&& $ENV{HOMEPATH};my@other_home_envs=qw(USERPROFILE APPDATA WINDIR SYS$LOGIN);push(@home_dirs,map$ENV{$_},grep$ENV{$_},@other_home_envs);my@real_home_dirs=grep -d,@home_dirs;return wantarray ? @real_home_dirs : shift(@real_home_dirs)}sub _find_user_config {my$self=shift;my$file=shift;for my$dir ($self->_home_dir){my$path=File::Spec->catfile($dir,$file);return$path if -e $path}return undef}sub read_modulebuildrc {my($self,$action)=@_;return ()unless$self->use_rcfile;my$modulebuildrc;if (exists($ENV{MODULEBUILDRC})&& $ENV{MODULEBUILDRC}eq 'NONE'){return ()}elsif (exists($ENV{MODULEBUILDRC})&& -e $ENV{MODULEBUILDRC}){$modulebuildrc=$ENV{MODULEBUILDRC}}elsif (exists($ENV{MODULEBUILDRC})){$self->log_warn("WARNING: Can't find resource file " ."'$ENV{MODULEBUILDRC}' defined in environment.\n" ."No options loaded\n");return ()}else {$modulebuildrc=$self->_find_user_config('.modulebuildrc');return ()unless$modulebuildrc}open(my$fh,'<',$modulebuildrc)or die "Can't open $modulebuildrc: $!";my%options;my$buffer='';while (defined(my$line=<$fh>)){chomp($line);$line =~ s/#.*$//;next unless length($line);if ($line =~ /^\S/){if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' ';$buffer=''}$buffer=$line}else {$buffer .= $line}}if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' '}my ($global_opts)=$self->read_args($self->split_like_shell($options{'*'}|| ''));if ($action eq 'fakeinstall' &&!exists$options{fakeinstall}){$action='install'}my ($action_opts)=$self->read_args($self->split_like_shell($options{$action}|| ''));return$self->_merge_arglist($action_opts,$global_opts)}sub merge_modulebuildrc {my($self,$action,%cmdline_opts)=@_;my%rc_opts=$self->read_modulebuildrc($action || $self->{action}|| 'build');my%new_opts=$self->_merge_arglist(\%cmdline_opts,\%rc_opts);$self->merge_args($action,%new_opts)}sub merge_args {my ($self,$action,%args)=@_;$self->{action}=$action if defined$action;my%additive=map {$_=>1}$self->hash_properties;while (my ($key,$val)=each%args){$self->{phash}{runtime_params}->access($key=>$val)if$self->valid_property($key);if ($key eq 'config'){$self->config($_=>$val->{$_})foreach keys %$val}else {my$add_to=$additive{$key}? $self->{properties}{$key}: $self->valid_property($key)? $self->{properties}: $self->{args};if ($additive{$key}){$add_to->{$_}=$val->{$_}foreach keys %$val}else {$add_to->{$key}=$val}}}}sub cull_args {my$self=shift;my@arg_list=@_;unshift@arg_list,$self->split_like_shell($ENV{PERL_MB_OPT})if$ENV{PERL_MB_OPT};my ($args,$action)=$self->read_args(@arg_list);$self->merge_args($action,%$args);$self->merge_modulebuildrc($action,%$args)}sub super_classes {my ($self,$class,$seen)=@_;$class ||= ref($self)|| $self;$seen ||= {};no strict 'refs';my@super=grep {not $seen->{$_}++}$class,@{$class .'::ISA'};return@super,map {$self->super_classes($_,$seen)}@super}sub known_actions {my ($self)=@_;my%actions;no strict 'refs';for my$class ($self->super_classes){for (keys %{$class .'::'}){$actions{$1}++ if /^ACTION_(\w+)/}}return wantarray ? sort keys%actions : \%actions}sub get_action_docs {my ($self,$action)=@_;my$actions=$self->known_actions;die "No known action '$action'" unless$actions->{$action};my ($files_found,@docs)=(0);for my$class ($self->super_classes){(my$file=$class)=~ s{::}{/}g;$file=$INC{$file .'.pm'}or next;open(my$fh,'<',$file)or next;$files_found++;local $_;while (<$fh>){last if /^=head1 ACTIONS\s/}my$style;while (<$fh>){last if /^=head1 /;if(/^=(item|head2)\s+\Q$action\E\b/){$style=$1;push@docs,$_;last}}$style or next;if($style eq 'item'){my ($found,$inlist)=(0,0);while (<$fh>){if (/^=(item|back)/){last unless$inlist}push@docs,$_;++$inlist if /^=over/;--$inlist if /^=back/}}else {while (<$fh>){last if(/^=(?:head[12]|cut)/);push@docs,$_}}}unless ($files_found){$@="Couldn't find any documentation to search";return}unless (@docs){$@="Couldn't find any docs for action '$action'";return}return join '',@docs}sub ACTION_prereq_report {my$self=shift;$self->log_info($self->prereq_report)}sub ACTION_prereq_data {my$self=shift;$self->log_info(Module::Build::Dumper->_data_dump($self->prereq_data))}sub prereq_data {my$self=shift;my@types=('configure_requires',@{$self->prereq_action_types});my$info={map {$_=>$self->$_()}grep {%{$self->$_()}}@types };return$info}sub prereq_report {my$self=shift;my$info=$self->prereq_data;my$output='';for my$type (sort keys %$info){my$prereqs=$info->{$type};$output .= "\n$type:\n";my$mod_len=2;my$ver_len=4;my%mods;for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$len=length$modname;$mod_len=$len if$len > $mod_len;$spec ||= '0';$len=length$spec;$ver_len=$len if$len > $ver_len;my$mod=$self->check_installed_status($modname,$spec);$mod->{name}=$modname;$mod->{ok}||= 0;$mod->{ok}=!$mod->{ok}if$type =~ /^(\w+_)?conflicts$/;$mods{lc$modname}=$mod}my$space=q{ } x ($mod_len - 3);my$vspace=q{ } x ($ver_len - 3);my$sline=q{-} x ($mod_len - 3);my$vline=q{-} x ($ver_len - 3);my$disposition=($type =~ /^(\w+_)?conflicts$/)? 'Clash' : 'Need';$output .= "    Module $space  $disposition $vspace  Have\n"."    ------$sline+------$vline-+----------\n";for my$k (sort keys%mods){my$mod=$mods{$k};my$space=q{ } x ($mod_len - length$k);my$vspace=q{ } x ($ver_len - length$mod->{need});my$f=$mod->{ok}? ' ' : '!';$output .= "  $f $mod->{name} $space     $mod->{need}  $vspace   ".(defined($mod->{have})? $mod->{have}: "")."\n"}}return$output}sub ACTION_help {my ($self)=@_;my$actions=$self->known_actions;if (@{$self->{args}{ARGV}}){my$msg=eval {$self->get_action_docs($self->{args}{ARGV}[0],$actions)};print $@ ? "$@\n" : $msg;return}print <<EOF;print$self->_action_listing($actions);print "\nRun `Build help <action>` for details on an individual action.\n";print "See `perldoc Module::Build` for complete documentation.\n"}sub _action_listing {my ($self,$actions)=@_;my@actions=sort keys %$actions;@actions=map$actions[($_ + ($_ % 2)* @actions)/ 2],0..$#actions;my$out='';while (my ($one,$two)=splice@actions,0,2){$out .= sprintf("  %-12s                   %-12s\n",$one,$two||'')}$out =~ s{\s*$}{}mg;return$out}sub ACTION_retest {my ($self)=@_;local@INC=@INC;@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub ACTION_testall {my ($self)=@_;my@types;for my$action (grep {$_ ne 'all'}$self->get_test_types){push(@types,$action)}$self->generic_test(types=>['default',@types])}sub get_test_types {my ($self)=@_;my$t=$self->{properties}->{test_types};return (defined$t ? (wantarray ? sort keys %$t : keys %$t): ())}sub ACTION_test {my ($self)=@_;$self->generic_test(type=>'default')}sub generic_test {my$self=shift;(@_ % 2)and croak('Odd number of elements in argument hash');my%args=@_;my$p=$self->{properties};my@types=((exists($args{type})? $args{type}: ()),(exists($args{types})? @{$args{types}}: ()),);@types or croak "need some types of tests to check";my%test_types=(default=>$p->{test_file_exts},(defined($p->{test_types})? %{$p->{test_types}}: ()),);for my$type (@types){croak "$type not defined in test_types!" unless defined$test_types{$type }}local$p->{test_file_exts}=[map {ref $_ ? @$_ : $_}@test_types{@types}];$self->depends_on('code');local@INC=@INC;unshift@INC,(File::Spec->catdir($p->{base_dir},$self->blib,'lib'),File::Spec->catdir($p->{base_dir},$self->blib,'arch'));@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub do_tests {my$self=shift;my$tests=$self->find_test_files;local$ENV{PERL_DL_NONLAZY}=1;if(@$tests){my$args=$self->tap_harness_args;if($self->use_tap_harness or ($args and %$args)){my$aggregate=$self->run_tap_harness($tests);if ($aggregate->has_errors){die "Errors in testing.  Cannot continue.\n"}}else {$self->run_test_harness($tests)}}else {$self->log_info("No tests defined.\n")}$self->run_visual_script}sub run_tap_harness {my ($self,$tests)=@_;require TAP::Harness::Env;my$aggregate=TAP::Harness::Env->create({lib=>[@INC],verbosity=>$self->{properties}{verbose},switches=>[$self->harness_switches ],%{$self->tap_harness_args},})->runtests(@$tests);return$aggregate}sub run_test_harness {my ($self,$tests)=@_;require Test::Harness;local$Test::Harness::verbose=$self->verbose || 0;local$Test::Harness::switches=join ' ',$self->harness_switches;Test::Harness::runtests(@$tests)}sub run_visual_script {my$self=shift;$self->run_perl_script('visual.pl','-Mblib='.$self->blib)if -e 'visual.pl'}sub harness_switches {my$self=shift;my@res;push@res,qw(-w -d) if$self->{properties}{debugger};push@res,'-MDevel::Cover' if$self->{properties}{cover};return@res}sub test_files {my$self=shift;my$p=$self->{properties};if (@_){return$p->{test_files}=(@_==1 ? shift : [@_])}return$self->find_test_files}sub expand_test_dir {my ($self,$dir)=@_;my$exts=$self->{properties}{test_file_exts};return sort map {@{$self->rscan_dir($dir,qr{^[^.].*\Q$_\E$})}}@$exts if$self->recursive_test_files;return sort map {glob File::Spec->catfile($dir,"*$_")}@$exts}sub ACTION_testdb {my ($self)=@_;local$self->{properties}{debugger}=1;$self->depends_on('test')}sub ACTION_testcover {my ($self)=@_;unless (Module::Metadata->find_module_by_name('Devel::Cover')){warn("Cannot run testcover action unless Devel::Cover is installed.\n");return}$self->add_to_cleanup('coverage','cover_db');$self->depends_on('code');if (-e 'cover_db'){my$pm_files=$self->rscan_dir (File::Spec->catdir($self->blib,'lib'),$self->file_qr('\.pm$'));my$cover_files=$self->rscan_dir('cover_db',sub {-f $_ and not /\.html$/});$self->do_system(qw(cover -delete))unless$self->up_to_date($pm_files,$cover_files)&& $self->up_to_date($self->test_files,$cover_files)}local$self->{properties}{cover}=1;$self->depends_on('test');$self->do_system('cover')}sub ACTION_code {my ($self)=@_;my$blib=$self->blib;$self->add_to_cleanup($blib);File::Path::mkpath(File::Spec->catdir($blib,'arch'));if (my$split=$self->autosplit){$self->autosplit_file($_,$blib)for ref($split)? @$split : ($split)}for my$element (@{$self->build_elements}){my$method="process_${element}_files";$method="process_files_by_extension" unless$self->can($method);$self->$method($element)}$self->depends_on('config_data')}sub ACTION_build {my$self=shift;$self->log_info("Building " .$self->dist_name ."\n");$self->depends_on('code');$self->depends_on('docs')}sub process_files_by_extension {my ($self,$ext)=@_;my$method="find_${ext}_files";my$files=$self->can($method)? $self->$method(): $self->_find_file_by_type($ext,'lib');for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($self->blib,$files->{$file}))}}sub process_support_files {my$self=shift;my$p=$self->{properties};return unless$p->{c_source};return if$self->pureperl_only && $self->allow_pureperl;my$files;if (ref($p->{c_source})eq "ARRAY"){push @{$p->{include_dirs}},@{$p->{c_source}};for my$path (@{$p->{c_source}}){push @$files,@{$self->rscan_dir($path,$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}}}else {push @{$p->{include_dirs}},$p->{c_source};$files=$self->rscan_dir($p->{c_source},$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}for my$file (@$files){push @{$p->{objects}},$self->compile_c($file)}}sub process_share_dir_files {my$self=shift;my$files=$self->_find_share_dir_files;return unless$files;my$share_prefix=File::Spec->catdir($self->blib,qw/lib auto share/);for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($share_prefix,$files->{$file}))}}sub _find_share_dir_files {my$self=shift;my$share_dir=$self->share_dir;return unless$share_dir;my@file_map;if ($share_dir->{dist}){my$prefix="dist/".$self->dist_name;push@file_map,$self->_share_dir_map($prefix,$share_dir->{dist})}if ($share_dir->{module}){for my$mod (sort keys %{$share_dir->{module}}){(my$altmod=$mod)=~ s{::}{-}g;my$prefix="module/$altmod";push@file_map,$self->_share_dir_map($prefix,$share_dir->{module}{$mod})}}return {@file_map }}sub _share_dir_map {my ($self,$prefix,$list)=@_;my%files;for my$dir (@$list){for my$f (@{$self->rscan_dir($dir,sub {-f})}){$f =~ s{\A.*?\Q$dir\E/}{};$files{"$dir/$f"}="$prefix/$f"}}return%files}sub process_PL_files {my ($self)=@_;my$files=$self->find_PL_files;for my$file (sort keys %$files){my$to=$files->{$file};unless ($self->up_to_date($file,$to)){$self->run_perl_script($file,[],[@$to])or die "$file failed";$self->add_to_cleanup(@$to)}}}sub process_xs_files {my$self=shift;return if$self->pureperl_only && $self->allow_pureperl;my$files=$self->find_xs_files;croak 'Can\'t build xs files under --pureperl-only' if %$files && $self->pureperl_only;for my$from (sort keys %$files){my$to=$files->{$from};unless ($from eq $to){$self->add_to_cleanup($to);$self->copy_if_modified(from=>$from,to=>$to)}$self->process_xs($to)}}sub process_pod_files {shift()->process_files_by_extension(shift())}sub process_pm_files {shift()->process_files_by_extension(shift())}sub process_script_files {my$self=shift;my$files=$self->find_script_files;return unless keys %$files;my$script_dir=File::Spec->catdir($self->blib,'script');File::Path::mkpath($script_dir);for my$file (sort keys %$files){my$result=$self->copy_if_modified($file,$script_dir,'flatten')or next;$self->fix_shebang_line($result)unless$self->is_vmsish;$self->make_executable($result)}}sub find_PL_files {my$self=shift;if (my$files=$self->{properties}{PL_files}){if (ref$files eq 'ARRAY'){return {map {$_,[/^(.*)\.PL$/]}map$self->localize_file_path($_),@$files }}elsif (ref$files eq 'HASH'){my%out;while (my ($file,$to)=each %$files){$out{$self->localize_file_path($file)}=[map$self->localize_file_path($_),ref$to ? @$to : ($to)]}return \%out}else {die "'PL_files' must be a hash reference or array reference"}}return unless -d 'lib';return {map {$_,[/^(.*)\.PL$/i ]}@{$self->rscan_dir('lib',$self->file_qr('\.PL$'))}}}sub find_pm_files {shift->_find_file_by_type('pm','lib')}sub find_pod_files {shift->_find_file_by_type('pod','lib')}sub find_xs_files {shift->_find_file_by_type('xs','lib')}sub find_script_files {my$self=shift;if (my$files=$self->script_files){return {map {$self->localize_file_path($_),$files->{$_}}keys %$files }}return {}}sub find_test_files {my$self=shift;my$p=$self->{properties};if (my$files=$p->{test_files}){$files=[sort keys %$files]if ref$files eq 'HASH';$files=[map {-d $_ ? $self->expand_test_dir($_): $_}map glob,$self->split_like_shell($files)];return [map$self->localize_file_path($_),@$files ]}else {my@tests;push@tests,'test.pl' if -e 'test.pl';push@tests,$self->expand_test_dir('t')if -e 't' and -d _;return \@tests}}sub _find_file_by_type {my ($self,$type,$dir)=@_;if (my$files=$self->{properties}{"${type}_files"}){return {map$self->localize_file_path($_),%$files }}return {}unless -d $dir;return {map {$_,$_}map$self->localize_file_path($_),grep!/\.\#/,@{$self->rscan_dir($dir,$self->file_qr("\\.$type\$"))}}}sub localize_file_path {my ($self,$path)=@_;return File::Spec->catfile(split m{/},$path)}sub localize_dir_path {my ($self,$path)=@_;return File::Spec->catdir(split m{/},$path)}sub fix_shebang_line {my ($self,@files)=@_;my$c=ref($self)? $self->{config}: 'Module::Build::Config';my ($does_shbang)=$c->get('sharpbang')=~ /^\s*\#\!/;for my$file (@files){open(my$FIXIN,'<',$file)or die "Can't process '$file': $!";local $/="\n";chomp(my$line=<$FIXIN>);next unless$line =~ s/^\s*\#!\s*//;my ($cmd,$arg)=(split(' ',$line,2),'');next unless$cmd =~ /perl/i;my$interpreter=$self->{properties}{perl};$self->log_verbose("Changing sharpbang in $file to $interpreter\n");my$shb='';$shb .= $c->get('sharpbang')."$interpreter $arg\n" if$does_shbang;open(my$FIXOUT,'>',"$file.new")or die "Can't create new $file: $!\n";local $\;undef $/;print$FIXOUT $shb,<$FIXIN>;close$FIXIN;close$FIXOUT;rename($file,"$file.bak")or die "Can't rename $file to $file.bak: $!";rename("$file.new",$file)or die "Can't rename $file.new to $file: $!";$self->delete_filetree("$file.bak")or $self->log_warn("Couldn't clean up $file.bak, leaving it there");$self->do_system($c->get('eunicefix'),$file)if$c->get('eunicefix')ne ':'}}sub ACTION_testpod {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod 0.95; 1} or die "The 'testpod' action requires Test::Pod version 0.95";my@files=sort keys %{$self->_find_pods($self->libdoc_dirs)},keys %{$self->_find_pods ($self->bindoc_dirs,exclude=>[$self->file_qr('\.bat$')])}or die "Couldn't find any POD files to test\n";{package Module::Build::PodTester;Test::Pod->import(tests=>scalar@files);pod_file_ok($_)foreach@files}}sub ACTION_testpodcoverage {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod::Coverage 1.00; 1} or die "The 'testpodcoverage' action requires ","Test::Pod::Coverage version 1.00";local@INC=@INC;my$p=$self->{properties};unshift(@INC,File::Spec->catdir($p->{base_dir},$self->blib,'lib'),);all_pod_coverage_ok()}sub ACTION_docs {my$self=shift;$self->depends_on('code');$self->depends_on('manpages','html')}sub _is_default_installable {my$self=shift;my$type=shift;return ($self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs)->{$type}))? 1 : 0}sub _is_ActivePerl {my$self=shift;unless (exists($self->{_is_ActivePerl})){$self->{_is_ActivePerl}=(eval {require ActivePerl::DocTools}|| 0)}return$self->{_is_ActivePerl}}sub _is_ActivePPM {my$self=shift;unless (exists($self->{_is_ActivePPM})){$self->{_is_ActivePPM}=(eval {require ActivePerl::PPM}|| 0)}return$self->{_is_ActivePPM}}sub ACTION_manpages {my$self=shift;return unless$self->_mb_feature('manpage_support');$self->depends_on('code');my%extra_manify_args=$self->{properties}{'extra_manify_args'}? %{$self->{properties}{'extra_manify_args'}}: ();for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'manpages' || $self->_is_default_installable("${type}doc"));my$files=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.bat$')]);next unless %$files;my$sub=$self->can("manify_${type}_pods");$self->$sub(%extra_manify_args)if defined($sub)}}sub manify_bin_pods {my$self=shift;my%podman_args=(section=>1,@_);my$files=$self->_find_pods($self->{properties}{bindoc_dirs},exclude=>[$self->file_qr('\.bat$')]);return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'bindoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man1page_name($file).'.' .$self->config('man1ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub manify_lib_pods {my$self=shift;my%podman_args=(section=>3,@_);my$files=$self->_find_pods($self->{properties}{libdoc_dirs});return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'libdoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man3page_name($files->{$file}).'.' .$self->config('man3ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub _find_pods {my ($self,$dirs,%args)=@_;my%files;for my$spec (@$dirs){my$dir=$self->localize_dir_path($spec);next unless -e $dir;FILE: foreach my$file (@{$self->rscan_dir($dir)}){for my$regexp (@{$args{exclude}}){next FILE if$file =~ $regexp}$file=$self->localize_file_path($file);$files{$file}=File::Spec->abs2rel($file,$dir)if$self->contains_pod($file)}}return \%files}sub contains_pod {my ($self,$file)=@_;return '' unless -T $file;open(my$fh,'<',$file)or die "Can't open $file: $!";while (my$line=<$fh>){return 1 if$line =~ /^\=(?:head|pod|item)/}return ''}sub ACTION_html {my$self=shift;return unless$self->_mb_feature('HTML_support');$self->depends_on('code');for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'html' || $self->_is_default_installable("${type}html"));$self->htmlify_pods($type)}}sub htmlify_pods {my$self=shift;my$type=shift;my$htmldir=shift || File::Spec->catdir($self->blib,"${type}html");$self->add_to_cleanup('pod2htm*');my$pods=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.(?:bat|com|html)$')]);return unless %$pods;unless (-d $htmldir){File::Path::mkpath($htmldir,0,oct(755))or die "Couldn't mkdir $htmldir: $!"}my@rootdirs=($type eq 'bin')? qw(bin) : $self->installdirs eq 'core' ? qw(lib) : qw(site lib);my$podroot=$ENV{PERL_CORE}? File::Basename::dirname($ENV{PERL_CORE}): $self->original_prefix('core');my$htmlroot=$self->install_sets('core')->{libhtml};my$podpath;unless (defined$self->args('html_links')and!$self->args('html_links')){my@podpath=((map {File::Spec->abs2rel($_,$podroot)}grep {-d}($self->install_sets('core','lib'),$self->install_sets('core','bin'),$self->install_sets('site','lib'),)),File::Spec->rel2abs($self->blib));$podpath=$ENV{PERL_CORE}? File::Spec->catdir($podroot,'lib'): join(":",map {tr,:\\,|/,;$_}@podpath)}my$blibdir=join('/',File::Spec->splitdir((File::Spec->splitpath(File::Spec->rel2abs($htmldir),1))[1]),'');my ($with_ActiveState,$htmltool);if ($with_ActiveState=$self->_is_ActivePerl && eval {require ActivePerl::DocTools::Pod;1}){my$tool_v=ActiveState::DocTools::Pod->VERSION;$htmltool="ActiveState::DocTools::Pod";$htmltool .= " $tool_v" if$tool_v && length$tool_v}else {require Module::Build::PodParser;require Pod::Html;$htmltool="Pod::Html " .Pod::Html->VERSION}$self->log_verbose("Converting Pod to HTML with $htmltool\n");my$errors=0;POD: foreach my$pod (sort keys %$pods){my ($name,$path)=File::Basename::fileparse($pods->{$pod},$self->file_qr('\.(?:pm|plx?|pod)$'));my@dirs=File::Spec->splitdir(File::Spec->canonpath($path));pop(@dirs)if scalar(@dirs)&& $dirs[-1]eq File::Spec->curdir;my$fulldir=File::Spec->catdir($htmldir,@rootdirs,@dirs);my$tmpfile=File::Spec->catfile($fulldir,"${name}.tmp");my$outfile=File::Spec->catfile($fulldir,"${name}.html");my$infile=File::Spec->abs2rel($pod);next if$self->up_to_date($infile,$outfile);unless (-d $fulldir){File::Path::mkpath($fulldir,0,oct(755))or die "Couldn't mkdir $fulldir: $!"}$self->log_verbose("HTMLifying $infile -> $outfile\n");if ($with_ActiveState){my$depth=@rootdirs + @dirs;my%opts=(infile=>$infile,outfile=>$tmpfile,(defined($podpath)? (podpath=>$podpath): ()),podroot=>$podroot,index=>1,depth=>$depth,);eval {ActivePerl::DocTools::Pod::pod2html(map {($_,$opts{$_})}sort keys%opts);1}or $self->log_warn("[$htmltool] pod2html (" .join(", ",map {"q{$_} => q{$opts{$_}}"}(sort keys%opts)).") failed: $@")}else {my$path2root=File::Spec->catdir((File::Spec->updir)x @dirs);open(my$fh,'<',$infile)or die "Can't read $infile: $!";my$abstract=Module::Build::PodParser->new(fh=>$fh)->get_abstract();my$title=join('::',(@dirs,$name));$title .= " - $abstract" if$abstract;my@opts=("--title=$title",(defined($podpath)? "--podpath=$podpath" : ()),"--infile=$infile","--outfile=$tmpfile","--podroot=$podroot",($path2root ? "--htmlroot=$path2root" : ()),);unless (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--flush'))}if (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--header','--backlink'))}elsif (eval{Pod::Html->VERSION(1.03)}){push(@opts,('--header','--backlink=Back to Top'))}$self->log_verbose("P::H::pod2html @opts\n");{my$orig=Cwd::getcwd();eval {Pod::Html::pod2html(@opts);1}or $self->log_warn("[$htmltool] pod2html( " .join(", ",map {"q{$_}"}@opts).") failed: $@");chdir($orig)}}if (!-r $tmpfile){$errors++;next POD}open(my$fh,'<',$tmpfile)or die "Can't read $tmpfile: $!";my$html=join('',<$fh>);close$fh;if (!$self->_is_ActivePerl){$html =~ s#^<!DOCTYPE .*?>#<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">#im;$html =~ s#<html xmlns="http://www.w3.org/1999/xhtml">#<html>#i;$html =~ s#<head>#<head>\n<!-- saved from url=(0017)http://localhost/ -->#i}$html =~ s/\Q$blibdir\E//g;open($fh,'>',$outfile)or die "Can't write $outfile: $!";print$fh $html;close$fh;unlink($tmpfile)}return!$errors}sub man1page_name {my$self=shift;return File::Basename::basename(shift)}sub man3page_name {my$self=shift;my ($vol,$dirs,$file)=File::Spec->splitpath(shift);my@dirs=File::Spec->splitdir(File::Spec->canonpath($dirs));$file =~ s/\.p(?:od|m|l)\z//i;return join($self->manpage_separator,@dirs,$file)}sub manpage_separator {return '::'}sub ACTION_diff {my$self=shift;$self->depends_on('build');my$local_lib=File::Spec->rel2abs('lib');my@myINC=grep {$_ ne $local_lib}@INC;push@myINC,map$self->install_destination($_),qw(lib arch);my@flags=@{$self->{args}{ARGV}};@flags=$self->split_like_shell($self->{args}{flags}|| '')unless@flags;my$installmap=$self->install_map;delete$installmap->{read};delete$installmap->{write};my$text_suffix=$self->file_qr('\.(pm|pod)$');for my$localdir (sort keys %$installmap){my@localparts=File::Spec->splitdir($localdir);my$files=$self->rscan_dir($localdir,sub {-f});for my$file (@$files){my@parts=File::Spec->splitdir($file);@parts=@parts[@localparts .. $#parts];my$installed=Module::Metadata->find_module_by_name(join('::',@parts),\@myINC);if (not $installed){print "Only in lib: $file\n";next}my$status=File::Compare::compare($installed,$file);next if$status==0;die "Can't compare $installed and $file: $!" if$status==-1;if ($file =~ $text_suffix){$self->do_system('diff',@flags,$installed,$file)}else {print "Binary files $file and $installed differ\n"}}}}sub ACTION_pure_install {shift()->depends_on('install')}sub ACTION_install {my ($self)=@_;require ExtUtils::Install;$self->depends_on('build');$self->_do_in_dir(".",sub {ExtUtils::Install::install($self->install_map,$self->verbose,0,$self->{args}{uninst}||0)});if ($self->_is_ActivePerl && $self->{_completed_actions}{html}){$self->log_info("Building ActivePerl Table of Contents\n");eval {ActivePerl::DocTools::WriteTOC(verbose=>$self->verbose ? 1 : 0);1}or $self->log_warn("AP::DT:: WriteTOC() failed: $@")}if ($self->_is_ActivePPM){my$F_perllocal=File::Spec->catfile($self->install_sets('core','lib'),'perllocal.pod');my$dt_stamp=time;$self->log_info("For ActivePerl's PPM: touch '$F_perllocal'\n");open my$perllocal,">>",$F_perllocal;close$perllocal;utime($dt_stamp,$dt_stamp,$F_perllocal)}}sub ACTION_fakeinstall {my ($self)=@_;require ExtUtils::Install;my$eui_version=ExtUtils::Install->VERSION;if ($eui_version < 1.32){$self->log_warn("The 'fakeinstall' action requires Extutils::Install 1.32 or later.\n" ."(You only have version $eui_version).");return}$self->depends_on('build');ExtUtils::Install::install($self->install_map,!$self->quiet,1,$self->{args}{uninst}||0)}sub ACTION_versioninstall {my ($self)=@_;die "You must have only.pm 0.25 or greater installed for this operation: $@\n" unless eval {require only;'only'->VERSION(0.25);1};$self->depends_on('build');my%onlyargs=map {exists($self->{args}{$_})? ($_=>$self->{args}{$_}): ()}qw(version versionlib);only::install::install(%onlyargs)}sub ACTION_installdeps {my ($self)=@_;my$info=$self->_enum_prereqs;if (!$info){$self->log_info("No prerequisites detected\n");return}my$failures=$self->prereq_failures($info);if (!$failures){$self->log_info("All prerequisites satisfied\n");return}my@install;for my$type (sort keys %$failures){my$prereqs=$failures->{$type};if($type =~ m/^(?:\w+_)?requires$/){push(@install,sort keys %$prereqs);next}$self->log_info("Checking optional dependencies:\n");for my$module (sort keys %$prereqs){push(@install,$module)if($self->y_n("Install $module?",'y'))}}return unless@install;my ($command,@opts)=$self->split_like_shell($self->cpan_client);if (!File::Spec->file_name_is_absolute($command)){my@loc=('site','vendor','');my@bindirs=File::Basename::dirname($self->perl);push@bindirs,map {($self->config->{"install${_}bin"},$self->config->{"install${_}script"})}@loc;for my$d (@bindirs){my$abs_cmd=$self->find_command(File::Spec->catfile($d,$command));if (defined$abs_cmd){$command=$abs_cmd;last}}}$self->do_system($command,@opts,@install)}sub ACTION_clean {my ($self)=@_;$self->log_info("Cleaning up build files\n");for my$item (map glob($_),$self->cleanup){$self->delete_filetree($item)}}sub ACTION_realclean {my ($self)=@_;$self->depends_on('clean');$self->log_info("Cleaning up configuration files\n");$self->delete_filetree($self->config_dir,$self->mymetafile,$self->mymetafile2,$self->build_script)}sub ACTION_ppd {my ($self)=@_;require Module::Build::PPMMaker;my$ppd=Module::Build::PPMMaker->new();my$file=$ppd->make_ppd(%{$self->{args}},build=>$self);$self->add_to_cleanup($file)}sub ACTION_ppmdist {my ($self)=@_;$self->depends_on('build');my$ppm=$self->ppm_name;$self->delete_filetree($ppm);$self->log_info("Creating $ppm\n");$self->add_to_cleanup($ppm,"$ppm.tar.gz");my%types=(lib=>'lib',arch=>'arch',bin=>'bin',script=>'script',bindoc=>'man1',libdoc=>'man3',binhtml=>undef,libhtml=>undef,);for my$type ($self->install_types){next if exists($types{$type})&&!defined($types{$type});my$dir=File::Spec->catdir($self->blib,$type);next unless -e $dir;my$files=$self->rscan_dir($dir);for my$file (@$files){next unless -f $file;my$rel_file=File::Spec->abs2rel(File::Spec->rel2abs($file),File::Spec->rel2abs($dir));my$to_file=File::Spec->catfile($ppm,'blib',exists($types{$type})? $types{$type}: $type,$rel_file);$self->copy_if_modified(from=>$file,to=>$to_file)}}for my$type (qw(bin lib)){$self->htmlify_pods($type,File::Spec->catdir($ppm,'blib','html'))}my$target=File::Spec->catfile(File::Spec->updir,$ppm);$self->_do_in_dir($ppm,sub {$self->make_tarball('blib',$target)});$self->depends_on('ppd');$self->delete_filetree($ppm)}sub ACTION_pardist {my ($self)=@_;if (not eval {require PAR::Dist;PAR::Dist->VERSION(0.17)}){$self->log_warn("In order to create .par distributions, you need to\n" ."install PAR::Dist first.");return()}$self->depends_on('build');return PAR::Dist::blib_to_par(name=>$self->dist_name,version=>$self->dist_version,)}sub ACTION_dist {my ($self)=@_;$self->dispatch('distdir');my$dist_dir=$self->dist_dir;$self->make_tarball($dist_dir);$self->delete_filetree($dist_dir)}sub ACTION_distcheck {my ($self)=@_;$self->_check_manifest_skip unless$self->invoked_action eq 'distclean';require ExtUtils::Manifest;local $^W;my ($missing,$extra)=ExtUtils::Manifest::fullcheck();return unless @$missing || @$extra;my$msg="MANIFEST appears to be out of sync with the distribution\n";if ($self->invoked_action eq 'distcheck'){die$msg}else {warn$msg}}sub _check_mymeta_skip {my$self=shift;my$maniskip=shift || 'MANIFEST.SKIP';require ExtUtils::Manifest;local $^W;my$skip_factory=ExtUtils::Manifest->can('maniskip')|| ExtUtils::Manifest->can('_maniskip');my$mymetafile=$self->mymetafile;for my$file ($self->mymetafile,$self->mymetafile2){unless ($skip_factory && $skip_factory->($maniskip)->($file)){$self->log_warn("File '$maniskip' does not include '$file'. Adding it now.\n");my$safe=quotemeta($file);$self->_append_maniskip("^$safe\$",$maniskip)}}}sub _add_to_manifest {my ($self,$manifest,$lines)=@_;$lines=[$lines]unless ref$lines;my$existing_files=$self->_read_manifest($manifest);return unless defined($existing_files);@$lines=grep {!exists$existing_files->{$_}}@$lines or return;my$mode=(stat$manifest)[2];chmod($mode | oct(222),$manifest)or die "Can't make $manifest writable: $!";open(my$fh,'<',$manifest)or die "Can't read $manifest: $!";my$last_line=(<$fh>)[-1]|| "\n";my$has_newline=$last_line =~ /\n$/;close$fh;open($fh,'>>',$manifest)or die "Can't write to $manifest: $!";print$fh "\n" unless$has_newline;print$fh map "$_\n",@$lines;close$fh;chmod($mode,$manifest);$self->log_verbose(map "Added to $manifest: $_\n",@$lines)}sub _sign_dir {my ($self,$dir)=@_;unless (eval {require Module::Signature;1}){$self->log_warn("Couldn't load Module::Signature for 'distsign' action:\n $@\n");return}{my$manifest=File::Spec->catfile($dir,'MANIFEST');die "Signing a distribution requires a MANIFEST file" unless -e $manifest;$self->_add_to_manifest($manifest,"SIGNATURE    Added here by Module::Build")}$self->_do_in_dir($dir,sub {local$Module::Signature::Quiet=1;Module::Signature::sign()})}sub _do_in_dir {my ($self,$dir,$do)=@_;my$start_dir=File::Spec->rel2abs($self->cwd);chdir$dir or die "Can't chdir() to $dir: $!";eval {$do->()};my@err=$@ ? ($@): ();chdir$start_dir or push@err,"Can't chdir() back to $start_dir: $!";die join "\n",@err if@err}sub ACTION_distsign {my ($self)=@_;{local$self->{properties}{sign}=0;$self->depends_on('distdir')unless -d $self->dist_dir}$self->_sign_dir($self->dist_dir)}sub ACTION_skipcheck {my ($self)=@_;require ExtUtils::Manifest;local $^W;ExtUtils::Manifest::skipcheck()}sub ACTION_distclean {my ($self)=@_;$self->depends_on('realclean');$self->depends_on('distcheck')}sub do_create_makefile_pl {my$self=shift;require Module::Build::Compat;$self->log_info("Creating Makefile.PL\n");eval {Module::Build::Compat->create_makefile_pl($self->create_makefile_pl,$self,@_)};if ($@){1 while unlink 'Makefile.PL';die "$@\n"}$self->_add_to_manifest('MANIFEST','Makefile.PL')}sub do_create_license {my$self=shift;$self->log_info("Creating LICENSE file\n");if (!$self->_mb_feature('license_creation')){$self->_warn_mb_feature_deps('license_creation');die "Aborting.\n"}my$l=$self->license or die "Can't create LICENSE file: No license specified\n";my$license=$self->_software_license_object or die << "HERE";$self->delete_filetree('LICENSE');open(my$fh,'>','LICENSE')or die "Can't write LICENSE file: $!";print$fh $license->fulltext;close$fh;$self->_add_to_manifest('MANIFEST','LICENSE')}sub do_create_readme {my$self=shift;$self->delete_filetree('README');my$docfile=$self->_main_docfile;unless ($docfile){$self->log_warn(<<EOF);return}if (eval {require Pod::Readme;Pod::Readme->can('new')}){$self->log_info("Creating README using Pod::Readme\n");my$parser=Pod::Readme->new;$parser->parse_from_file($docfile,'README',@_)}elsif (eval {require Pod::Text;1}){$self->log_info("Creating README using Pod::Text\n");if (open(my$fh,'>','README')){local $^W=0;no strict "refs";my$old_parse_file;$old_parse_file=\&{"Pod::Simple::parse_file"}and local *{"Pod::Simple::parse_file"}=sub {my$self=shift;$self->output_fh($_[1])if $_[1];$self->$old_parse_file($_[0])}if$Pod::Text::VERSION ==3.01;Pod::Text::pod2text($docfile,$fh);close$fh}else {$self->log_warn("Cannot create 'README' file: Can't open file for writing\n");return}}else {$self->log_warn("Can't load Pod::Readme or Pod::Text to create README\n");return}$self->_add_to_manifest('MANIFEST','README')}sub _main_docfile {my$self=shift;if (my$pm_file=$self->dist_version_from){(my$pod_file=$pm_file)=~ s/.pm$/.pod/;return (-e $pod_file ? $pod_file : $pm_file)}else {return undef}}sub do_create_bundle_inc {my$self=shift;my$dist_inc=File::Spec->catdir($self->dist_dir,'inc');require inc::latest;inc::latest->write($dist_inc,@{$self->bundle_inc_preload});inc::latest->bundle_module($_,$dist_inc)for @{$self->bundle_inc};return 1}sub ACTION_distdir {my ($self)=@_;if (@{$self->bundle_inc}&&!$self->_mb_feature('inc_bundling_support')){$self->_warn_mb_feature_deps('inc_bundling_support');die "Aborting.\n"}$self->depends_on('distmeta');my$dist_files=$self->_read_manifest('MANIFEST')or die "Can't create distdir without a MANIFEST file - run 'manifest' action first.\n";delete$dist_files->{SIGNATURE};die "No files found in MANIFEST - try running 'manifest' action?\n" unless ($dist_files and keys %$dist_files);my$metafile=$self->metafile;$self->log_warn("*** Did you forget to add $metafile to the MANIFEST?\n")unless exists$dist_files->{$metafile};my$dist_dir=$self->dist_dir;$self->delete_filetree($dist_dir);$self->log_info("Creating $dist_dir\n");$self->add_to_cleanup($dist_dir);for my$file (sort keys %$dist_files){next if$file =~ m{^MYMETA\.};my$new=$self->copy_if_modified(from=>$file,to_dir=>$dist_dir,verbose=>0)}$self->do_create_bundle_inc if @{$self->bundle_inc};$self->_sign_dir($dist_dir)if$self->{properties}{sign}}sub ACTION_disttest {my ($self)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {local$ENV{AUTHOR_TESTING}=1;local$ENV{RELEASE_TESTING}=1;$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['test'])or die "Error executing 'Build test' in dist directory"})}sub ACTION_distinstall {my ($self,@args)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['install'])or die "Error executing 'Build install' in dist directory"})}sub _eumanifest_has_include {my$self=shift;require ExtUtils::Manifest;return eval {ExtUtils::Manifest->VERSION(1.50);1}}sub _default_maniskip {my$self=shift;my$default_maniskip;for my$dir (@INC){$default_maniskip=File::Spec->catfile($dir,"ExtUtils","MANIFEST.SKIP");last if -r $default_maniskip}return$default_maniskip}sub _slurp {my$self=shift;my$file=shift;my$mode=shift || "";open my$fh,"<$mode",$file or croak "Can't open $file for reading: $!";local $/;return <$fh>}sub _spew {my$self=shift;my$file=shift;my$content=shift || "";my$mode=shift || "";open my$fh,">$mode",$file or croak "Can't open $file for writing: $!";print {$fh}$content;close$fh}sub _case_tolerant {my$self=shift;if (ref$self){$self->{_case_tolerant}=File::Spec->case_tolerant unless defined($self->{_case_tolerant});return$self->{_case_tolerant}}else {return File::Spec->case_tolerant}}sub _append_maniskip {my$self=shift;my$skip=shift;my$file=shift || 'MANIFEST.SKIP';return unless defined$skip && length$skip;open(my$fh,'>>',$file)or die "Can't open $file: $!";print$fh "$skip\n";close$fh}sub _write_default_maniskip {my$self=shift;my$file=shift || 'MANIFEST.SKIP';open(my$fh,'>',$file)or die "Can't open $file: $!";my$content=$self->_eumanifest_has_include ? "#!include_default\n" : $self->_slurp($self->_default_maniskip);$content .= <<'EOF';$content .= '\b'.$self->dist_name.'-[\d\.\_]+'."\n";print$fh $content;close$fh;return}sub _check_manifest_skip {my ($self)=@_;my$maniskip='MANIFEST.SKIP';if (!-e $maniskip){$self->log_warn("File '$maniskip' does not exist: Creating a temporary '$maniskip'\n");$self->_write_default_maniskip($maniskip);$self->_unlink_on_exit($maniskip)}else {$self->_check_mymeta_skip($maniskip)}return}sub ACTION_manifest {my ($self)=@_;$self->_check_manifest_skip;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);ExtUtils::Manifest::mkmanifest()}sub ACTION_manifest_skip {my ($self)=@_;if (-e 'MANIFEST.SKIP'){$self->log_warn("MANIFEST.SKIP already exists.\n");return 0}$self->log_info("Creating a new MANIFEST.SKIP file\n");return$self->_write_default_maniskip;return -e 'MANIFEST.SKIP'}sub file_qr {return shift->{_case_tolerant}? qr($_[0])i : qr($_[0])}sub dist_dir {my ($self)=@_;my$dir=join "-",$self->dist_name,$self->dist_version;$dir .= "-" .$self->dist_suffix if$self->dist_suffix;return$dir}sub ppm_name {my$self=shift;return 'PPM-' .$self->dist_dir}sub _files_in {my ($self,$dir)=@_;return unless -d $dir;local*DH;opendir DH,$dir or die "Can't read directory $dir: $!";my@files;while (defined (my$file=readdir DH)){my$full_path=File::Spec->catfile($dir,$file);next if -d $full_path;push@files,$full_path}return@files}sub share_dir {my$self=shift;my$p=$self->{properties};$p->{share_dir}=shift if @_;if (!defined$p->{share_dir}){return}elsif (!ref$p->{share_dir}){$p->{share_dir}={dist=>[$p->{share_dir}]}}elsif (ref$p->{share_dir}eq 'ARRAY'){$p->{share_dir}={dist=>$p->{share_dir}}}elsif (ref$p->{share_dir}eq 'HASH'){my$share_dir=$p->{share_dir};if (defined$share_dir->{dist}){if (!ref$share_dir->{dist}){$share_dir->{dist}=[$share_dir->{dist}]}elsif (ref$share_dir->{dist}ne 'ARRAY'){die "'dist' key in 'share_dir' must be scalar or arrayref"}}if (defined$share_dir->{module}){my$mod_hash=$share_dir->{module};if (ref$mod_hash eq 'HASH'){for my$k (sort keys %$mod_hash){if (!ref$mod_hash->{$k}){$mod_hash->{$k}=[$mod_hash->{$k}]}elsif(ref$mod_hash->{$k}ne 'ARRAY'){die "modules in 'module' key of 'share_dir' must be scalar or arrayref"}}}else {die "'module' key in 'share_dir' must be hashref"}}}else {die "'share_dir' must be hashref, arrayref or string"}return$p->{share_dir}}sub script_files {my$self=shift;for ($self->{properties}{script_files}){$_=shift if @_;next unless $_;return $_ if ref $_ eq 'HASH';return $_={map {$_,1}@$_ }if ref $_ eq 'ARRAY';die "'script_files' must be a hashref, arrayref, or string" if ref();return $_={map {$_,1}$self->_files_in($_)}if -d $_;return $_={$_=>1}}my%pl_files=map {File::Spec->canonpath($_)=>1}keys %{$self->PL_files || {}};my@bin_files=$self->_files_in('bin');my%bin_map=map {$_=>File::Spec->canonpath($_)}@bin_files;return $_={map {$_=>1}grep!$pl_files{$bin_map{$_}},@bin_files }}BEGIN {*scripts=\&script_files}{my%licenses=(perl=>'Perl_5',apache=>'Apache_2_0',apache_1_1=>'Apache_1_1',artistic=>'Artistic_1',artistic_2=>'Artistic_2',lgpl=>'LGPL_2_1',lgpl2=>'LGPL_2_1',lgpl3=>'LGPL_3_0',bsd=>'BSD',gpl=>'GPL_1',gpl2=>'GPL_2',gpl3=>'GPL_3',mit=>'MIT',mozilla=>'Mozilla_1_1',restrictive=>'Restricted',open_source=>undef,unrestricted=>undef,unknown=>undef,);my%license_urls=(perl=>'http://dev.perl.org/licenses/',apache=>'http://apache.org/licenses/LICENSE-2.0',apache_1_1=>'http://apache.org/licenses/LICENSE-1.1',artistic=>'http://opensource.org/licenses/artistic-license.php',artistic_2=>'http://opensource.org/licenses/artistic-license-2.0.php',lgpl=>'http://opensource.org/licenses/lgpl-license.php',lgpl2=>'http://opensource.org/licenses/lgpl-2.1.php',lgpl3=>'http://opensource.org/licenses/lgpl-3.0.html',bsd=>'http://opensource.org/licenses/bsd-license.php',gpl=>'http://opensource.org/licenses/gpl-license.php',gpl2=>'http://opensource.org/licenses/gpl-2.0.php',gpl3=>'http://opensource.org/licenses/gpl-3.0.html',mit=>'http://opensource.org/licenses/mit-license.php',mozilla=>'http://opensource.org/licenses/mozilla1.1.php',restrictive=>undef,open_source=>undef,unrestricted=>undef,unknown=>undef,);sub valid_licenses {return \%licenses}sub _license_url {return$license_urls{$_[1]}}}sub _software_license_class {my ($self,$license)=@_;if ($self->valid_licenses->{$license}&& eval {require Software::LicenseUtils;Software::LicenseUtils->VERSION(0.103009)}){my@classes=Software::LicenseUtils->guess_license_from_meta_key($license,1);if (@classes==1){eval "require $classes[0]";return$classes[0]}}LICENSE: for my$l ($self->valid_licenses->{$license },$license){next unless defined$l;my$trial="Software::License::" .$l;if (eval "require Software::License; Software::License->VERSION(0.014); require $trial; 1"){return$trial}}return}sub _software_license_object {my ($self)=@_;return unless defined(my$license=$self->license);my$class=$self->_software_license_class($license)or return;my$author=join(" & ",@{$self->dist_author})|| 'unknown';my$sl=eval {$class->new({holder=>$author})};if ($@){$self->log_warn("Error getting '$class' object: $@")}return$sl}sub _hash_merge {my ($self,$h,$k,$v)=@_;if (ref$h->{$k}eq 'ARRAY'){push @{$h->{$k}},ref$v ? @$v : $v}elsif (ref$h->{$k}eq 'HASH'){$h->{$k}{$_}=$v->{$_}foreach keys %$v}else {$h->{$k}=$v}}sub ACTION_distmeta {my ($self)=@_;$self->do_create_makefile_pl if$self->create_makefile_pl;$self->do_create_readme if$self->create_readme;$self->do_create_license if$self->create_license;$self->do_create_metafile}sub do_create_metafile {my$self=shift;return if$self->{wrote_metadata};my$p=$self->{properties};unless ($p->{license}){$self->log_warn("No license specified, setting license = 'unknown'\n");$p->{license}='unknown'}my@metafiles=($self->metafile,$self->metafile2);$self->delete_filetree($_)for@metafiles;local@INC=@INC;if (($self->module_name || '')eq 'Module::Build'){$self->depends_on('config_data');push@INC,File::Spec->catdir($self->blib,'lib')}my$meta_obj=$self->_get_meta_object(quiet=>1,fatal=>1,auto=>1);my@created=$self->_write_meta_files($meta_obj,'META');if (@created){$self->{wrote_metadata}=1;$self->_add_to_manifest('MANIFEST',$_)for@created}return 1}sub _write_meta_files {my$self=shift;my ($meta,$file)=@_;$file =~ s{\.(?:yml|json)$}{};my@created;push@created,"$file\.yml" if$meta && $meta->save("$file\.yml",{version=>"1.4"});push@created,"$file\.json" if$meta && $meta->save("$file\.json");if (@created){$self->log_info("Created " .join(" and ",@created)."\n")}return@created}sub _get_meta_object {my$self=shift;my%args=@_;return unless$self->try_require("CPAN::Meta","2.142060");my$meta;eval {my$data=$self->get_metadata(fatal=>$args{fatal},auto=>$args{auto},);$data->{dynamic_config}=$args{dynamic}if defined$args{dynamic};$meta=CPAN::Meta->create($data)};if ($@ &&!$args{quiet}){$self->log_warn("Could not get valid metadata. Error is: $@\n")}return$meta}sub read_metafile {my$self=shift;my ($metafile)=@_;return unless$self->try_require("CPAN::Meta","2.110420");my$meta=CPAN::Meta->load_file($metafile);return$meta->as_struct({version=>"2.0"})}sub normalize_version {my ($self,$version)=@_;$version=0 unless defined$version and length$version;if ($version =~ /[=<>!,]/){}elsif (ref$version eq 'version'){$version=$version->is_qv ? $version->normal : $version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version}my%prereq_map=(requires=>[qw/runtime requires/],configure_requires=>[qw/configure requires/],build_requires=>[qw/build requires/ ],test_requires=>[qw/test requires/ ],test_recommends=>[qw/test recommends/ ],recommends=>[qw/runtime recommends/ ],conflicts=>[qw/runtime conflicts/ ],);sub _normalize_prereqs {my ($self)=@_;my$p=$self->{properties};my%prereq_types;for my$type ('configure_requires',@{$self->prereq_action_types}){if (exists$p->{$type}and keys %{$p->{$type}}){my ($phase,$relation)=@{$prereq_map{$type}};for my$mod (keys %{$p->{$type}}){$prereq_types{$phase}{$relation}{$mod}=$self->normalize_version($p->{$type}{$mod})}}}return \%prereq_types}sub _get_license {my$self=shift;my$license=$self->license;my ($meta_license,$meta_license_url);my$valid_licenses=$self->valid_licenses();if (my$sl=$self->_software_license_object){$meta_license=$sl->meta2_name;$meta_license_url=$sl->url}elsif (exists$valid_licenses->{$license}){$meta_license=$valid_licenses->{$license}? lc$valid_licenses->{$license}: $license;$meta_license_url=$self->_license_url($license)}else {$self->log_warn("Can not determine license type for '" .$self->license ."'\nSetting META license field to 'unknown'.\n");$meta_license='unknown'}return ($meta_license,$meta_license_url)}sub get_metadata {my ($self,%args)=@_;my$fatal=$args{fatal}|| 0;my$p=$self->{properties};$self->auto_config_requires if$args{auto};for my$f (qw(dist_name dist_version dist_author dist_abstract license)){my$field=$self->$f();unless (defined$field and length$field){my$err="ERROR: Missing required field '$f' for metafile\n";if ($fatal){die$err}else {$self->log_warn($err)}}}my%metadata=(name=>$self->dist_name,version=>$self->normalize_version($self->dist_version),author=>$self->dist_author,abstract=>$self->dist_abstract,generated_by=>"Module::Build version $Module::Build::VERSION",'meta-spec'=>{version=>'2',url=>'http://search.cpan.org/perldoc?CPAN::Meta::Spec',},dynamic_config=>exists$p->{dynamic_config}? $p->{dynamic_config}: 1,release_status=>$self->release_status,);my ($meta_license,$meta_license_url)=$self->_get_license;$metadata{license}=[$meta_license ];$metadata{resources}{license}=[$meta_license_url ]if defined$meta_license_url;$metadata{prereqs}=$self->_normalize_prereqs;if (exists$p->{no_index}){$metadata{no_index}=$p->{no_index}}elsif (my$pkgs=eval {$self->find_dist_packages}){$metadata{provides}=$pkgs if %$pkgs}else {$self->log_warn("$@\nWARNING: Possible missing or corrupt 'MANIFEST' file.\n" ."Nothing to enter for 'provides' field in metafile.\n")}if (my$add=$self->meta_add){if (not exists$add->{'meta-spec'}or $add->{'meta-spec'}{version}!=2){require CPAN::Meta::Converter;if (CPAN::Meta::Converter->VERSION('2.141170')){$add=CPAN::Meta::Converter->new($add)->upgrade_fragment;delete$add->{prereqs}}else {$self->log_warn("Can't meta_add without CPAN::Meta 2.141170")}}while (my($k,$v)=each %{$add}){$metadata{$k}=$v}}if (my$merge=$self->meta_merge){if (eval {require CPAN::Meta::Merge}){%metadata=%{CPAN::Meta::Merge->new(default_version=>'1.4')->merge(\%metadata,$merge)}}else {$self->log_warn("Can't merge without CPAN::Meta::Merge")}}return \%metadata}sub prepare_metadata {my ($self,$node,$keys,$args)=@_;unless (ref$node eq 'HASH'){croak "prepare_metadata() requires a hashref argument to hold output\n"}croak 'Keys argument to prepare_metadata is no longer supported' if$keys;%{$node}=%{$self->get_meta(%{$args})};return$node}sub _read_manifest {my ($self,$file)=@_;return undef unless -e $file;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);return scalar ExtUtils::Manifest::maniread($file)}sub find_dist_packages {my$self=shift;my$manifest=$self->_read_manifest('MANIFEST')or die "Can't find dist packages without a MANIFEST file\nRun 'Build manifest' to generate one\n";my%dist_files=map {$self->localize_file_path($_)=>$_}keys %$manifest;my@pm_files=sort grep {$_ !~ m{^t}}grep {exists$dist_files{$_}}keys %{$self->find_pm_files};return$self->find_packages_in_files(\@pm_files,\%dist_files)}sub find_packages_in_files {my ($self,$file_list,$filename_map)=@_;my(%prime,%alt);for my$file (@{$file_list}){my$mapped_filename=$filename_map->{$file};my@path=split(/\//,$mapped_filename);(my$prime_package=join('::',@path[1..$#path]))=~ s/\.pm$//;my$pm_info=Module::Metadata->new_from_file($file);for my$package ($pm_info->packages_inside){next if$package eq 'main';next if$package eq 'DB';next if grep /^_/,split(/::/,$package);my$version=$pm_info->version($package);if ($package eq $prime_package){if (exists($prime{$package})){die "Unexpected conflict in '$package'; multiple versions found.\n"}else {$prime{$package}{file}=$mapped_filename;$prime{$package}{version}=$version if defined($version)}}else {push(@{$alt{$package}},{file=>$mapped_filename,version=>$version,})}}}for my$package (sort keys(%alt)){my$result=$self->_resolve_module_versions($alt{$package});if (exists($prime{$package})){if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" .$result->{err})}elsif (defined($result->{version})){if (exists($prime{$package}{version})&& defined($prime{$package}{version})){if ($self->compare_versions($prime{$package}{version},'!=',$result->{version})){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" ."  $result->{file} ($result->{version})\n")}}else {$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}}}else {}}else {if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" .$result->{err})}$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}if defined($result->{version})}}for my$provides (values%prime){if ($provides->{version}){$provides->{version}=$self->normalize_version($provides->{version})}else {delete$provides->{version}}}return \%prime}sub _resolve_module_versions {my$self=shift;my$packages=shift;my($file,$version);my$err='';for my$p (@$packages){if (defined($p->{version})){if (defined($version)){if ($self->compare_versions($version,'!=',$p->{version})){$err .= "  $p->{file} ($p->{version})\n"}else {}}else {$file=$p->{file};$version=$p->{version}}}$file ||= $p->{file}if defined($p->{file})}if ($err){$err="  $file ($version)\n" .$err}my%result=(file=>$file,version=>$version,err=>$err);return \%result}sub make_tarball {my ($self,$dir,$file)=@_;$file ||= $dir;$self->log_info("Creating $file.tar.gz\n");if ($self->{args}{tar}){my$tar_flags=$self->verbose ? 'cvf' : 'cf';$self->do_system($self->split_like_shell($self->{args}{tar}),$tar_flags,"$file.tar",$dir);$self->do_system($self->split_like_shell($self->{args}{gzip}),"$file.tar")if$self->{args}{gzip}}else {eval {require Archive::Tar && Archive::Tar->VERSION(1.09);1}or die "You must install Archive::Tar 1.09+ to make a distribution tarball\n"."or specify a binary tar program with the '--tar' option.\n"."See the documentation for the 'dist' action.\n";my$files=$self->rscan_dir($dir);$Archive::Tar::DO_NOT_USE_PREFIX=(grep {length($_)>= 100}@$files)? 0 : 1;my$tar=Archive::Tar->new;$tar->add_files(@$files);for my$f ($tar->get_files){$f->mode($f->mode & ~022)}$tar->write("$file.tar.gz",1)}}sub install_path {my$self=shift;my($type,$value)=(@_,'<empty>');Carp::croak('Type argument missing')unless defined($type);my$map=$self->{properties}{install_path};return$map unless @_;unless (defined($value)){delete($map->{$type});return undef}if ($value eq '<empty>'){return undef unless exists$map->{$type};return$map->{$type}}return$map->{$type}=$value}sub install_sets {my ($self,$dirs,$key,$value)=@_;$dirs=$self->installdirs unless defined$dirs;if (@_==4 && defined$dirs && defined$key){$self->{properties}{install_sets}{$dirs}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{install_sets},$self->_default_install_paths->{install_sets})};if (defined$dirs && defined$key){return$map->{$dirs}{$key}}elsif (defined$dirs){return$map->{$dirs}}else {croak "Can't determine installdirs for install_sets()"}}sub original_prefix {my ($self,$key,$value)=@_;if (@_==3 && defined$key){$self->{properties}{original_prefix}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{original_prefix},$self->_default_install_paths->{original_prefix})};return$map unless defined$key;return$map->{$key}}sub install_base_relpaths {my$self=shift;if (@_ > 1){$self->_set_relpaths($self->{properties}{install_base_relpaths},@_)}my$map={$self->_merge_arglist($self->{properties}{install_base_relpaths},$self->_default_install_paths->{install_base_relpaths})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub prefix_relpaths {my$self=shift;my$installdirs=shift || $self->installdirs or croak "Can't determine installdirs for prefix_relpaths()";if (@_ > 1){$self->{properties}{prefix_relpaths}{$installdirs}||= {};$self->_set_relpaths($self->{properties}{prefix_relpaths}{$installdirs},@_)}my$map={$self->_merge_arglist($self->{properties}{prefix_relpaths}{$installdirs},$self->_default_install_paths->{prefix_relpaths}{$installdirs})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub _set_relpaths {my$self=shift;my($map,$type,$value)=@_;Carp::croak('Type argument missing')unless defined($type);if (!defined($value)){$map->{$type}=undef;return}else {Carp::croak("Value must be a relative path")if File::Spec::Unix->file_name_is_absolute($value);my@value=split(/\//,$value);$map->{$type}=\@value}}sub prefix_relative {my ($self,$type)=@_;my$installdirs=$self->installdirs;my$relpath=$self->install_sets($installdirs)->{$type};return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type,)}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m|/$|;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined($path)&& length($path);if(!defined($path)|| (length($path)==0)){$self->log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->log_verbose("    now $path in $rprefix\n");return$path}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return$default}}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,$relpath): undef}if ($self->prefix){my$relpath=$self->prefix_relative($type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs)->{$type}}sub install_types {my$self=shift;my%types;if ($self->install_base){%types=%{$self->install_base_relpaths}}elsif ($self->prefix){%types=%{$self->prefix_relpaths}}else {%types=%{$self->install_sets($self->installdirs)}}%types=(%types,%{$self->install_path});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my(%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push(@skipping,$type)}}$self->log_warn("WARNING: Can't figure out install path for types: @skipping\n" ."Files will not be installed.\n")if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}sub depends_on {my$self=shift;for my$action (@_){$self->_call_action($action)}}sub rscan_dir {my ($self,$dir,$pattern)=@_;my@result;local $_;my$subr=!$pattern ? sub {push@result,$File::Find::name}: !ref($pattern)|| (ref$pattern eq 'Regexp')? sub {push@result,$File::Find::name if /$pattern/}: ref($pattern)eq 'CODE' ? sub {push@result,$File::Find::name if$pattern->()}: die "Unknown pattern type";File::Find::find({wanted=>$subr,no_chdir=>1,preprocess=>sub {sort @_}},$dir);return \@result}sub delete_filetree {my$self=shift;my$deleted=0;for (@_){next unless -e $_;$self->log_verbose("Deleting $_\n");File::Path::rmtree($_,0,0);die "Couldn't remove '$_': $!\n" if -e $_;$deleted++}return$deleted}sub autosplit_file {my ($self,$file,$to)=@_;require AutoSplit;my$dir=File::Spec->catdir($to,'lib','auto');AutoSplit::autosplit($file,$dir)}sub cbuilder {my$self=shift;my$s=$self->{stash};return$s->{_cbuilder}if$s->{_cbuilder};require ExtUtils::CBuilder;return$s->{_cbuilder}=ExtUtils::CBuilder->new(config=>$self->config,($self->quiet ? (quiet=>1): ()),)}sub have_c_compiler {my ($self)=@_;my$p=$self->{properties};return$p->{_have_c_compiler}if defined$p->{_have_c_compiler};$self->log_verbose("Checking if compiler tools configured... ");my$b=$self->cbuilder;my$have=$b && eval {$b->have_compiler};$self->log_verbose($have ? "ok.\n" : "failed.\n");return$p->{_have_c_compiler}=$have}sub compile_c {my ($self,$file,%args)=@_;if (!$self->have_c_compiler){die "Error: no compiler detected to compile '$file'.  Aborting\n"}my$b=$self->cbuilder;my$obj_file=$b->object_file($file);$self->add_to_cleanup($obj_file);return$obj_file if$self->up_to_date($file,$obj_file);$b->compile(source=>$file,defines=>$args{defines},object_file=>$obj_file,include_dirs=>$self->include_dirs,extra_compiler_flags=>$self->extra_compiler_flags,);return$obj_file}sub link_c {my ($self,$spec)=@_;my$p=$self->{properties};$self->add_to_cleanup($spec->{lib_file});my$objects=$p->{objects}|| [];return$spec->{lib_file}if$self->up_to_date([$spec->{obj_file},@$objects],$spec->{lib_file});my$module_name=$spec->{module_name}|| $self->module_name;$self->cbuilder->link(module_name=>$module_name,objects=>[$spec->{obj_file},@$objects],lib_file=>$spec->{lib_file},extra_linker_flags=>$self->extra_linker_flags);return$spec->{lib_file}}sub compile_xs {my ($self,$file,%args)=@_;$self->log_verbose("$file -> $args{outfile}\n");if (eval {require ExtUtils::ParseXS;1}){ExtUtils::ParseXS::process_file(filename=>$file,prototypes=>0,output=>$args{outfile},)}else {my$xsubpp=Module::Metadata->find_module_by_name('ExtUtils::xsubpp')or die "Can't find ExtUtils::xsubpp in INC (@INC)";my@typemaps;push@typemaps,Module::Metadata->find_module_by_name('ExtUtils::typemap',\@INC);my$lib_typemap=Module::Metadata->find_module_by_name('typemap',[File::Basename::dirname($file),File::Spec->rel2abs('.')]);push@typemaps,$lib_typemap if$lib_typemap;@typemaps=map {+'-typemap',$_}@typemaps;my$cf=$self->{config};my$perl=$self->{properties}{perl};my@command=($perl,"-I".$cf->get('installarchlib'),"-I".$cf->get('installprivlib'),$xsubpp,'-noprototypes',@typemaps,$file);$self->log_info("@command\n");open(my$fh,'>',$args{outfile})or die "Couldn't write $args{outfile}: $!";print {$fh}$self->_backticks(@command);close$fh}}sub split_like_shell {my ($self,$string)=@_;return ()unless defined($string);return @$string if ref$string eq 'ARRAY';$string =~ s/^\s+|\s+$//g;return ()unless length($string);return Text::ParseWords::shellwords($string)}sub oneliner {my($self,$cmd,$switches,$args)=@_;$switches=[]unless defined$switches;$args=[]unless defined$args;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;return$self->_quote_args($perl,@$switches,'-e',$cmd,@$args)}sub run_perl_script {my ($self,$script,$preargs,$postargs)=@_;for ($preargs,$postargs){$_=[$self->split_like_shell($_)]unless ref()}return$self->run_perl_command([@$preargs,$script,@$postargs])}sub run_perl_command {my ($self,$args)=@_;$args=[$self->split_like_shell($args)]unless ref($args);my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;local$ENV{PERL5LIB}=join$self->config('path_sep'),$self->_added_to_INC;return$self->do_system($perl,@$args)}sub _infer_xs_spec {my$self=shift;my$file=shift;my$cf=$self->{config};my%spec;my($v,$d,$f)=File::Spec->splitpath($file);my@d=File::Spec->splitdir($d);(my$file_base=$f)=~ s/\.[^.]+$//i;$spec{base_name}=$file_base;$spec{src_dir}=File::Spec->catpath($v,$d,'');shift(@d)while@d && ($d[0]eq 'lib' || $d[0]eq '');pop(@d)while@d && $d[-1]eq '';$spec{module_name}=join('::',(@d,$file_base));$spec{archdir}=File::Spec->catdir($self->blib,'arch','auto',@d,$file_base);$spec{c_file}=File::Spec->catfile($spec{src_dir},"${file_base}.c");$spec{obj_file}=File::Spec->catfile($spec{src_dir},"${file_base}".$cf->get('obj_ext'));require DynaLoader;my$modfname=defined&DynaLoader::mod2fname ? DynaLoader::mod2fname([@d,$file_base]): $file_base;$spec{bs_file}=File::Spec->catfile($spec{archdir},"$modfname.bs");$spec{lib_file}=File::Spec->catfile($spec{archdir},"$modfname.".$cf->get('dlext'));return \%spec}sub process_xs {my ($self,$file)=@_;my$spec=$self->_infer_xs_spec($file);(my$file_base=$file)=~ s/\.[^.]+$//;$self->add_to_cleanup($spec->{c_file});unless ($self->up_to_date($file,$spec->{c_file})){$self->compile_xs($file,outfile=>$spec->{c_file})}my$v=$self->dist_version;$self->compile_c($spec->{c_file},defines=>{VERSION=>qq{"$v"},XS_VERSION=>qq{"$v"}});File::Path::mkpath($spec->{archdir},0,oct(777))unless -d $spec->{archdir};$self->add_to_cleanup($spec->{bs_file});unless ($self->up_to_date($file,$spec->{bs_file})){require ExtUtils::Mkbootstrap;$self->log_info("ExtUtils::Mkbootstrap::Mkbootstrap('$spec->{bs_file}')\n");ExtUtils::Mkbootstrap::Mkbootstrap($spec->{bs_file});open(my$fh,'>>',$spec->{bs_file});utime((time)x2,$spec->{bs_file})}$self->link_c($spec)}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my%seen;my$sep=$self->config('path_sep');local$ENV{PERL5LIB}=(!exists($ENV{PERL5LIB})? '' : length($ENV{PERL5LIB})< 500 ? $ENV{PERL5LIB}: join$sep,grep {!$seen{$_}++ and -d $_}split($sep,$ENV{PERL5LIB}));my$status=system(@cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub copy_if_modified {my$self=shift;my%args=(@_ > 3 ? (@_): (from=>shift,to_dir=>shift,flatten=>shift));$args{verbose}=!$self->quiet unless exists$args{verbose};my$file=$args{from};unless (defined$file and length$file){die "No 'from' parameter given to copy_if_modified"}$args{flatten}=1 if File::Spec->file_name_is_absolute($file);my$to_path;if (defined$args{to}and length$args{to}){$to_path=$args{to}}elsif (defined$args{to_dir}and length$args{to_dir}){$to_path=File::Spec->catfile($args{to_dir},$args{flatten}? File::Basename::basename($file): $file)}else {die "No 'to' or 'to_dir' parameter given to copy_if_modified"}return if$self->up_to_date($file,$to_path);{local$self->{properties}{quiet}=1;$self->delete_filetree($to_path)}File::Path::mkpath(File::Basename::dirname($to_path),0,oct(777));$self->log_verbose("Copying $file -> $to_path\n");if ($^O eq 'os2'){chmod 0666,$to_path;File::Copy::syscopy($file,$to_path,0x1)or die "Can't copy('$file', '$to_path'): $!"}else {File::Copy::copy($file,$to_path)or die "Can't copy('$file', '$to_path'): $!"}my$mode=oct(444)| ($self->is_executable($file)? oct(111): 0);chmod($mode,$to_path);return$to_path}sub up_to_date {my ($self,$source,$derived)=@_;$source=[$source]unless ref$source;$derived=[$derived]unless ref$derived;return 0 if @$source &&!@$derived || grep {not -e}@$derived;my$most_recent_source=time / (24*60*60);for my$file (@$source){unless (-e $file){$self->log_warn("Can't find source file $file for up-to-date check");next}$most_recent_source=-M _ if -M _ < $most_recent_source}for my$derived (@$derived){return 0 if -M $derived > $most_recent_source}return 1}sub dir_contains {my ($self,$first,$second)=@_;($first,$second)=map File::Spec->canonpath($_),($first,$second);my@first_dirs=File::Spec->splitdir($first);my@second_dirs=File::Spec->splitdir($second);return 0 if@second_dirs < @first_dirs;my$is_same=($self->_case_tolerant ? sub {lc(shift())eq lc(shift())}: sub {shift()eq shift()});while (@first_dirs){return 0 unless$is_same->(shift@first_dirs,shift@second_dirs)}return 1}1;
  
  ERRORS/WARNINGS FOUND IN PREREQUISITES.  You may wish to install the versions
  of the modules indicated above before proceeding with this installation
  
  EOF
  * FATAL ERROR: Perl interpreter mismatch. Configuration was initially
    created with '$self->{properties}{perl}'
    but we are now using '$perl'.  You must
    run 'Build realclean' or 'make realclean' and re-configure.
  DIEFATAL
  * WARNING: Configuration was initially created with Module::Build
    version '$self->{properties}{mb_version}' but we are now using version '$mb_version'.
    If errors occur, you must re-run the Build.PL or Makefile.PL script.
  MISMATCH
  ERROR: This build seems to be unattended, but there is no default value
  for this question.  Aborting.
  EOF
  package $opts{class};
  use $pack;
  \@ISA = qw($pack);
  $opts{code}
  1;
  EOF
  No 'module_name' was provided and it could not be inferred
  from other properties.  This will prevent a packlist from
  being written for this file.  Please set either 'module_name'
  or 'dist_version_from' in Build.PL.
  END_WARN
  Bundling in inc/ is disabled because ExtUtils::Installed could not
  create a list of your installed modules.  Here is the error:
  $@
  EUI_ERROR
  Could not find a packlist for '$mod'.  If it's a core module, try
  force installing it from CPAN.
  NO_PACKLIST
  Module::Build was not found in configure_requires! Adding it now
  automatically as: configure_requires => { 'Module::Build' => $ver }
  EOM
  Warning: ExtUtils::CBuilder not installed or no compiler detected
  Proceeding with configuration, but compilation may fail during Build
  
  EOM
      if ($INC[-1] ne '.') {
          push @INC, '.';
      }
  END
  $shebang
  
  use strict;
  use Cwd;
  use File::Basename;
  use File::Spec;
  
  sub magic_number_matches {
    return 0 unless -e '$q{magic_numfile}';
    my \$FH;
    open \$FH, '<','$q{magic_numfile}' or return 0;
    my \$filenum = <\$FH>;
    close \$FH;
    return \$filenum == $magic_number;
  }
  
  my \$progname;
  my \$orig_dir;
  BEGIN {
    \$^W = 1;  # Use warnings
    \$progname = basename(\$0);
    \$orig_dir = Cwd::cwd();
    my \$base_dir = '$q{base_dir}';
    if (!magic_number_matches()) {
      unless (chdir(\$base_dir)) {
        die ("Couldn't chdir(\$base_dir), aborting\\n");
      }
      unless (magic_number_matches()) {
        die ("Configuration seems to be out of date, please re-run 'perl Build.PL' again.\\n");
      }
    }
    unshift \@INC,
      (
  $quoted_INC
      );
  $dot_in_inc_code
  }
  
  close(*DATA) unless eof(*DATA); # ensure no open handles to this script
  
  use $build_package;
  Module::Build->VERSION(q{$config_requires});
  
  # Some platforms have problems setting \$^X in shebang contexts, fix it up here
  \$^X = Module::Build->find_perl_interpreter;
  
  if (-e 'Build.PL' and not $build_package->up_to_date('Build.PL', \$progname)) {
     warn "Warning: Build.PL has been altered.  You may need to run 'perl Build.PL' again.\\n";
  }
  
  # This should have just enough arguments to be able to bootstrap the rest.
  my \$build = $build_package->resume (
    properties => {
      config_dir => '$q{config_dir}',
      orig_dir => \$orig_dir,
    },
  );
  
  \$build->dispatch;
  EOF
  
   Usage: $0 <action> --arg1=value --arg2=value ...
   Example: $0 test --verbose=1
  
   Actions defined:
  EOF
  Can't create LICENSE file: '$l' is not a valid license key
  or Software::License subclass;
  HERE
  Cannot create README: can't determine which file contains documentation;
  Must supply either 'dist_version_from', or 'module_name' parameter.
  EOF
  # Avoid configuration metadata file
  ^MYMETA\.
  
  # Avoid Module::Build generated and utility files.
  \bBuild$
  \bBuild.bat$
  \b_build
  \bBuild.COM$
  \bBUILD.COM$
  \bbuild.com$
  ^MANIFEST\.SKIP
  
  # Avoid archives of this distribution
  EOF
MODULE_BUILD_BASE

$fatpacked{"Module/Build/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COMPAT';
  package Module::Build::Compat;use strict;use warnings;our$VERSION='0.4229';use File::Basename ();use File::Spec;use Config;use Module::Build;use Module::Metadata;use version;use Data::Dumper;my%convert_installdirs=(PERL=>'core',SITE=>'site',VENDOR=>'vendor',);my%makefile_to_build=(TEST_VERBOSE=>'verbose',VERBINST=>'verbose',INC=>sub {map {(extra_compiler_flags=>$_)}Module::Build->split_like_shell(shift)},POLLUTE=>sub {(extra_compiler_flags=>'-DPERL_POLLUTE')},INSTALLDIRS=>sub {(installdirs=>$convert_installdirs{uc shift()})},LIB=>sub {my$lib=shift;my%config=(installprivlib=>$lib,installsitelib=>$lib,installarchlib=>"$lib/$Config{archname}",installsitearch=>"$lib/$Config{archname}");return map {(config=>"$_=$config{$_}")}sort keys%config},(map {my$name=$_;$name=>sub {my@ret=(config=>lc($name)."=" .shift);print STDERR "# Converted to @ret\n";return@ret}}qw(INSTALLARCHLIB INSTALLSITEARCH INSTALLVENDORARCH INSTALLPRIVLIB INSTALLSITELIB INSTALLVENDORLIB INSTALLBIN INSTALLSITEBIN INSTALLVENDORBIN INSTALLSCRIPT INSTALLSITESCRIPT INSTALLVENDORSCRIPT INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR)),map {$_,lc($_)}qw(DESTDIR PREFIX INSTALL_BASE UNINST),);my%macro_to_build=%makefile_to_build;delete$macro_to_build{LIB};sub _merge_prereq {my ($req,$breq)=@_;$req ||= {};$breq ||= {};for my$p ($req,$breq){for my$k (sort keys %$p){next if$k eq 'perl';my$v_obj=eval {version->new($p->{$k})};if (!defined$v_obj){die "A prereq of the form '$p->{$k}' for '$k' is not supported by Module::Build::Compat ( use a simpler version like '0.05' or 'v1.4.25' )\n"}if ($v_obj->is_qv){my$proper_ver=$v_obj->numify;warn "Dotted-decimal prereq '$p->{$k}' for '$k' is not portable - converting it to '$proper_ver'\n";$p->{$k}=$proper_ver}}}my$merge={%$req };for my$k (keys %$breq){my$v1=$merge->{$k}|| 0;my$v2=$breq->{$k};$merge->{$k}=$v1 > $v2 ? $v1 : $v2}return %$merge}sub create_makefile_pl {my ($package,$type,$build,%args)=@_;die "Don't know how to build Makefile.PL of type '$type'" unless$type =~ /^(small|passthrough|traditional)$/;if ($type eq 'passthrough'){$build->log_warn(<<"HERE")}my$fh;if ($args{fh}){$fh=$args{fh}}else {$args{file}||= 'Makefile.PL';local$build->{properties}{quiet}=1;$build->delete_filetree($args{file});open($fh,'>',"$args{file}")or die "Can't write $args{file}: $!"}print {$fh}"# Note: this file was auto-generated by ",__PACKAGE__," version $VERSION\n";my$requires=$build->requires;if (my$minimum_perl=$requires->{perl}){my$min_ver=version->new($minimum_perl)->numify;print {$fh}"require $min_ver;\n"}my$subclass_load='';if (ref($build)ne "Module::Build"){my$subclass_dir=$package->subclass_dir($build);if (File::Spec->file_name_is_absolute($subclass_dir)){my$base_dir=$build->base_dir;if ($build->dir_contains($base_dir,$subclass_dir)){$subclass_dir=File::Spec->abs2rel($subclass_dir,$base_dir);$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}else {$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}if ($type eq 'small'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'passthrough'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'traditional'){my (%MM_Args,%prereq);if (eval "use Tie::IxHash 1.2; 1"){tie%MM_Args,'Tie::IxHash';tie%prereq,'Tie::IxHash'}my%name=($build->module_name ? (NAME=>$build->module_name): (DISTNAME=>$build->dist_name));my%version=($build->dist_version_from ? (VERSION_FROM=>$build->dist_version_from): (VERSION=>$build->dist_version));%MM_Args=(%name,%version);%prereq=_merge_prereq($build->requires,$build->build_requires);%prereq=map {$_,$prereq{$_}}sort keys%prereq;delete$prereq{perl};$MM_Args{PREREQ_PM}=\%prereq;$MM_Args{INSTALLDIRS}=$build->installdirs eq 'core' ? 'perl' : $build->installdirs;$MM_Args{EXE_FILES}=[sort keys %{$build->script_files}]if$build->script_files;$MM_Args{PL_FILES}=$build->PL_files || {};if ($build->recursive_test_files){$MM_Args{test}={TESTS=>join q{ },$package->_test_globs($build)}}local$Data::Dumper::Terse=1;my$args=Data::Dumper::Dumper(\%MM_Args);$args =~ s/\{(.*)\}/($1)/s;print$fh <<"EOF"}}sub _test_globs {my ($self,$build)=@_;return map {File::Spec->catfile($_,'*.t')}@{$build->rscan_dir('t',sub {-d $File::Find::name})}}sub subclass_dir {my ($self,$build)=@_;return (Module::Metadata->find_module_dir_by_name(ref$build)|| File::Spec->catdir($build->config_dir,'lib'))}sub unixify_dir {my ($self,$path)=@_;return join '/',File::Spec->splitdir($path)}sub makefile_to_build_args {my$class=shift;my@out;for my$arg (@_){next if$arg eq '';my ($key,$val)=($arg =~ /^(\w+)=(.+)/ ? ($1,$2): die "Malformed argument '$arg'");($val)=Module::Build->_detildefy($val)if$val =~ /^~/;if (exists$makefile_to_build{$key}){my$trans=$makefile_to_build{$key};push@out,$class->_argvify(ref($trans)? $trans->($val): ($trans=>$val))}elsif (exists$Config{lc($key)}){push@out,$class->_argvify(config=>lc($key)."=$val")}else {push@out,$class->_argvify("\L$key"=>$val)}}return@out}sub _argvify {my ($self,@pairs)=@_;my@out;while (@pairs){my ($k,$v)=splice@pairs,0,2;push@out,("--$k",$v)}return@out}sub makefile_to_build_macros {my@out;my%config;for my$macro (sort keys%macro_to_build){my$trans=$macro_to_build{$macro};next unless exists$ENV{$macro}&& length$ENV{$macro};my$val=$ENV{$macro};my@args=ref($trans)? $trans->($val): ($trans=>$val);while (@args){my ($k,$v)=splice(@args,0,2);if ($k eq 'config'){if ($v =~ /^([^=]+)=(.*)$/){$config{$1}=$2}else {warn "Couldn't parse config '$v'\n"}}else {push@out,($k=>$v)}}}push@out,(config=>\%config)if%config;return@out}sub run_build_pl {my ($pack,%in)=@_;$in{script}||= 'Build.PL';my@args=$in{args}? $pack->makefile_to_build_args(@{$in{args}}): ();print "# running $in{script} @args\n";Module::Build->run_perl_script($in{script},[],\@args)or die "Couldn't run $in{script}: $!"}sub fake_makefile {my ($self,%args)=@_;unless (exists$args{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$args{build_class}='Module::Build'}my$class=$args{build_class};my$perl=$class->find_perl_interpreter;$perl='MCR ' .$perl if$self->_is_vms_mms;my$noop=($class->is_windowsish ? 'rem>nul' : $self->_is_vms_mms ? 'Continue' : 'true');my$filetype=$class->is_vmsish ? '.COM' : '';my$Build='Build' .$filetype .' --makefile_env_macros 1';my$unlink=$class->oneliner('1 while unlink $ARGV[0]',[],[$args{makefile}]);$unlink =~ s/\$/\$\$/g unless$class->is_vmsish;my$maketext=join '',map {"$_=\n"}sort keys%macro_to_build;$maketext .= ($^O eq 'os2' ? "SHELL = sh\n\n" : $^O eq 'MSWin32' && $Config{make}=~ /gmake/ ? "SHELL = $ENV{COMSPEC}\n\n" : "\n\n");$maketext .= <<"EOF";for my$action ($class->known_actions){next if$action =~ /^(all|distclean|realclean|force_do_it)$/;$maketext .= <<"EOF"}if ($self->_is_vms_mms){$maketext .= "\n.FIRST\n\t\@ $noop\n";for my$macro (sort keys%macro_to_build){$maketext .= ".IFDEF $macro\n\tDEFINE $macro \"\$($macro)\"\n.ENDIF\n"}$maketext .= "\n"}else {$maketext .= "\n.EXPORT : " .join(' ',sort keys%macro_to_build)."\n\n"}return$maketext}sub fake_prereqs {my$file=File::Spec->catfile('_build','prereqs');open(my$fh,'<',"$file")or die "Can't read $file: $!";my$prereqs=eval do {local $/;<$fh>};close$fh;my%merged=_merge_prereq($prereqs->{requires},$prereqs->{build_requires});my@prereq;for (sort keys%merged){next if $_ eq 'perl';push@prereq,"$_=>q[$merged{$_}]"}return unless@prereq;return "#     PREREQ_PM => { " .join(", ",@prereq)." }\n\n"}sub write_makefile {my ($pack,%in)=@_;unless (exists$in{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$in{build_class}='Module::Build'}my$class=$in{build_class};$in{makefile}||= $pack->_is_vms_mms ? 'Descrip.MMS' : 'Makefile';open MAKE,"> $in{makefile}" or die "Cannot write $in{makefile}: $!";print MAKE$pack->fake_prereqs;print MAKE$pack->fake_makefile(%in);close MAKE}sub _is_vms_mms {return Module::Build->is_vmsish && ($Config{make}=~ m/MM[SK]/i)}1;
  
  IMPORTANT NOTE: The '$type' style of Makefile.PL is deprecated and
  may be removed in a future version of Module::Build in favor of the
  'configure_requires' property.  See Module::Build::Compat
  documentation for details.
  
  HERE
      use Module::Build::Compat 0.02;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  
      unless (eval "use Module::Build::Compat 0.02; 1" ) {
        print "This module requires Module::Build to install itself.\n";
  
        require ExtUtils::MakeMaker;
        my $yn = ExtUtils::MakeMaker::prompt
  	('  Install Module::Build now from CPAN?', 'y');
  
        unless ($yn =~ /^y/i) {
  	die " *** Cannot install without Module::Build.  Exiting ...\n";
        }
  
        require Cwd;
        require File::Spec;
        require CPAN;
  
        # Save this 'cause CPAN will chdir all over the place.
        my $cwd = Cwd::cwd();
  
        CPAN::Shell->install('Module::Build::Compat');
        CPAN::Shell->expand("Module", "Module::Build::Compat")->uptodate
  	or die "Couldn't install Module::Build, giving up.\n";
  
        chdir $cwd or die "Cannot chdir() back to $cwd: $!";
      }
      eval "use Module::Build::Compat 0.02; 1" or die $@;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      my $build_script = 'Build';
      $build_script .= '.com' if $^O eq 'VMS';
      exit(0) unless(-e $build_script); # cpantesters convention
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  use ExtUtils::MakeMaker;
  WriteMakefile
  $args;
  EOF
  all : force_do_it
  	$perl $Build
  realclean : force_do_it
  	$perl $Build realclean
  	$unlink
  distclean : force_do_it
  	$perl $Build distclean
  	$unlink
  
  
  force_do_it :
  	@ $noop
  EOF
  $action : force_do_it
  	$perl $Build $action
  EOF
MODULE_BUILD_COMPAT

$fatpacked{"Module/Build/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIG';
  package Module::Build::Config;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Config;sub new {my ($pack,%args)=@_;return bless {stack=>{},values=>$args{values}|| {},},$pack}sub get {my ($self,$key)=@_;return$self->{values}{$key}if ref($self)&& exists$self->{values}{$key};return$Config{$key}}sub set {my ($self,$key,$val)=@_;$self->{values}{$key}=$val}sub push {my ($self,$key,$val)=@_;push @{$self->{stack}{$key}},$self->{values}{$key}if exists$self->{values}{$key};$self->{values}{$key}=$val}sub pop {my ($self,$key)=@_;my$val=delete$self->{values}{$key};if (exists$self->{stack}{$key}){$self->{values}{$key}=pop @{$self->{stack}{$key}};delete$self->{stack}{$key}unless @{$self->{stack}{$key}}}return$val}sub values_set {my$self=shift;return undef unless ref($self);return$self->{values}}sub all_config {my$self=shift;my$v=ref($self)? $self->{values}: {};return {%Config,%$v}}1;
MODULE_BUILD_CONFIG

$fatpacked{"Module/Build/ConfigData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIGDATA';
  package Module::Build::ConfigData;use strict;my$arrayref=eval do {local $/;<DATA>}or die "Couldn't load ConfigData data: $@";close DATA;my ($config,$features,$auto_features)=@$arrayref;sub config {$config->{$_[1]}}sub set_config {$config->{$_[1]}=$_[2]}sub set_feature {$features->{$_[1]}=0+!!$_[2]}sub auto_feature_names {sort grep!exists$features->{$_},keys %$auto_features}sub feature_names {my@features=(sort keys %$features,auto_feature_names());@features}sub config_names {sort keys %$config}sub write {my$me=__FILE__;require Data::Dumper;my$mode_orig=(stat$me)[2]& 07777;chmod($mode_orig | 0222,$me);open(my$fh,'+<',$me)or die "Can't rewrite $me: $!";seek($fh,0,0);while (<$fh>){last if /^__DATA__$/}die "Couldn't find __DATA__ token in $me" if eof($fh);seek($fh,tell($fh),0);my$data=[$config,$features,$auto_features];print($fh 'do{ my ' .Data::Dumper->new([$data],['x'])->Purity(1)->Dump().'$x; }');truncate($fh,tell($fh));close$fh;chmod($mode_orig,$me)or warn "Couldn't restore permissions on $me: $!"}sub feature {my ($package,$key)=@_;return$features->{$key}if exists$features->{$key};my$info=$auto_features->{$key}or return 0;require Module::Build;for my$type (sort keys %$info){my$prereqs=$info->{$type};next if$type eq 'description' || $type eq 'recommends';for my$modname (sort keys %$prereqs){my$status=Module::Build->check_installed_status($modname,$prereqs->{$modname});if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}__DATA__ do{ my $x = [
         {},
         {},
         {
           'HTML_support' => {
                               'description' => 'Create HTML documentation',
                               'requires' => {
                                               'Pod::Html' => 0
                                             }
                             },
           'PPM_support' => {
                              'description' => 'Generate PPM files for distributions'
                            },
           'dist_authoring' => {
                                 'description' => 'Create new distributions',
                                 'recommends' => {
                                                   'Module::Signature' => '0.21',
                                                   'Pod::Readme' => '0.04'
                                                 },
                                 'requires' => {
                                                 'Archive::Tar' => '1.09'
                                               }
                               },
           'inc_bundling_support' => {
                                       'description' => 'Bundle Module::Build in inc/',
                                       'requires' => {
                                                       'ExtUtils::Install' => '1.54',
                                                       'ExtUtils::Installed' => '1.999',
                                                       'inc::latest' => '0.5'
                                                     }
                                     },
           'license_creation' => {
                                   'description' => 'Create licenses automatically in distributions',
                                   'requires' => {
                                                   'Software::License' => '0.103009'
                                                 }
                                 },
           'manpage_support' => {
                                  'description' => 'Create Unix man pages',
                                  'requires' => {
                                                  'Pod::Man' => 0
                                                }
                                }
         }
       ];
  $x; }
MODULE_BUILD_CONFIGDATA

$fatpacked{"Module/Build/Cookbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COOKBOOK';
  package Module::Build::Cookbook;use strict;use warnings;our$VERSION='0.4229';
MODULE_BUILD_COOKBOOK

$fatpacked{"Module/Build/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_DUMPER';
  package Module::Build::Dumper;use strict;use warnings;our$VERSION='0.4229';use Data::Dumper;sub _data_dump {my ($self,$data)=@_;return ("do{ my " .Data::Dumper->new([$data],['x'])->Purity(1)->Terse(0)->Sortkeys(1)->Dump().'$x; }')}1;
MODULE_BUILD_DUMPER

$fatpacked{"Module/Build/Notes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_NOTES';
  package Module::Build::Notes;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Data::Dumper;use Module::Build::Dumper;sub new {my ($class,%args)=@_;my$file=delete$args{file}or die "Missing required parameter 'file' to new()";my$self=bless {disk=>{},new=>{},file=>$file,%args,},$class}sub restore {my$self=shift;open(my$fh,'<',$self->{file})or die "Can't read $self->{file}: $!";$self->{disk}=eval do {local $/;<$fh>};die $@ if $@;close$fh;$self->{new}={}}sub access {my$self=shift;return$self->read()unless @_;my$key=shift;return$self->read($key)unless @_;my$value=shift;$self->write({$key=>$value });return$self->read($key)}sub has_data {my$self=shift;return keys %{$self->read()}> 0}sub exists {my ($self,$key)=@_;return exists($self->{new}{$key})|| exists($self->{disk}{$key})}sub read {my$self=shift;if (@_){my$key=shift;return$self->{new}{$key}if exists$self->{new}{$key};return$self->{disk}{$key}}my$out=(keys %{$self->{new}}? {%{$self->{disk}},%{$self->{new}}}: $self->{disk});return wantarray ? %$out : $out}sub _same {my ($self,$x,$y)=@_;return 1 if!defined($x)and!defined($y);return 0 if!defined($x)or!defined($y);return$x eq $y}sub write {my ($self,$href)=@_;$href ||= {};@{$self->{new}}{keys %$href }=values %$href;for my$key (keys %{$self->{new}}){next if ref$self->{new}{$key};next if ref$self->{disk}{$key}or!exists$self->{disk}{$key};delete$self->{new}{$key}if$self->_same($self->{new}{$key},$self->{disk}{$key})}if (my$file=$self->{file}){my ($vol,$dir,$base)=File::Spec->splitpath($file);$dir=File::Spec->catpath($vol,$dir,'');return unless -e $dir && -d $dir;return if -e $file and!keys %{$self->{new}};@{$self->{disk}}{keys %{$self->{new}}}=values %{$self->{new}};$self->_dump($file,$self->{disk});$self->{new}={}}return$self->read}sub _dump {my ($self,$file,$data)=@_;open(my$fh,'>',$file)or die "Can't create '$file': $!";print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}my$orig_template=do {local $/;<DATA>};close DATA;sub write_config_data {my ($self,%args)=@_;my$template=$orig_template;$template =~ s/NOTES_NAME/$args{config_module}/g;$template =~ s/MODULE_NAME/$args{module}/g;$template =~ s/=begin private\n//;$template =~ s/=end private/=cut/;$template =~ s{$_\n}{} for '=begin private','=end private';open(my$fh,'>',$args{file})or die "Can't create '$args{file}': $!";print {$fh}$template;print {$fh}"\n__DATA__\n";print {$fh}Module::Build::Dumper->_data_dump([$args{config_data},$args{feature},$args{auto_features}]);close$fh}1;__DATA__ package NOTES_NAME;
  use strict;
  my $arrayref = eval do {local $/; <DATA>}
    or die "Couldn't load ConfigData data: $@";
  close DATA;
  my ($config, $features, $auto_features) = @$arrayref;
  
  sub config { $config->{$_[1]} }
  
  sub set_config { $config->{$_[1]} = $_[2] }
  sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0
  
  sub auto_feature_names { sort grep !exists $features->{$_}, keys %$auto_features }
  
  sub feature_names {
    my @features = (sort keys %$features, auto_feature_names());
    @features;
  }
  
  sub config_names  { sort keys %$config }
  
  sub write {
    my $me = __FILE__;
  
    # Can't use Module::Build::Dumper here because M::B is only a
    # build-time prereq of this module
    require Data::Dumper;
  
    my $mode_orig = (stat $me)[2] & 07777;
    chmod($mode_orig | 0222, $me); # Make it writeable
    open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
    seek($fh, 0, 0);
    while (<$fh>) {
      last if /^__DATA__$/;
    }
    die "Couldn't find __DATA__ token in $me" if eof($fh);
  
    seek($fh, tell($fh), 0);
    my $data = [$config, $features, $auto_features];
    print($fh 'do{ my '
  	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
  	      . '$x; }' );
    truncate($fh, tell($fh));
    close $fh;
  
    chmod($mode_orig, $me)
      or warn "Couldn't restore permissions on $me: $!";
  }
  
  sub feature {
    my ($package, $key) = @_;
    return $features->{$key} if exists $features->{$key};
  
    my $info = $auto_features->{$key} or return 0;
  
    require Module::Build;  # XXX should get rid of this
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      next if $type eq 'description' || $type eq 'recommends';
  
      foreach my $modname (sort keys %$prereqs) {
        my $status = Module::Build->check_installed_status($modname, $prereqs->{$modname});
        if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
        if ( ! eval "require $modname; 1" ) { return 0; }
      }
    }
    return 1;
  }
  
  =begin private
  
  =head1 NAME
  
  NOTES_NAME - Configuration for MODULE_NAME
  
  =head1 SYNOPSIS
  
    use NOTES_NAME;
    $value = NOTES_NAME->config('foo');
    $value = NOTES_NAME->feature('bar');
  
    @names = NOTES_NAME->config_names;
    @names = NOTES_NAME->feature_names;
  
    NOTES_NAME->set_config(foo => $new_value);
    NOTES_NAME->set_feature(bar => $new_value);
    NOTES_NAME->write;  # Save changes
  
  
  =head1 DESCRIPTION
  
  This module holds the configuration data for the C<MODULE_NAME>
  module.  It also provides a programmatic interface for getting or
  setting that configuration data.  Note that in order to actually make
  changes, you'll have to have write access to the C<NOTES_NAME>
  module, and you should attempt to understand the repercussions of your
  actions.
  
  
  =head1 METHODS
  
  =over 4
  
  =item config($name)
  
  Given a string argument, returns the value of the configuration item
  by that name, or C<undef> if no such item exists.
  
  =item feature($name)
  
  Given a string argument, returns the value of the feature by that
  name, or C<undef> if no such feature exists.
  
  =item set_config($name, $value)
  
  Sets the configuration item with the given name to the given value.
  The value may be any Perl scalar that will serialize correctly using
  C<Data::Dumper>.  This includes references, objects (usually), and
  complex data structures.  It probably does not include transient
  things like filehandles or sockets.
  
  =item set_feature($name, $value)
  
  Sets the feature with the given name to the given boolean value.  The
  value will be converted to 0 or 1 automatically.
  
  =item config_names()
  
  Returns a list of all the names of config items currently defined in
  C<NOTES_NAME>, or in scalar context the number of items.
  
  =item feature_names()
  
  Returns a list of all the names of features currently defined in
  C<NOTES_NAME>, or in scalar context the number of features.
  
  =item auto_feature_names()
  
  Returns a list of all the names of features whose availability is
  dynamically determined, or in scalar context the number of such
  features.  Does not include such features that have later been set to
  a fixed value.
  
  =item write()
  
  Commits any changes from C<set_config()> and C<set_feature()> to disk.
  Requires write access to the C<NOTES_NAME> module.
  
  =back
  
  
  =head1 AUTHOR
  
  C<NOTES_NAME> was automatically created using C<Module::Build>.
  C<Module::Build> was written by Ken Williams, but he holds no
  authorship claim or copyright claim to the contents of C<NOTES_NAME>.
  
  =end private
  
MODULE_BUILD_NOTES

$fatpacked{"Module/Build/PPMMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PPMMAKER';
  package Module::Build::PPMMaker;use strict;use warnings;use Config;our$VERSION='0.4229';$VERSION=eval$VERSION;sub new {my$package=shift;return bless {@_},$package}sub make_ppd {my ($self,%args)=@_;my$build=delete$args{build};my@codebase;if (exists$args{codebase}){@codebase=ref$args{codebase}? @{$args{codebase}}: ($args{codebase})}else {my$distfile=$build->ppm_name .'.tar.gz';print "Using default codebase '$distfile'\n";@codebase=($distfile)}my%dist;for my$info (qw(name author abstract version)){my$method="dist_$info";$dist{$info}=$build->$method()or die "Can't determine distribution's $info\n"}$self->_simple_xml_escape($_)foreach$dist{abstract},@{$dist{author}};my$ppd=<<"PPD";for my$type (qw(requires)){my$prereq=$build->$type();for my$modname (sort keys %$prereq){next if$modname eq 'perl';my$min_version='0.0';for my$c ($build->_parse_conditions($prereq->{$modname})){my ($op,$version)=$c =~ /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x;if ($op eq '>='){$min_version=$version;last}}$modname .= '::' unless$modname =~ /::/;$ppd .= qq!        <REQUIRE NAME="$modname" VERSION="$min_version" />\n!}}if (keys %{$build->find_xs_files}){my$perl_version=$self->_ppd_version($build->perl_version);$ppd .= sprintf(<<'EOF',$self->_varchname($build->config))}for my$codebase (@codebase){$self->_simple_xml_escape($codebase);$ppd .= sprintf(<<'EOF',$codebase)}$ppd .= <<'EOF';my$ppd_file="$dist{name}.ppd";open(my$fh,'>',$ppd_file)or die "Cannot write to $ppd_file: $!";binmode($fh,":utf8")if $] >= 5.008 && $Config{useperlio};print$fh $ppd;close$fh;return$ppd_file}sub _ppd_version {my ($self,$version)=@_;return join ',',(split(/\./,$version),(0)x4)[0..3]}sub _varchname {my ($self,$config)=@_;my$varchname=$config->{archname};if ($] >= 5.008){my$vstring=sprintf "%vd",$^V;$vstring =~ s/\.\d+$//;$varchname .= "-$vstring"}return$varchname}{my%escapes=("\n"=>"\\n",'"'=>'&quot;','&'=>'&amp;','>'=>'&gt;','<'=>'&lt;',);my$rx=join '|',keys%escapes;sub _simple_xml_escape {$_[1]=~ s/($rx)/$escapes{$1}/go}}1;
  <SOFTPKG NAME=\"$dist{name}\" VERSION=\"$dist{version}\">
      <ABSTRACT>$dist{abstract}</ABSTRACT>
  @{[ join "\n", map "    <AUTHOR>$_</AUTHOR>", @{$dist{author}} ]}
      <IMPLEMENTATION>
  PPD
          <ARCHITECTURE NAME="%s" />
  EOF
          <CODEBASE HREF="%s" />
  EOF
      </IMPLEMENTATION>
  </SOFTPKG>
  EOF
MODULE_BUILD_PPMMAKER

$fatpacked{"Module/Build/Platform/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DEFAULT';
  package Module::Build::Platform::Default;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_DEFAULT

$fatpacked{"Module/Build/Platform/MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_MACOS';
  package Module::Build::Platform::MacOS;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);use ExtUtils::Install;sub have_forkpipe {0}sub new {my$class=shift;my$self=$class->SUPER::new(@_);for ('sitelib','sitearch'){$self->config($_=>$self->config("install$_"))unless$self->config($_)}(my$sp=$self->config('startperl'))=~ s/.*Exit \{Status\}\s//;$self->config(startperl=>$sp);return$self}sub make_executable {my$self=shift;require MacPerl;for (@_){MacPerl::SetFileInfo('McPL','TEXT',$_)}}sub dispatch {my$self=shift;if(!@_ and!@ARGV){require MacPerl;my@action_list=qw(build test install);my%actions=map {+($_,1)}$self->known_actions;delete@actions{@action_list};push@action_list,sort {$a cmp $b}keys%actions;my%toolserver=map {+$_=>1}qw(test disttest diff testdb);for (@action_list){$_ .= ' *' if$toolserver{$_}}my$cmd=MacPerl::Pick("What build command? ('*' requires ToolServer)",@action_list);return unless defined$cmd;$cmd =~ s/ \*$//;$ARGV[0]=($cmd);my$args=MacPerl::Ask('Any extra arguments?  (ie. verbose=1)','');return unless defined$args;push@ARGV,$self->split_like_shell($args)}$self->SUPER::dispatch(@_)}sub ACTION_realclean {my$self=shift;chmod 0666,$self->{properties}{build_script};$self->SUPER::ACTION_realclean}sub ACTION_install {my$self=shift;return$self->SUPER::ACTION_install(@_)if eval {ExtUtils::Install->VERSION('1.30');1};local $^W=0;local*ExtUtils::Install::find=sub {my ($code,@dirs)=@_;@dirs=map {$_ eq '.' ? File::Spec->curdir : $_}@dirs;return File::Find::find($code,@dirs)};return$self->SUPER::ACTION_install(@_)}1;
MODULE_BUILD_PLATFORM_MACOS

$fatpacked{"Module/Build/Platform/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_UNIX';
  package Module::Build::Platform::Unix;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub is_executable {my ($self,$file)=@_;return +(stat$file)[2]& 0100}sub _startperl {"#! " .shift()->perl}sub _construct {my$self=shift()->SUPER::_construct(@_);my$c=$self->{config};for (qw(siteman1 siteman3 vendorman1 vendorman3)){$c->{"install${_}dir"}||= $c->{"install${_}"}}return$self}sub _detildefy {my ($self,$value)=@_;$value =~ s[^~([^/]+)?(?=/|$)]   # tilde with optional username [$1 ? (eval{(getpwnam $1)[7]}|| "~$1"): ($ENV{HOME}|| eval{(getpwuid $>)[7]}|| glob("~"))]ex;return$value}1;
MODULE_BUILD_PLATFORM_UNIX

$fatpacked{"Module/Build/Platform/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VMS';
  package Module::Build::Platform::VMS;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;use Config;our@ISA=qw(Module::Build::Base);sub _set_defaults {my$self=shift;$self->SUPER::_set_defaults(@_);$self->{properties}{build_script}='Build.com'}sub cull_args {my$self=shift;my($action,$args)=$self->SUPER::cull_args(@_);my@possible_actions=grep {lc $_ eq lc$action}$self->known_actions;die "Ambiguous action '$action'.  Could be one of @possible_actions" if@possible_actions > 1;return ($possible_actions[0],$args)}sub manpage_separator {return '__'}sub _catprefix {my($self,$rprefix,$default)=@_;my($rvol,$rdirs)=File::Spec->splitpath($rprefix);if($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n");$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->log_verbose("  rprefix translated to $rprefix\n"."  sprefix translated to $sprefix\n");if(length($path)==0){$self->log_verbose("  no path to prefixify.\n")}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($sprefix eq $rprefix){$self->log_verbose("  no new prefix.\n")}else {my($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config('vms_prefix');if($path_vol eq $vms_prefix.':'){$self->log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix($rprefix,$path_dirs)}else {$self->log_verbose("    cannot prefixify.\n");return$self->prefix_relpaths($self->installdirs,$type)}}$self->log_verbose("    now $path\n");return$path}sub _quote_args {my ($self,@args)=@_;my$got_arrayref=(scalar(@args)==1 && ref$args[0]eq 'ARRAY')? 1 : 0;map {if (!/^\//){$_ =~ s/\"/""/g;$_=q(").$_.q(")}}($got_arrayref ? @{$args[0]}: @args);return$got_arrayref ? $args[0]: join(' ',@args)}sub have_forkpipe {0}sub _backticks {my ($self,@cmd)=@_;my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return `$cmd $args`}sub find_command {my ($self,$command)=@_;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}$self->SUPER::find_command($command)}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d _;my(@dirs)=('');my(@exts)=('',$Config{'exe_ext'},'.exe','.com');if ($file !~ m![/:>\]]!){for (my$i=0;defined$ENV{"DCL\$PATH;$i"};$i++){my$dir=$ENV{"DCL\$PATH;$i"};$dir .= ':' unless$dir =~ m%[\]:]$%;push(@dirs,$dir)}push(@dirs,'Sys$System:');for my$dir (@dirs){my$sysfile="$dir$file";for my$ext (@exts){return$file if -x "$sysfile$ext" &&!-d _}}}return}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return!system("$cmd $args")}sub oneliner {my$self=shift;my$oneliner=$self->SUPER::oneliner(@_);$oneliner =~ s/^\"\S+\"//;return "MCR $^X $oneliner"}sub rscan_dir {my ($self,$dir,$pattern)=@_;my$result=$self->SUPER::rscan_dir($dir,$pattern);for my$file (@$result){if (!_efs()&& ($file =~ m#/#)){$file =~ s/\.$//}}return$result}sub dist_dir {my$self=shift;my$dist_dir=$self->SUPER::dist_dir;$dist_dir =~ s/\./_/g unless _efs();return$dist_dir}sub man3page_name {my$self=shift;my$mpname=$self->SUPER::man3page_name(shift);my$sep=$self->manpage_separator;$mpname =~ s/^$sep//;return$mpname}sub expand_test_dir {my ($self,$dir)=@_;my@reldirs=$self->SUPER::expand_test_dir($dir);for my$eachdir (@reldirs){my ($v,$d,$f)=File::Spec->splitpath($eachdir);my$reldir=File::Spec->abs2rel(File::Spec->catpath($v,$d,''));$eachdir=File::Spec->catfile($reldir,$f)}return@reldirs}sub _detildefy {my ($self,$arg)=@_;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}sub find_perl_interpreter {return VMS::Filespec::vmsify($^X)}sub localize_file_path {my ($self,$path)=@_;$path=VMS::Filespec::vmsify($path);$path =~ s/\.\z//;return$path}sub localize_dir_path {my ($self,$path)=@_;return VMS::Filespec::vmspath($path)}sub ACTION_clean {my ($self)=@_;for my$item (map glob(VMS::Filespec::rmsexpand($_,'.;0')),$self->cleanup){$self->delete_filetree($item)}}my$use_feature;BEGIN {if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_feature=1}}sub _unix_rpt {my$unix_rpt;if ($use_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub _efs {my$efs;if ($use_feature){$efs=VMS::Feature::current("efs_charset")}else {my$env_efs=$ENV{'DECC$EFS_CHARSET'}|| '';$efs=$env_efs =~ /^[ET1]/i}return$efs}1;
MODULE_BUILD_PLATFORM_VMS

$fatpacked{"Module/Build/Platform/VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VOS';
  package Module::Build::Platform::VOS;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_VOS

$fatpacked{"Module/Build/Platform/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_WINDOWS';
  package Module::Build::Platform::Windows;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Config;use File::Basename;use File::Spec;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub manpage_separator {return '.'}sub have_forkpipe {0}sub _detildefy {my ($self,$value)=@_;$value =~ s,^~(?= [/\\] | $ ),$ENV{HOME},x if$ENV{HOME};return$value}sub ACTION_realclean {my ($self)=@_;$self->SUPER::ACTION_realclean();my$basename=basename($0);$basename =~ s/(?:\.bat)?$//i;if (lc$basename eq lc$self->build_script){if ($self->build_bat){$self->log_verbose("Deleting $basename.bat\n");my$full_progname=$0;$full_progname =~ s/(?:\.bat)?$/.bat/i;require Win32;my$null_arg=(Win32::IsWinNT())? '""' : '';my$cmd=qq(start $null_arg /min "\%comspec\%" /c del "$full_progname");open(my$fh,'>>',"$basename.bat")or die "Can't create $basename.bat: $!";print$fh $cmd;close$fh }else {$self->delete_filetree($self->build_script .'.bat')}}}sub make_executable {my$self=shift;$self->SUPER::make_executable(@_);for my$script (@_){if ($script =~ /\.(bat|cmd)$/){$self->SUPER::make_executable($script);next}else {my%opts=();if ($script eq $self->build_script){$opts{ntargs}=q(-x -S %0 --build_bat %*);$opts{otherargs}=q(-x -S "%0" --build_bat %1 %2 %3 %4 %5 %6 %7 %8 %9)}my$out=eval {$self->pl2bat(in=>$script,update=>1,%opts)};if ($@){$self->log_warn("WARNING: Unable to convert file '$script' to an executable script:\n$@")}else {$self->SUPER::make_executable($out)}}}}sub pl2bat {my$self=shift;my%opts=@_;$opts{ntargs}='-x -S %0 %*' unless exists$opts{ntargs};$opts{otherargs}='-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9' unless exists$opts{otherargs};$opts{stripsuffix}='/\\.plx?/' unless exists$opts{stripsuffix};$opts{stripsuffix}=($opts{stripsuffix}=~ m{^/([^/]*[^/\$]|)\$?/?$} ? $1 : "\Q$opts{stripsuffix}\E");unless (exists$opts{out}){$opts{out}=$opts{in};$opts{out}=~ s/$opts{stripsuffix}$//oi;$opts{out}.= '.bat' unless$opts{in}=~ /\.bat$/i or $opts{in}=~ /^-$/}my$head=<<EOT;$head =~ s/^\s+//gm;my$headlines=2 + ($head =~ tr/\n/\n/);my$tail="\n__END__\n:endofperl\n";my$linedone=0;my$taildone=0;my$linenum=0;my$skiplines=0;my$start=$Config{startperl};$start="#!perl" unless$start =~ /^#!.*perl/;open(my$in,'<',"$opts{in}")or die "Can't open $opts{in}: $!";my@file=<$in>;close($in);for my$line (@file){$linenum++;if ($line =~ /^:endofperl\b/){if (!exists$opts{update}){warn "$opts{in} has already been converted to a batch file!\n";return}$taildone++}if (not $linedone and $line =~ /^#!.*perl/){if (exists$opts{update}){$skiplines=$linenum - 1;$line .= "#line ".(1+$headlines)."\n"}else {$line .= "#line ".($linenum+$headlines)."\n"}$linedone++}if ($line =~ /^#\s*line\b/ and $linenum==2 + $skiplines){$line=""}}open(my$out,'>',"$opts{out}")or die "Can't open $opts{out}: $!";print$out $head;print$out $start,($opts{usewarnings}? " -w" : ""),"\n#line ",($headlines+1),"\n" unless$linedone;print$out @file[$skiplines..$#file];print$out $tail unless$taildone;close($out);return$opts{out}}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;|'"\[\]\{\}]+$/){push@quoted,$_}else {s/"/\\"/g;push@quoted,qq("$_")}}return join " ",@quoted}sub split_like_shell {(my$self,local $_)=@_;return @$_ if defined()&& ref()eq 'ARRAY';my@argv;return@argv unless defined()&& length();my$length=length;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub do_system {my ($self,@cmd)=@_;my$cmd=$self->_quote_args(@cmd);my$status=system($cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub _maybe_command {my($self,$file)=@_;my@e=exists($ENV{'PATHEXT'})? split(/;/,$ENV{PATHEXT}): qw(.com .exe .bat .cmd);my$e='';for (@e){$e .= "\Q$_\E|"}chop$e;if ($file =~ /($e)$/i){return$file if -e $file}else {for (@e){return "$file$_" if -e "$file$_"}}return}1;
      \@rem = '--*-Perl-*--
      \@echo off
      if "%OS%" == "Windows_NT" goto WinNT
      perl $opts{otherargs}
      goto endofperl
      :WinNT
      perl $opts{ntargs}
      if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
      if %errorlevel% == 9009 echo You do not have Perl in your PATH.
      if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
      goto endofperl
      \@rem ';
  EOT
MODULE_BUILD_PLATFORM_WINDOWS

$fatpacked{"Module/Build/Platform/aix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_AIX';
  package Module::Build::Platform::aix;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_AIX

$fatpacked{"Module/Build/Platform/cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_CYGWIN';
  package Module::Build::Platform::cygwin;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub _maybe_command {my ($self,$file)=@_;if ($file =~ m{^/cygdrive/}i){require Module::Build::Platform::Windows;return Module::Build::Platform::Windows->_maybe_command($file)}return$self->SUPER::_maybe_command($file)}1;
MODULE_BUILD_PLATFORM_CYGWIN

$fatpacked{"Module/Build/Platform/darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DARWIN';
  package Module::Build::Platform::darwin;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_DARWIN

$fatpacked{"Module/Build/Platform/os2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_OS2';
  package Module::Build::Platform::os2;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub have_forkpipe {0}sub _maybe_command {my($self,$file)=@_;$file =~ s,[/\\]+,/,g;return$file if -x $file &&!-d _;return "$file.exe" if -x "$file.exe" &&!-d _;return "$file.cmd" if -x "$file.cmd" &&!-d _;return}1;
MODULE_BUILD_PLATFORM_OS2

$fatpacked{"Module/Build/PodParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PODPARSER';
  package Module::Build::PodParser;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;sub new {my$package=shift;my$self;$self=bless {have_pod_parser=>0,@_},$package;unless ($self->{fh}){die "No 'file' or 'fh' parameter given" unless$self->{file};open($self->{fh},'<',$self->{file})or die "Couldn't open $self->{file}: $!"}return$self}sub parse_from_filehandle {my ($self,$fh)=@_;local $_;while (<$fh>){next unless /^=(?!cut)/ .. /^=cut/;last if ($self->{abstract})=/^ (?: [a-z_0-9:]+ | [BCIF] < [a-z_0-9:]+ > ) \s+ - \s+ (.*\S) /ix}my@author;while (<$fh>){next unless /^=head1\s+AUTHORS?/i ... /^=/;next if /^=/;push@author,$_ if /\@/}return unless@author;s/^\s+|\s+$//g foreach@author;$self->{author}=\@author;return}sub get_abstract {my$self=shift;return$self->{abstract}if defined$self->{abstract};$self->parse_from_filehandle($self->{fh});return$self->{abstract}}sub get_author {my$self=shift;return$self->{author}if defined$self->{author};$self->parse_from_filehandle($self->{fh});return$self->{author}|| []}
MODULE_BUILD_PODPARSER

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;$Module::Implementation::VERSION='0.09';use strict;use warnings;use Module::Runtime 0.012 qw(require_module);use Try::Tiny;unless (exists$Module::Implementation::{VERSION}&& ${$Module::Implementation::{VERSION}}){$Module::Implementation::{VERSION}=\42}my%Implementation;sub build_loader_sub {my$caller=caller();return _build_loader($caller,@_)}sub _build_loader {my$package=shift;my%args=@_;my@implementations=@{$args{implementations}};my@symbols=@{$args{symbols}|| []};my$implementation;my$env_var=uc$package;$env_var =~ s/::/_/g;$env_var .= '_IMPLEMENTATION';return sub {my ($implementation,$loaded)=_load_implementation($package,$ENV{$env_var},\@implementations,);$Implementation{$package}=$implementation;_copy_symbols($loaded,$package,\@symbols);return$loaded}}sub implementation_for {my$package=shift;return$Implementation{$package}}sub _load_implementation {my$package=shift;my$env_value=shift;my$implementations=shift;if ($env_value){die "$env_value is not a valid implementation for $package" unless grep {$_ eq $env_value}@{$implementations};my$requested="${package}::$env_value";($requested)=$requested =~ /^(.+)$/;try {require_module($requested)}catch {require Carp;Carp::croak("Could not load $requested: $_")};return ($env_value,$requested)}else {my$err;for my$possible (@{$implementations}){my$try="${package}::$possible";my$ok;try {require_module($try);$ok=1}catch {$err .= $_ if defined $_};return ($possible,$try)if$ok}require Carp;if (defined$err && length$err){Carp::croak("Could not find a suitable $package implementation: $err")}else {Carp::croak('Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken')}}}sub _copy_symbols {my$from_package=shift;my$to_package=shift;my$symbols=shift;for my$sym (@{$symbols}){my$type=$sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';my$from="${from_package}::$sym";my$to="${to_package}::$sym";{no strict 'refs';no warnings 'once';*{$to}=$type eq '&' ? \&{$from}: $type eq '$' ? \${$from}: $type eq '@' ? \@{$from}: $type eq '%' ? \%{$from}: $type eq '*' ? *{$from}: die "Can't copy symbol from $from_package to $to_package: $type$sym"}}}1;
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  package Module::Runtime;BEGIN {require 5.006}BEGIN {${^WARNING_BITS}=""}our$VERSION="0.016";our@EXPORT_OK=qw($module_name_rx is_module_name is_valid_module_name check_module_name module_notional_filename require_module use_module use_package_optimistically $top_module_spec_rx $sub_module_spec_rx is_module_spec is_valid_module_spec check_module_spec compose_module_name);my%export_ok=map {($_=>undef)}@EXPORT_OK;sub import {my$me=shift;my$callpkg=caller(0);my$errs="";for(@_){if(exists$export_ok{$_}){if(/\A\$(.*)\z/s){*{$callpkg."::".$1}=\$$1}else {*{$callpkg."::".$_}=\&$_}}else {$errs .= "\"$_\" is not exported by the $me module\n"}}if($errs ne ""){die "${errs}Can't continue after import errors "."at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n"}}sub _is_string($) {my($arg)=@_;return defined($arg)&& ref(\$arg)eq "SCALAR"}our$module_name_rx=qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;my$qual_module_spec_rx=qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;my$unqual_top_module_spec_rx=qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$top_module_spec_rx=qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;my$unqual_sub_module_spec_rx=qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$sub_module_spec_rx=qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;sub is_module_name($) {_is_string($_[0])&& $_[0]=~ /\A$module_name_rx\z/o}*is_valid_module_name=\&is_module_name;sub check_module_name($) {unless(&is_module_name){die +(_is_string($_[0])? "`$_[0]'" : "argument")." is not a module name\n"}}sub module_notional_filename($) {&check_module_name;my($name)=@_;$name =~ s!::!/!g;return$name.".pm"}BEGIN {*_WORK_AROUND_HINT_LEAKAGE="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0}}BEGIN {if(_WORK_AROUND_BROKEN_MODULE_STATE){eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  };die $@ if $@ ne ""}}sub require_module($) {local %^H if _WORK_AROUND_HINT_LEAKAGE;if(_WORK_AROUND_BROKEN_MODULE_STATE){my$notional_filename=&module_notional_filename;my$guard=bless([$notional_filename ],"Module::Runtime::__GUARD__");my$result=CORE::require($notional_filename);pop @$guard;return$result}else {return scalar(CORE::require(&module_notional_filename))}}sub use_module($;$) {my($name,$version)=@_;require_module($name);$name->VERSION($version)if @_ >= 2;return$name}sub use_package_optimistically($;$) {my($name,$version)=@_;my$fn=module_notional_filename($name);eval {local$SIG{__DIE__};require_module($name)};die $@ if $@ ne "" && ($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s || $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);$name->VERSION($version)if @_ >= 2;return$name}sub is_module_spec($$) {my($prefix,$spec)=@_;return _is_string($spec)&& $spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o : qr/\A$top_module_spec_rx\z/o)}*is_valid_module_spec=\&is_module_spec;sub check_module_spec($$) {unless(&is_module_spec){die +(_is_string($_[1])? "`$_[1]'" : "argument")." is not a module specification\n"}}sub compose_module_name($$) {my($prefix,$spec)=@_;check_module_name($prefix)if defined$prefix;&check_module_spec;if($spec =~ s#\A(?:/|::)##){}else {$spec=$prefix."::".$spec if defined$prefix}$spec =~ s#/#::#g;return$spec}1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;use Moo::_strictures;use Moo::_mro;use Moo::_Utils qw(_check_tracked _getglob _getstash _install_coderef _install_modifier _install_tracked _load_module _set_loaded _unimport_coderefs);use Scalar::Util qw(reftype);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Method::Generate::Constructor Method::Generate::Accessor Moo::sification Moo::_Utils Moo::Role)}our$VERSION='2.003006';$VERSION =~ tr/_//d;require Moo::sification;Moo::sification->import;our%MAKERS;sub import {my$target=caller;my$class=shift;_set_loaded(caller);strict->import;warnings->import;if ($INC{'Role/Tiny.pm'}and Role::Tiny->is_role($target)){croak "Cannot import Moo into a role"}$MAKERS{$target}||= {};_install_tracked$target=>extends=>sub {$class->_set_superclasses($target,@_);$class->_maybe_reset_handlemoose($target);return};_install_tracked$target=>with=>sub {require Moo::Role;Moo::Role->apply_roles_to_package($target,@_);$class->_maybe_reset_handlemoose($target)};_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){croak "Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$class->_constructor_maker_for($target)->register_attribute_specs($name,$spec_ref);$class->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);$class->_maybe_reset_handlemoose($target)}return};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {_install_modifier($target,$type,@_);return}}return if$MAKERS{$target}{is_class};my$stash=_getstash($target);$MAKERS{$target}{non_methods}={map +($_=>\&{"${target}::${_}"}),grep exists &{"${target}::${_}"},grep!/::\z/ &&!/\A\(/,keys %$stash };$MAKERS{$target}{is_class}=1;{no strict 'refs';@{"${target}::ISA"}=do {require Moo::Object;('Moo::Object')}unless @{"${target}::ISA"}}if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub unimport {my$target=caller;_unimport_coderefs($target)}sub _set_superclasses {my$class=shift;my$target=shift;for my$superclass (@_){_load_module($superclass);if ($INC{'Role/Tiny.pm'}&& Role::Tiny->is_role($superclass)){croak "Can't extend role '$superclass'"}}@{*{_getglob("${target}::ISA")}{ARRAY}}=@_;if (my$old=delete$Moo::MAKERS{$target}{constructor}){$old->assert_constructor;delete _getstash($target)->{new};Moo->_constructor_maker_for($target)->register_attribute_specs(%{$old->all_attribute_specs})}elsif (!$target->isa('Moo::Object')){Moo->_constructor_maker_for($target)}$Moo::HandleMoose::MOUSE{$target}=[grep defined,map Mouse::Util::find_meta($_),@_ ]if Mouse::Util->can('find_meta')}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _accessor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{accessor}||= do {my$maker_class=do {if (my$m=do {require Sub::Defer;if (my$defer_target=(Sub::Defer::defer_info($target->can('new'))||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);$MAKERS{$pkg}&& $MAKERS{$pkg}{accessor}}else {undef}}){ref($m)}else {require Method::Generate::Accessor;'Method::Generate::Accessor'}};$maker_class->new}}sub _constructor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{constructor}||= do {require Method::Generate::Constructor;my%construct_opts=(package=>$target,accessor_generator=>$class->_accessor_maker_for($target),subconstructor_handler=>('      if ($Moo::MAKERS{$class}) {'."\n" .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n" .'          package '.$target.';'."\n" .'          return $invoker->SUPER::new(@_);'."\n" .'        }'."\n" .'        '.$class.'->_constructor_maker_for($class);'."\n" .'        return $invoker->new(@_)'.";\n" .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n" .'        return $meta->new_object('."\n" .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n" .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n" .'        );'."\n" .'      }'."\n"),);my$con;my@isa=@{mro::get_linear_isa($target)};shift@isa;no strict 'refs';if (my ($parent_new)=grep +(defined &{$_.'::new'}),@isa){if ($parent_new eq 'Moo::Object'){}elsif (my$makers=$MAKERS{$parent_new}){$con=$makers->{constructor};$construct_opts{construction_string}=$con->construction_string if$con}elsif ($parent_new->can('BUILDALL')){$construct_opts{construction_builder}=sub {my$inv=$target->can('BUILDARGS')? '' : 'Moo::Object::';'do {' .'  my $args = $class->'.$inv.'BUILDARGS(@_);' .'  $args->{__no_BUILD__} = 1;' .'  $invoker->'.$target.'::SUPER::new($args);' .'}'}}else {$construct_opts{construction_builder}=sub {'$invoker->'.$target.'::SUPER::new(' .($target->can('FOREIGNBUILDARGS')? '$class->FOREIGNBUILDARGS(@_)' : '@_').')'}}}($con ? ref($con): 'Method::Generate::Constructor')->new(%construct_opts)->install_delayed ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})}}sub _concrete_methods_of {my ($me,$class)=@_;my$makers=$MAKERS{$class};my$non_methods=$makers->{non_methods}|| {};my$stash=_getstash($class);my$subs={map {;no strict 'refs';${"${class}::${_}"}=${"${class}::${_}"};($_=>\&{"${class}::${_}"})}grep exists &{"${class}::${_}"},grep!/::\z/,keys %$stash };my%tracked=map +($_=>1),_check_tracked($class,[keys %$subs ]);return {map +($_=>\&{"${class}::${_}"}),grep!($non_methods->{$_}&& $non_methods->{$_}==$subs->{$_}),grep!exists$tracked{$_},keys %$subs }}1;
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;use Moo::_strictures;use Moo::_Utils qw(_getstash);use Sub::Quote qw(quotify);use Carp qw(croak);our%TYPE_MAP;our$SETUP_DONE;sub import {return if$SETUP_DONE;inject_all();$SETUP_DONE=1}sub inject_all {croak "Can't inflate Moose metaclass with Moo::sification disabled" if$Moo::sification::disabled;require Class::MOP;inject_fake_metaclass_for($_)for grep $_ ne 'Moo::Object',keys%Moo::MAKERS;inject_fake_metaclass_for($_)for keys%Moo::Role::INFO;require Moose::Meta::Method::Constructor;@Moo::HandleMoose::FakeConstructor::ISA='Moose::Meta::Method::Constructor';@Moo::HandleMoose::FakeMeta::ISA='Moose::Meta::Method::Meta'}sub maybe_reinject_fake_metaclass_for {my ($name)=@_;our%DID_INJECT;if (delete$DID_INJECT{$name}){unless ($Moo::Role::INFO{$name}){Moo->_constructor_maker_for($name)->install_delayed}inject_fake_metaclass_for($name)}}sub inject_fake_metaclass_for {my ($name)=@_;require Class::MOP;require Moo::HandleMoose::FakeMetaClass;Class::MOP::store_metaclass_by_name($name,bless({name=>$name },'Moo::HandleMoose::FakeMetaClass'));require Moose::Util::TypeConstraints;if ($Moo::Role::INFO{$name}){Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name)}else {Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name)}}{package Moo::HandleMoose::FakeConstructor;sub _uninlined_body {\&Moose::Object::new}}sub inject_real_metaclass_for {my ($name)=@_;our%DID_INJECT;return Class::MOP::get_metaclass_by_name($name)if$DID_INJECT{$name};require Moose;require Moo;require Moo::Role;require Scalar::Util;require Sub::Defer;Class::MOP::remove_metaclass_by_name($name);my ($am_role,$am_class,$meta,$attr_specs,$attr_order)=do {if (my$info=$Moo::Role::INFO{$name}){my@attr_info=@{$info->{attributes}||[]};(1,0,Moose::Meta::Role->initialize($name),{@attr_info },[@attr_info[grep!($_ % 2),0..$#attr_info]])}elsif (my$cmaker=Moo->_constructor_maker_for($name)){my$specs=$cmaker->all_attribute_specs;(0,1,Moose::Meta::Class->initialize($name),$specs,[sort {$specs->{$a}{index}<=> $specs->{$b}{index}}keys %$specs ])}else {(0,0,Moose::Meta::Class->initialize($name),{},[])}};{local$DID_INJECT{$name}=1;for my$spec (values %$attr_specs){if (my$inflators=delete$spec->{moosify}){$_->($spec)for @$inflators}}my%methods =%{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};if (my$info=$Moo::Role::INFO{$name}){delete$info->{methods}}$methods{$_}=Sub::Defer::undefer_sub($methods{$_})for grep $_ ne 'new',keys%methods;my@attrs;{local @{_getstash($name)}{keys%methods};my%seen_name;for my$attr_name (@$attr_order){$seen_name{$attr_name}=1;my%spec=%{$attr_specs->{$attr_name}};my%spec_map=(map {$_->name=>$_->init_arg||$_->name}((grep {$_->has_init_arg}$meta->attribute_metaclass->meta->get_all_attributes),grep {exists($_->{init_arg})? defined($_->init_arg): 1}map {my$meta=Moose::Util::resolve_metatrait_alias('Attribute',$_)->meta;map$meta->get_attribute($_),$meta->get_attribute_list}@{$spec{traits}||[]}));$spec_map{traits}||= 'traits';$spec{is}='ro' if$spec{is}eq 'lazy' or $spec{is}eq 'rwp';my$coerce=$spec{coerce};if (my$isa=$spec{isa}){my$tc=$spec{isa}=do {if (my$mapped=$TYPE_MAP{$isa}){my$type=$mapped->();unless (Scalar::Util::blessed($type)&& $type->isa("Moose::Meta::TypeConstraint")){croak "error inflating attribute '$attr_name' for package '$name': " ."\$TYPE_MAP{$isa} did not return a valid type constraint'"}$coerce ? $type->create_child_type(name=>$type->name): $type}else {Moose::Meta::TypeConstraint->new(constraint=>sub {eval {&$isa;1}})}};if ($coerce){$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{coerce}=1}}elsif ($coerce){my$attr=quotify($attr_name);my$tc=Moose::Meta::TypeConstraint->new(constraint=>sub {die "This is not going to work"},inlined=>sub {'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'},);$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{isa}=$tc;$spec{coerce}=1}%spec=map {$spec_map{$_}=>$spec{$_}}grep {exists$spec_map{$_}}keys%spec;push@attrs,$meta->add_attribute($attr_name=>%spec)}for my$mouse (do {our%MOUSE;@{$MOUSE{$name}||[]}}){for my$attr ($mouse->get_all_attributes){my%spec=%{$attr};delete@spec{qw(associated_class associated_methods __METACLASS__ provides curries)};my$attr_name=delete$spec{name};next if$seen_name{$attr_name}++;push@attrs,$meta->add_attribute($attr_name=>%spec)}}}for my$meth_name (keys%methods){my$meth_code=$methods{$meth_name};$meta->add_method($meth_name,$meth_code)}if ($am_role){my$info=$Moo::Role::INFO{$name};$meta->add_required_methods(@{$info->{requires}});for my$modifier (@{$info->{modifiers}}){my ($type,@args)=@$modifier;my$code=pop@args;$meta->${\"add_${type}_method_modifier"}($_,$code)for@args}}elsif ($am_class){for my$attr (@attrs){for my$method (@{$attr->associated_methods}){$method->{body}=$name->can($method->name)}}bless($meta->find_method_by_name('new'),'Moo::HandleMoose::FakeConstructor',);my$meta_meth;if ($meta_meth=$meta->find_method_by_name('meta')and $meta_meth->body==\&Moo::Object::meta){bless($meta_meth,'Moo::HandleMoose::FakeMeta')}require Method::Generate::DemolishAll}$meta->add_role(Class::MOP::class_of($_))for grep!/\|/ && $_ ne $name,keys %{$Moo::Role::APPLIED_TO{$name}}}$DID_INJECT{$name}=1;$meta}1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;use Moo::_strictures;use Carp ();BEGIN {our@CARP_NOT=qw(Moo::HandleMoose)}sub DESTROY {}sub AUTOLOAD {my ($meth)=(our$AUTOLOAD =~ /([^:]+)$/);my$self=shift;Carp::croak "Can't call $meth without object instance" if!ref$self;Carp::croak "Can't inflate Moose metaclass with Moo::sification disabled" if$Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)}sub can {my$self=shift;return$self->SUPER::can(@_)if!ref$self or $Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)}sub isa {my$self=shift;return$self->SUPER::isa(@_)if!ref$self or $Moo::sification::disabled;return!!0 if @_==1 && $_[0]eq 'Exception::Class::Base';require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)}sub make_immutable {$_[0]}1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;use Moo::_strictures;package Moo::HandleMoose;our%TYPE_MAP;package Moo::HandleMoose::_TypeMap;use Scalar::Util ();use Config;our%WEAK_TYPES;sub _str_to_ref {my$in=shift;return$in if ref$in;if ($in =~ /(?:^|=)([A-Z]+)\(0x([0-9a-zA-Z]+)\)$/){my$type=$1;my$id=do {no warnings 'portable';hex "$2"};require B;my$sv=bless \$id,'B::SV';my$ref=eval {$sv->object_2svref};if (!defined$ref or Scalar::Util::reftype($ref)ne $type){die <<'END_ERROR'}return$ref}return$in}sub TIEHASH {bless {},$_[0]}sub STORE {my ($self,$key,$value)=@_;my$type=_str_to_ref($key);$WEAK_TYPES{$type}=$type;Scalar::Util::weaken($WEAK_TYPES{$type})if ref$type;$self->{$key}=$value}sub FETCH {$_[0]->{$_[1]}}sub FIRSTKEY {my$a=scalar keys %{$_[0]};each %{$_[0]}}sub NEXTKEY {each %{$_[0]}}sub EXISTS {exists $_[0]->{$_[1]}}sub DELETE {delete $_[0]->{$_[1]}}sub CLEAR {%{$_[0]}=()}sub SCALAR {scalar %{$_[0]}}sub CLONE {my@types=map {defined$WEAK_TYPES{$_}? ($WEAK_TYPES{$_}=>$TYPE_MAP{$_}): ()}keys%TYPE_MAP;%WEAK_TYPES=();%TYPE_MAP=@types}sub DESTROY {my%types=%{$_[0]};untie%TYPE_MAP;%TYPE_MAP=%types}if ($Config{useithreads}){my@types=%TYPE_MAP;tie%TYPE_MAP,__PACKAGE__;%TYPE_MAP=@types}1;
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;use Moo::_strictures;use Carp ();our%NO_BUILD;our%NO_DEMOLISH;our$BUILD_MAKER;our$DEMOLISH_MAKER;sub new {my$class=shift;unless (exists$NO_DEMOLISH{$class}){unless ($NO_DEMOLISH{$class}=!$class->can('DEMOLISH')){($DEMOLISH_MAKER ||= do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method($class)}}my$proto=$class->BUILDARGS(@_);$NO_BUILD{$class}and return bless({},$class);$NO_BUILD{$class}=!$class->can('BUILD')unless exists$NO_BUILD{$class};$NO_BUILD{$class}? bless({},$class): bless({},$class)->BUILDALL($proto)}sub BUILDARGS {my$class=shift;scalar @_==1 ? ref $_[0]eq 'HASH' ? {%{$_[0]}}: Carp::croak("Single parameters to new() must be a HASH ref" ." data => ".$_[0]): @_ % 2 ? Carp::croak("The new() method for $class expects a hash reference or a" ." key/value list. You passed an odd number of arguments"): {@_}}sub BUILDALL {my$self=shift;$self->${\(($BUILD_MAKER ||= do {require Method::Generate::BuildAll;Method::Generate::BuildAll->new})->generate_method(ref($self)))}(@_)}sub DEMOLISHALL {my$self=shift;$self->${\(($DEMOLISH_MAKER ||= do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method(ref($self)))}(@_)}sub does {return!!0 unless ($INC{'Moose/Role.pm'}|| $INC{'Role/Tiny.pm'});require Moo::Role;my$does=Moo::Role->can("does_role");{no warnings 'redefine';*does=$does}goto &$does}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;use Moo::_strictures;use Moo::_Utils qw(_check_tracked _getglob _getstash _install_coderef _install_modifier _install_tracked _load_module _name_coderef _set_loaded _unimport_coderefs);use Carp qw(croak);use Role::Tiny ();BEGIN {our@ISA=qw(Role::Tiny)}BEGIN {our@CARP_NOT=qw(Method::Generate::Accessor Method::Generate::Constructor Moo::sification Moo::_Utils)}our$VERSION='2.003006';$VERSION =~ tr/_//d;require Moo::sification;Moo::sification->import;BEGIN {*INFO=\%Role::Tiny::INFO;*APPLIED_TO=\%Role::Tiny::APPLIED_TO;*COMPOSED=\%Role::Tiny::COMPOSED;*ON_ROLE_CREATE=\@Role::Tiny::ON_ROLE_CREATE}our%INFO;our%APPLIED_TO;our%APPLY_DEFAULTS;our%COMPOSED;our@ON_ROLE_CREATE;sub import {my$target=caller;if ($Moo::MAKERS{$target}and $Moo::MAKERS{$target}{is_class}){croak "Cannot import Moo::Role into a Moo class"}_set_loaded(caller);goto&Role::Tiny::import}sub _accessor_maker_for {my ($class,$target)=@_;($INFO{$target}{accessor_maker}||= do {require Method::Generate::Accessor;Method::Generate::Accessor->new})}sub _install_subs {my ($me,$target)=@_;_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$me->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);push @{$INFO{$target}{attributes}||=[]},$name,$spec_ref;$me->_maybe_reset_handlemoose($target)}};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];$me->_maybe_reset_handlemoose($target)}}_install_tracked$target=>requires=>sub {push @{$INFO{$target}{requires}||=[]},@_;$me->_maybe_reset_handlemoose($target)};_install_tracked$target=>with=>sub {$me->apply_roles_to_package($target,@_);$me->_maybe_reset_handlemoose($target)};*{_getglob("${target}::meta")}=$me->can('meta')}push@ON_ROLE_CREATE,sub {my$target=shift;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($target)}};sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}sub unimport {my$target=caller;_unimport_coderefs($target)}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _non_methods {my$self=shift;my ($role)=@_;my$non_methods=$self->SUPER::_non_methods(@_);my$all_subs=$self->_all_subs($role);$non_methods->{$_}=$all_subs->{$_}for _check_tracked($role,[keys %$all_subs ]);return$non_methods}sub methods_provided_by {my ($self,$role)=@_;_load_module($role);$self->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$self->is_role($role);return$self->SUPER::methods_provided_by($role)}sub is_role {my ($self,$role)=@_;$self->_inhale_if_moose($role);$self->SUPER::is_role($role)}sub _inhale_if_moose {my ($self,$role)=@_;my$meta;if (!$self->SUPER::is_role($role)and ($INC{"Moose.pm"}and $meta=Class::MOP::class_of($role)and ref$meta ne 'Moo::HandleMoose::FakeMetaClass' and $meta->isa('Moose::Meta::Role'))or (Mouse::Util->can('find_meta')and $meta=Mouse::Util::find_meta($role)and $meta->isa('Mouse::Meta::Role'))){my$is_mouse=$meta->isa('Mouse::Meta::Role');$INFO{$role}{methods}={map +($_=>$role->can($_)),grep$role->can($_),grep!($is_mouse && $_ eq 'meta'),grep!$meta->get_method($_)->isa('Class::MOP::Method::Meta'),$meta->get_method_list };$APPLIED_TO{$role}={map +($_->name=>1),$meta->calculate_all_roles };$INFO{$role}{requires}=[$meta->get_required_method_list ];$INFO{$role}{attributes}=[map +($_=>do {my$attr=$meta->get_attribute($_);my$spec={%{$is_mouse ? $attr : $attr->original_options}};if ($spec->{isa}){require Sub::Quote;my$get_constraint=do {my$pkg=$is_mouse ? 'Mouse::Util::TypeConstraints' : 'Moose::Util::TypeConstraints';_load_module($pkg);$pkg->can('find_or_create_isa_type_constraint')};my$tc=$get_constraint->($spec->{isa});my$check=$tc->_compiled_type_constraint;my$tc_var='$_check_for_'.Sub::Quote::sanitize_identifier($tc->name);$spec->{isa}=Sub::Quote::quote_sub(qq{
                &${tc_var} or Carp::croak "Type constraint failed for \$_[0]"
              },{$tc_var=>\$check },{package=>$role,},);if ($spec->{coerce}){$spec->{coerce}=$tc->${\($tc->can('coercion')||sub {$_[0]})}->_compiled_type_coercion}}$spec}),$meta->get_attribute_list ];my$mods=$INFO{$role}{modifiers}=[];for my$type (qw(before after around)){my$map=$meta->${\($meta->can("get_${type}_method_modifiers_map")or sub {shift->{"${type}_method_modifiers"}})};for my$method (keys %$map){for my$mod (@{$map->{$method}}){push @$mods,[$type=>$method=>$mod ]}}}$INFO{$role}{inhaled_from_moose}=1;$INFO{$role}{is_role}=1}}sub _maybe_make_accessors {my ($self,$target,$role)=@_;my$m;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}or $INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($target)and ref($m)ne 'Method::Generate::Accessor'){$self->_make_accessors($target,$role)}}sub _make_accessors_if_moose {my ($self,$target,$role)=@_;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}){$self->_make_accessors($target,$role)}}sub _make_accessors {my ($self,$target,$role)=@_;my$acc_gen=($Moo::MAKERS{$target}{accessor}||= do {require Method::Generate::Accessor;Method::Generate::Accessor->new});my$con_gen=$Moo::MAKERS{$target}{constructor};my@attrs=@{$INFO{$role}{attributes}||[]};while (my ($name,$spec)=splice@attrs,0,2){if ($con_gen){$spec=$con_gen->all_attribute_specs->{$name}}$acc_gen->generate_method($target,$name,$spec)}}sub _undefer_subs {my ($self,$target,$role)=@_;if ($INC{'Sub/Defer.pm'}){Sub::Defer::undefer_package($role)}}sub role_application_steps {qw(_handle_constructor _undefer_subs _maybe_make_accessors),$_[0]->SUPER::role_application_steps}sub apply_roles_to_package {my ($me,$to,@roles)=@_;for my$role (@roles){_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role)}$me->SUPER::apply_roles_to_package($to,@roles)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role);$me->SUPER::apply_single_role_to_package($to,$role)}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role)}my$m;if ($INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($superclass)and ref($m)ne 'Method::Generate::Accessor'){@{*{_getglob("${new_name}::ISA")}{ARRAY}}=($superclass);$Moo::MAKERS{$new_name}={is_class=>1};$me->apply_roles_to_package($new_name,@roles)}else {$me->SUPER::create_class_with_roles($superclass,@roles);$Moo::MAKERS{$new_name}={is_class=>1};$me->_handle_constructor($new_name,$_)for@roles}if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($new_name)}$COMPOSED{class}{$new_name}=1;_set_loaded($new_name,(caller)[1]);return$new_name}sub apply_roles_to_object {my ($me,$object,@roles)=@_;my$new=$me->SUPER::apply_roles_to_object($object,@roles);my$class=ref$new;_set_loaded($class,(caller)[1]);my$apply_defaults=exists$APPLY_DEFAULTS{$class}? $APPLY_DEFAULTS{$class}: $APPLY_DEFAULTS{$class}=do {my%attrs=map {@{$INFO{$_}{attributes}||[]}}@roles;if ($INC{'Moo.pm'}and keys%attrs and my$con_gen=Moo->_constructor_maker_for($class)and my$m=Moo->_accessor_maker_for($class)){my$specs=$con_gen->all_attribute_specs;my%captures;my$code=join('',(map {my$name=$_;my$spec=$specs->{$name};if ($m->has_eager_default($name,$spec)){my ($has,$has_cap)=$m->generate_simple_has('$_[0]',$name,$spec);my ($set,$pop_cap)=$m->generate_use_default('$_[0]',$name,$spec,$has);@captures{keys %$has_cap,keys %$pop_cap}=(values %$has_cap,values %$pop_cap);"($set),"}else {()}}sort keys%attrs),);if ($code){require Sub::Quote;Sub::Quote::quote_sub("${class}::_apply_defaults","no warnings 'void';\n$code",\%captures,{package=>$class,no_install=>1,})}else {0}}else {0}};if ($apply_defaults){local$Carp::Internal{+__PACKAGE__}=1;local$Carp::Internal{$class}=1;$new->$apply_defaults}return$new}sub _composable_package_for {my ($self,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$COMPOSED{role}{$composed_name};$self->_make_accessors_if_moose($composed_name,$role);$self->SUPER::_composable_package_for($role)}sub _install_single_modifier {my ($me,@args)=@_;_install_modifier(@args)}sub _install_does {my ($me,$to)=@_;my$new=$me->SUPER::_install_does($to)or return;return _name_coderef("${to}::DOES",$new)}sub does_role {my ($proto,$role)=@_;return 1 if Role::Tiny::does_role($proto,$role);my$meta;if ($INC{'Moose.pm'}and $meta=Class::MOP::class_of($proto)and ref$meta ne 'Moo::HandleMoose::FakeMetaClass' and $meta->can('does_role')){return$meta->does_role($role)}return 0}sub _handle_constructor {my ($me,$to,$role)=@_;my$attr_info=$INFO{$role}&& $INFO{$role}{attributes};return unless$attr_info && @$attr_info;my$info=$INFO{$to};my$con=$INC{"Moo.pm"}&& Moo->_constructor_maker_for($to);my%existing =$info ? @{$info->{attributes}|| []}: $con ? %{$con->all_attribute_specs || {}}: ();my@attr_info=map {@{$attr_info}[$_,$_+1]}grep {!$existing{$attr_info->[$_]}}map {2 * $_}0..@$attr_info/2-1;if ($info){push @{$info->{attributes}||=[]},@attr_info}elsif ($con){$con->register_attribute_specs(map ref()? {%$_ }: $_,@attr_info)}}1;
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;use Moo::_strictures;{no strict 'refs';sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}}BEGIN {my ($su,$sn);$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname or $sn=$INC{'Sub/Name.pm'}or $su=eval {require Sub::Util}&& defined&Sub::Util::set_subname or $sn=eval {require Sub::Name};*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_CAN_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}use Module::Runtime qw(use_package_optimistically module_notional_filename);use Exporter qw(import);use Config;use Scalar::Util qw(weaken);use Carp qw(croak);our@EXPORT=qw(_install_coderef _load_module);our@EXPORT_OK=qw(_check_tracked _getglob _getstash _install_coderef _install_modifier _install_tracked _load_module _maybe_load_module _name_coderef _set_loaded _unimport_coderefs);my%EXPORTS;sub _install_modifier {my$target=$_[0];my$type=$_[1];my$code=$_[-1];my@names=@_[2 .. $#_ - 1];@names=@{$names[0]}if ref($names[0])eq 'ARRAY';my@tracked=_check_tracked($target,\@names);if ($INC{'Sub/Defer.pm'}){for my$name (@names){if (my$to_modify=$target->can($name)){Sub::Defer::undefer_sub($to_modify)}}}require Class::Method::Modifiers;Class::Method::Modifiers::install_modifier(@_);if (@tracked){my$exports=$EXPORTS{$target};weaken($exports->{$_}=$target->can($_))for@tracked}return}sub _install_tracked {my ($target,$name,$code)=@_;my$from=caller;weaken($EXPORTS{$target}{$name}=$code);_install_coderef("${target}::${name}","${from}::${name}",$code)}sub _load_module {my$module=$_[0];my$file=eval {module_notional_filename($module)}or croak $@;use_package_optimistically($module);return 1 if$INC{$file};my$error=$@ || "Can't locate $file";my$stash=_getstash($module)||{};return 1 if grep +(ref($_)|| *$_{CODE}),values %$stash;return 1 if$INC{"Moose.pm"}&& Class::MOP::class_of($module)or Mouse::Util->can('find_meta')&& Mouse::Util::find_meta($module);croak$error}our%MAYBE_LOADED;sub _maybe_load_module {my$module=$_[0];return$MAYBE_LOADED{$module}if exists$MAYBE_LOADED{$module};if(!eval {use_package_optimistically($module)}){warn "$module exists but failed to load with error: $@"}elsif ($INC{module_notional_filename($module)}){return$MAYBE_LOADED{$module}=1}return$MAYBE_LOADED{$module}=0}sub _set_loaded {$INC{Module::Runtime::module_notional_filename($_[0])}||= $_[1]}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}sub _name_coderef {shift if @_ > 2;_CAN_SUBNAME ? _subname(@_): $_[1]}sub _check_tracked {my ($target,$names)=@_;my$stash=_getstash($target);my$exports=$EXPORTS{$target}or return;$names=[keys %$exports]if!$names;my%rev=map +($exports->{$_}=>$_),grep defined$exports->{$_},keys %$exports;return grep {my$g=$stash->{$_};$g && defined &$g && exists$rev{\&$g}}@$names}sub _unimport_coderefs {my ($target)=@_;my$stash=_getstash($target);my@exports=_check_tracked($target);for my$name (@exports){my$old=delete$stash->{$name};my$full_name=join('::',$target,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});no strict 'refs';*$full_name=*{$old}{$type}}}}if ($Config{useithreads}){require Moo::HandleMoose::_TypeMap}1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;use Moo::_strictures;if ("$]" >= 5.010_000){require mro}else {require MRO::Compat}1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;use strict;use warnings;sub import {if ($ENV{MOO_FATAL_WARNINGS}){require strictures;strictures->VERSION(2);@_=('strictures');goto&strictures::import}else {strict->import;warnings->import;warnings->unimport('once')}}1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;use Moo::_strictures;no warnings 'once';BEGIN {*_USE_DGD="$]" < 5.014 ? sub(){1}: sub(){0};require Devel::GlobalDestruction if _USE_DGD()}use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Moo::HandleMoose)}sub unimport {croak "Can't disable Moo::sification after inflation has been done" if$Moo::HandleMoose::SETUP_DONE;our$disabled=1}sub Moo::HandleMoose::AuthorityHack::DESTROY {unless (our$disabled or _USE_DGD ? Devel::GlobalDestruction::in_global_destruction(): ${^GLOBAL_PHASE} eq 'DESTRUCT'){require Moo::HandleMoose;Moo::HandleMoose->import}}sub import {return if our$setup_done;if ($INC{"Moose.pm"}){require Moo::HandleMoose;Moo::HandleMoose->import}else {$Moose::AUTHORITY=bless({},'Moo::HandleMoose::AuthorityHack')}$setup_done=1}1;
MOO_SIFICATION

$fatpacked{"Package/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH';
  package Package::Stash;use strict;use warnings;use 5.008001;our$VERSION='0.38';our$IMPLEMENTATION;use Module::Implementation 0.06;BEGIN {local$ENV{PACKAGE_STASH_IMPLEMENTATION}=$IMPLEMENTATION if ($IMPLEMENTATION and not $ENV{PACKAGE_STASH_IMPLEMENTATION});Module::Implementation::build_loader_sub(implementations=>['XS','PP' ],symbols=>[qw(new name namespace add_symbol remove_glob has_symbol get_symbol get_or_add_symbol remove_symbol list_all_symbols get_all_symbols)],)->();$IMPLEMENTATION=Module::Implementation::implementation_for(__PACKAGE__)}1;
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_CONFLICTS';
  package Package::Stash::Conflicts;use strict;use warnings;use Dist::CheckConflicts -dist=>'Package::Stash',-conflicts=>{'Class::MOP'=>'1.08','MooseX::Method::Signatures'=>'0.36','MooseX::Role::WithOverloading'=>'0.08','namespace::clean'=>'0.18',},-also=>[qw(B Carp Dist::CheckConflicts Getopt::Long Module::Implementation Scalar::Util Symbol constant strict warnings) ],;1;
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_PP';
  package Package::Stash::PP;use strict;use warnings;our$VERSION='0.38';use B;use Carp qw(confess);use Scalar::Util qw(blessed reftype weaken);use Symbol;use constant BROKEN_ISA_ASSIGNMENT=>($] < 5.012);use constant BROKEN_WEAK_STASH=>($] < 5.010);use constant BROKEN_SCALAR_INITIALIZATION=>($] < 5.010);use constant BROKEN_GLOB_ASSIGNMENT=>($] < 5.013004);use constant HAS_ISA_CACHE=>($] < 5.010);sub new {my$class=shift;my ($package)=@_;if (!defined($package)|| (ref($package)&& reftype($package)ne 'HASH')){confess "Package::Stash->new must be passed the name of the " ."package to access"}elsif (ref($package)&& reftype($package)eq 'HASH'){confess "The PP implementation of Package::Stash does not support " ."anonymous stashes before perl 5.14" if BROKEN_GLOB_ASSIGNMENT;return bless {'namespace'=>$package,},$class}elsif ($package =~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/){return bless {'package'=>$package,},$class}else {confess "$package is not a module name"}}sub name {confess "Can't call name as a class method" unless blessed($_[0]);confess "Can't get the name of an anonymous package" unless defined($_[0]->{package});return $_[0]->{package}}sub namespace {confess "Can't call namespace as a class method" unless blessed($_[0]);if (BROKEN_WEAK_STASH){no strict 'refs';return \%{$_[0]->name .'::'}}else {return $_[0]->{namespace}if defined $_[0]->{namespace};{no strict 'refs';$_[0]->{namespace}=\%{$_[0]->name .'::'}}weaken($_[0]->{namespace});return $_[0]->{namespace}}}{my%SIGIL_MAP=('$'=>'SCALAR','@'=>'ARRAY','%'=>'HASH','&'=>'CODE',''=>'IO',);sub _deconstruct_variable_name {my ($variable)=@_;my@ret;if (ref($variable)eq 'HASH'){@ret=@{$variable}{qw[name sigil type]}}else {(defined$variable && length$variable)|| confess "You must pass a variable name";my$sigil=substr($variable,0,1,'');if (exists$SIGIL_MAP{$sigil}){@ret=($variable,$sigil,$SIGIL_MAP{$sigil})}else {@ret=("${sigil}${variable}",'',$SIGIL_MAP{''})}}($ret[0]!~ /::/)|| confess "Variable names may not contain ::";return@ret}}sub _valid_for_type {my ($value,$type)=@_;if ($type eq 'HASH' || $type eq 'ARRAY' || $type eq 'IO' || $type eq 'CODE'){return reftype($value)eq $type}else {my$ref=reftype($value);return!defined($ref)|| $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING'}}sub add_symbol {my ($self,$variable,$initial_value,%opts)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);if (@_ > 2){_valid_for_type($initial_value,$type)|| confess "$initial_value is not of type $type";if ($^P and $^P & 0x10 && $sigil eq '&'){my$filename=$opts{filename};my$first_line_num=$opts{first_line_num};(undef,$filename,$first_line_num)=caller if not defined$filename;my$last_line_num=$opts{last_line_num}|| ($first_line_num ||= 0);$DB::sub{$self->name .'::' .$name}="$filename:$first_line_num-$last_line_num"}}if (BROKEN_GLOB_ASSIGNMENT){if (@_ > 2){no strict 'refs';no warnings 'redefine';*{$self->name .'::' .$name}=ref$initial_value ? $initial_value : \$initial_value}else {no strict 'refs';if (BROKEN_ISA_ASSIGNMENT && $name eq 'ISA'){*{$self->name .'::' .$name}}else {my$undef=_undef_ref_for_type($type);*{$self->name .'::' .$name}=$undef}}}else {my$namespace=$self->namespace;{local*__ANON__::=$namespace;no strict 'refs';no warnings 'void';no warnings 'once';*{"__ANON__::$name"}}if (@_ > 2){no warnings 'redefine';*{$namespace->{$name}}=ref$initial_value ? $initial_value : \$initial_value}else {return if BROKEN_ISA_ASSIGNMENT && $name eq 'ISA';*{$namespace->{$name}}=_undef_ref_for_type($type)}}}sub _undef_ref_for_type {my ($type)=@_;if ($type eq 'ARRAY'){return []}elsif ($type eq 'HASH'){return {}}elsif ($type eq 'SCALAR'){return \undef}elsif ($type eq 'IO'){return Symbol::geniosym}elsif ($type eq 'CODE'){confess "Don't know how to vivify CODE variables"}else {confess "Unknown type $type in vivication"}}sub remove_glob {my ($self,$name)=@_;delete$self->namespace->{$name}}sub has_symbol {my ($self,$variable)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my$namespace=$self->namespace;return unless exists$namespace->{$name};my$entry_ref=\$namespace->{$name};if (reftype($entry_ref)eq 'GLOB'){if ($type eq 'SCALAR'){if (BROKEN_SCALAR_INITIALIZATION){return defined ${*{$entry_ref}{$type}}}else {my$sv=B::svref_2object($entry_ref)->SV;return$sv->isa('B::SV')|| ($sv->isa('B::SPECIAL')&& $B::specialsv_name[$$sv]ne 'Nullsv')}}else {return defined *{$entry_ref}{$type}}}else {return$type eq 'CODE'}}sub get_symbol {my ($self,$variable,%opts)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my$namespace=$self->namespace;if (!exists$namespace->{$name}){if ($opts{vivify}){$self->add_symbol($variable)}else {return undef}}my$entry_ref=\$namespace->{$name};if (ref($entry_ref)eq 'GLOB'){return *{$entry_ref}{$type}}else {if ($type eq 'CODE'){if (BROKEN_GLOB_ASSIGNMENT || defined($self->{package})){no strict 'refs';return \&{$self->name .'::' .$name}}if (blessed($namespace)&& $namespace->isa('Package::Anon')){$namespace->bless(\(my$foo))->can($name)}else {confess "Don't know how to inflate a " .ref($entry_ref)." into a full coderef (perhaps you could use" ." Package::Anon instead of a bare stash?)"}return *{$namespace->{$name}}{CODE}}else {return undef}}}sub get_or_add_symbol {my$self=shift;$self->get_symbol(@_,vivify=>1)}sub remove_symbol {my ($self,$variable)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my%desc=(SCALAR=>{sigil=>'$',type=>'SCALAR',name=>$name },ARRAY=>{sigil=>'@',type=>'ARRAY',name=>$name },HASH=>{sigil=>'%',type=>'HASH',name=>$name },CODE=>{sigil=>'&',type=>'CODE',name=>$name },IO=>{sigil=>'',type=>'IO',name=>$name },);confess "This should never ever ever happen" if!$desc{$type};my@types_to_store=grep {$type ne $_ && $self->has_symbol($desc{$_})}keys%desc;my%values=map {$_,$self->get_symbol($desc{$_})}@types_to_store;$values{SCALAR}=$self->get_symbol($desc{SCALAR})if!defined$values{SCALAR}&& $type ne 'SCALAR' && BROKEN_SCALAR_INITIALIZATION;$self->remove_glob($name);$self->add_symbol($desc{$_}=>$values{$_})for grep {defined$values{$_}}keys%values}sub list_all_symbols {my ($self,$type_filter)=@_;my$namespace=$self->namespace;if (HAS_ISA_CACHE){return grep {$_ ne '::ISA::CACHE::'}keys %{$namespace}unless defined$type_filter}else {return keys %{$namespace}unless defined$type_filter}if ($type_filter eq 'CODE'){return grep {ref(\$namespace->{$_})ne 'GLOB' || defined(*{$namespace->{$_}}{CODE})}keys %{$namespace}}elsif ($type_filter eq 'SCALAR'){return grep {!(HAS_ISA_CACHE && $_ eq '::ISA::CACHE::')&& (BROKEN_SCALAR_INITIALIZATION ? (ref(\$namespace->{$_})eq 'GLOB' && defined(${*{$namespace->{$_}}{'SCALAR'}})): (do {my$entry=\$namespace->{$_};ref($entry)eq 'GLOB' && B::svref_2object($entry)->SV->isa('B::SV')}))}keys %{$namespace}}else {return grep {ref(\$namespace->{$_})eq 'GLOB' && defined(*{$namespace->{$_}}{$type_filter})}keys %{$namespace}}}sub get_all_symbols {my ($self,$type_filter)=@_;my$namespace=$self->namespace;return {%{$namespace}}unless defined$type_filter;return {map {$_=>$self->get_symbol({name=>$_,type=>$type_filter})}$self->list_all_symbols($type_filter)}}1;
PACKAGE_STASH_PP

$fatpacked{"Package/Stash/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_XS';
  package Package::Stash::XS;use strict;use warnings;use 5.008001;our$VERSION='0.29';use XSLoader;XSLoader::load(__PACKAGE__,exists$Package::Stash::XS::{VERSION}? ${$Package::Stash::XS::{VERSION}}: (),);1;
PACKAGE_STASH_XS

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;use strict;use warnings;package Path::Tiny;our$VERSION='0.108';use Config;use Exporter 5.57 (qw/import/);use File::Spec 0.86 ();use Carp ();our@EXPORT=qw/path/;our@EXPORT_OK=qw/cwd rootdir tempfile tempdir/;use constant {PATH=>0,CANON=>1,VOL=>2,DIR=>3,FILE=>4,TEMP=>5,IS_WIN32=>($^O eq 'MSWin32'),};use overload (q{""}=>sub {$_[0]->[PATH]},bool=>sub () {1},fallback=>1,);sub FREEZE {return $_[0]->[PATH]}sub THAW {return path($_[2])}{no warnings 'once';*TO_JSON=*FREEZE};my$HAS_UU;sub _check_UU {local$SIG{__DIE__};!!eval {require Unicode::UTF8;Unicode::UTF8->VERSION(0.58);1}}my$HAS_PU;sub _check_PU {local$SIG{__DIE__};!!eval {require Encode;require PerlIO::utf8_strict;PerlIO::utf8_strict->VERSION(0.003);1}}my$HAS_FLOCK=$Config{d_flock}|| $Config{d_fcntl_can_lock}|| $Config{d_lockf};my$SLASH=qr{[\\/]};my$NOTSLASH=qr{[^\\/]};my$DRV_VOL=qr{[a-z]:}i;my$UNC_VOL=qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;my$WIN32_ROOT=qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;sub _win32_vol {my ($path,$drv)=@_;require Cwd;my$dcwd=eval {Cwd::getdcwd($drv)};$dcwd="$drv" unless defined$dcwd && length$dcwd;$dcwd =~ s{$SLASH?$}{/};$path =~ s{^$DRV_VOL}{$dcwd};return$path}sub _is_root {return IS_WIN32()? ($_[0]=~ /^$WIN32_ROOT$/): ($_[0]eq '/')}BEGIN {*_same=IS_WIN32()? sub {lc($_[0])eq lc($_[1])}: sub {$_[0]eq $_[1]}}my%MODEBITS=(om=>0007,gm=>0070,um=>0700);{my$m=0;$MODEBITS{$_}=(1 << $m++)for qw/ox ow or gx gw gr ux uw ur/};sub _symbolic_chmod {my ($mode,$symbolic)=@_;for my$clause (split /,\s*/,$symbolic){if ($clause =~ m{\A([augo]+)([=+-])([rwx]+)\z}){my ($who,$action,$perms)=($1,$2,$3);$who =~ s/a/ugo/g;for my$w (split //,$who){my$p=0;$p |= $MODEBITS{"$w$_"}for split //,$perms;if ($action eq '='){$mode=($mode & ~$MODEBITS{"${w}m"})| $p}else {$mode=$action eq "+" ? ($mode | $p): ($mode & ~$p)}}}else {Carp::croak("Invalid mode clause '$clause' for chmod()")}}return$mode}{package flock;use warnings::register}my$WARNED_NO_FLOCK=0;sub _throw {my ($self,$function,$file,$msg)=@_;if ($function =~ /^flock/ && $! =~ /operation not supported|function not implemented/i &&!warnings::fatal_enabled('flock')){if (!$WARNED_NO_FLOCK){warnings::warn(flock=>"Flock not available: '$!': continuing in unsafe mode");$WARNED_NO_FLOCK++}}else {$msg=$! unless defined$msg;Path::Tiny::Error->throw($function,(defined$file ? $file : $self->[PATH]),$msg)}return}sub _get_args {my ($raw,@valid)=@_;if (defined($raw)&& ref($raw)ne 'HASH'){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Options for $called_as must be a hash reference")}my$cooked={};for my$k (@valid){$cooked->{$k}=delete$raw->{$k}if exists$raw->{$k}}if (keys %$raw){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Invalid option(s) for $called_as: " .join(", ",keys %$raw))}return$cooked}sub path {my$path=shift;Carp::croak("Path::Tiny paths require defined, positive-length parts")unless 1 + @_==grep {defined && length}$path,@_;if (!@_ && ref($path)eq __PACKAGE__ &&!$path->[TEMP]){return$path}$path="$path";if (IS_WIN32()){$path=_win32_vol($path,$1)if$path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};$path .= "/" if$path =~ m{^$UNC_VOL$}}if (@_){$path .= (_is_root($path)? "" : "/").join("/",@_)}my$cpath=$path=File::Spec->canonpath($path);$path =~ tr[\\][/] if IS_WIN32();$path="/" if$path eq '/..';$path .= "/" if IS_WIN32()&& $path =~ m{^$UNC_VOL$};if (_is_root($path)){$path =~ s{/?$}{/}}else {$path =~ s{/$}{}}if ($path =~ m{^(~[^/]*).*}){require File::Glob;my ($homedir)=File::Glob::bsd_glob($1);$homedir =~ tr[\\][/] if IS_WIN32();$path =~ s{^(~[^/]*)}{$homedir}}bless [$path,$cpath ],__PACKAGE__}sub new {shift;path(@_)}sub cwd {require Cwd;return path(Cwd::getcwd())}sub rootdir {path(File::Spec->rootdir)}sub tempfile {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);$args->{TEMPLATE}=$maybe_template->[0]if @$maybe_template;require File::Temp;my$temp=File::Temp->new(TMPDIR=>1,%$args);close$temp;my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;return$self}sub tempdir {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);require File::Temp;my$temp=File::Temp->newdir(@$maybe_template,TMPDIR=>1,%$args);my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;$temp->{REALNAME}=$self->[CANON]if IS_WIN32;return$self}sub _parse_file_temp_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map {uc($_),$args{$_}}keys%args;my@template=(exists$args{TEMPLATE}? delete$args{TEMPLATE}: $leading_template ? $leading_template : ());return (\@template,\%args)}sub _splitpath {my ($self)=@_;@{$self}[VOL,DIR,FILE ]=File::Spec->splitpath($self->[PATH])}sub _resolve_symlinks {my ($self)=@_;my$new=$self;my ($count,%seen)=0;while (-l $new->[PATH]){if ($seen{$new->[PATH]}++){$self->_throw('readlink',$self->[PATH],"symlink loop detected")}if (++$count > 100){$self->_throw('readlink',$self->[PATH],"maximum symlink depth exceeded")}my$resolved=readlink$new->[PATH]or $new->_throw('readlink',$new->[PATH]);$resolved=path($resolved);$new=$resolved->is_absolute ? $resolved : $new->sibling($resolved)}return$new}sub absolute {my ($self,$base)=@_;if (IS_WIN32){return$self if length$self->volume;if ($self->is_absolute){require Cwd;my ($drv)=Win32::GetCwd()=~ /^($DRV_VOL | $UNC_VOL)/x;return path($drv .$self->[PATH])}}else {return$self if$self->is_absolute}require Cwd;return path(Cwd::getcwd(),$_[0]->[PATH])unless defined$base;$base=path($base);return path(($base->is_absolute ? $base : $base->absolute),$_[0]->[PATH])}sub append {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$mode=$args->{truncate}? ">" : ">>";my$fh=$self->filehandle({locked=>1 },$mode,$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close')}sub append_raw {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);$args->{binmode}=':unix';append($self,$args,@data)}sub append_utf8 {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){$args->{binmode}=":unix";append($self,$args,map {Unicode::UTF8::encode_utf8($_)}@data)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";append($self,$args,@data)}else {$args->{binmode}=":unix:encoding(UTF-8)";append($self,$args,@data)}}sub assert {my ($self,$assertion)=@_;return$self unless$assertion;if (ref$assertion eq 'CODE'){local $_=$self;$assertion->()or Path::Tiny::Error->throw("assert",$self->[PATH],"failed assertion")}else {Carp::croak("argument to assert must be a code reference argument")}return$self}sub basename {my ($self,@suffixes)=@_;$self->_splitpath unless defined$self->[FILE];my$file=$self->[FILE];for my$s (@suffixes){my$re=ref($s)eq 'Regexp' ? qr/$s$/ : qr/\Q$s\E$/;last if$file =~ s/$re//}return$file}sub canonpath {$_[0]->[CANON]}sub cached_temp {my$self=shift;$self->_throw("cached_temp",$self,"has no cached File::Temp object")unless defined$self->[TEMP];return$self->[TEMP]}sub child {my ($self,@parts)=@_;return path($self->[PATH],@parts)}sub children {my ($self,$filter)=@_;my$dh;opendir$dh,$self->[PATH]or $self->_throw('opendir');my@children=readdir$dh;closedir$dh or $self->_throw('closedir');if (not defined$filter){@children=grep {$_ ne '.' && $_ ne '..'}@children}elsif ($filter && ref($filter)eq 'Regexp'){@children=grep {$_ ne '.' && $_ ne '..' && $_ =~ $filter}@children}else {Carp::croak("Invalid argument '$filter' for children()")}return map {path($self->[PATH],$_)}@children}sub chmod {my ($self,$new_mode)=@_;my$mode;if ($new_mode =~ /\d/){$mode=($new_mode =~ /^0/ ? oct($new_mode): $new_mode)}elsif ($new_mode =~ /[=+-]/){$mode=_symbolic_chmod($self->stat->mode & 07777,$new_mode)}else {Carp::croak("Invalid mode argument '$new_mode' for chmod()")}CORE::chmod($mode,$self->[PATH])or $self->_throw("chmod");return 1}sub copy {my ($self,$dest)=@_;require File::Copy;File::Copy::copy($self->[PATH],$dest)or Carp::croak("copy failed for $self to $dest: $!");return -d $dest ? path($dest,$self->basename): path($dest)}sub digest {my ($self,@opts)=@_;my$args=(@opts && ref$opts[0]eq 'HASH')? shift@opts : {};$args=_get_args($args,qw/chunk_size/);unshift@opts,'SHA-256' unless@opts;require Digest;my$digest=Digest->new(@opts);if ($args->{chunk_size}){my$fh=$self->filehandle({locked=>1 },"<",":unix");my$buf;$digest->add($buf)while read$fh,$buf,$args->{chunk_size}}else {$digest->add($self->slurp_raw)}return$digest->hexdigest}sub dirname {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return length$self->[DIR]? $self->[DIR]: "."}sub edit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp(exists($args->{binmode})? {binmode=>$args->{binmode}}: ());$cb->();$self->spew($args,$_);return}sub edit_utf8 {my ($self,$cb)=@_;Carp::croak("Callback for edit_utf8() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp_utf8;$cb->();$self->spew_utf8($_);return}sub edit_raw {$_[2]={binmode=>":unix" };goto&edit}sub edit_lines {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit_lines() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$temp_fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);my$in_fh=$self->filehandle({locked=>1 },'<',$binmode);local $_;while (<$in_fh>){$cb->();$temp_fh->print($_)}close$temp_fh or $self->_throw('close',$temp);close$in_fh or $self->_throw('close');return$temp->move($resolved_path)}sub edit_lines_raw {$_[2]={binmode=>":unix" };goto&edit_lines}sub edit_lines_utf8 {$_[2]={binmode=>":raw:encoding(UTF-8)" };goto&edit_lines}sub exists {-e $_[0]->[PATH]}sub is_file {-e $_[0]->[PATH]&&!-d _}sub is_dir {-d $_[0]->[PATH]}sub filehandle {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked exclusive/);$args->{locked}=1 if$args->{exclusive};my ($opentype,$binmode)=@args;$opentype="<" unless defined$opentype;Carp::croak("Invalid file mode '$opentype'")unless grep {$opentype eq $_}qw/< +< > +> >> +>>/;$binmode=((caller(0))[10]|| {})->{'open' .substr($opentype,-1,1)}unless defined$binmode;$binmode="" unless defined$binmode;my ($fh,$lock,$trunc);if ($HAS_FLOCK && $args->{locked}&&!$ENV{PERL_PATH_TINY_NO_FLOCK}){require Fcntl;if (grep {$opentype eq $_}qw(> +>)){my$flags=$opentype eq ">" ? Fcntl::O_WRONLY(): Fcntl::O_RDWR();$flags |= Fcntl::O_CREAT();$flags |= Fcntl::O_EXCL()if$args->{exclusive};sysopen($fh,$self->[PATH],$flags)or $self->_throw("sysopen");if ($binmode =~ s/^:unix//){binmode($fh,":raw")or $self->_throw("binmode (:raw)");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")or $self->_throw("binmode (:pop)")}}if (length$binmode){binmode($fh,$binmode)or $self->_throw("binmode ($binmode)")}$lock=Fcntl::LOCK_EX();$trunc=1}elsif ($^O eq 'aix' && $opentype eq "<"){if (-w $self->[PATH]){$opentype="+<";$lock=Fcntl::LOCK_EX()}}else {$lock=$opentype eq "<" ? Fcntl::LOCK_SH(): Fcntl::LOCK_EX()}}unless ($fh){my$mode=$opentype .$binmode;open$fh,$mode,$self->[PATH]or $self->_throw("open ($mode)")}do {flock($fh,$lock)or $self->_throw("flock ($lock)")}if$lock;do {truncate($fh,0)or $self->_throw("truncate")}if$trunc;return$fh}sub is_absolute {substr($_[0]->dirname,0,1)eq '/'}sub is_relative {substr($_[0]->dirname,0,1)ne '/'}sub is_rootdir {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return$self->[DIR]eq '/' && $self->[FILE]eq ''}sub iterator {my$self=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);my@dirs=$self;my$current;return sub {my$next;while (@dirs){if (ref$dirs[0]eq 'Path::Tiny'){if (!-r $dirs[0]){shift@dirs and next}$current=$dirs[0];my$dh;opendir($dh,$current->[PATH])or $self->_throw('opendir',$current->[PATH]);$dirs[0]=$dh;if (-l $current->[PATH]&&!$args->{follow_symlinks}){shift@dirs and next}}while (defined($next=readdir$dirs[0])){next if$next eq '.' || $next eq '..';my$path=$current->child($next);push@dirs,$path if$args->{recurse}&& -d $path &&!(!$args->{follow_symlinks}&& -l $path);return$path}shift@dirs}return}}sub lines {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);my$chomp=$args->{chomp};if ($args->{count}){my ($counter,$mod,@result)=(0,abs($args->{count}));while (my$line=<$fh>){$line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if$chomp;$result[$counter++ ]=$line;last if$counter==$args->{count};$counter %= $mod}splice(@result,0,0,splice(@result,$counter))if@result==$mod && $counter % $mod;return@result}elsif ($chomp){return map {s/(?:\x{0d}?\x{0a}|\x{0d})$//;$_}<$fh>}else {return wantarray ? <$fh> : (my$count=()=<$fh>)}}sub lines_raw {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ($args->{chomp}&&!$args->{count}){return split /\n/,slurp_raw($self)}else {$args->{binmode}=":raw";return lines($self,$args)}}my$CRLF=qr/(?:\x{0d}?\x{0a}|\x{0d})/;sub lines_utf8 {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ((defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU()))&& $args->{chomp}&&!$args->{count}){my$slurp=slurp_utf8($self);$slurp =~ s/$CRLF$//;return split$CRLF,$slurp,-1}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";return lines($self,$args)}else {$args->{binmode}=":raw:encoding(UTF-8)";return lines($self,$args)}}sub mkpath {my ($self,$args)=@_;$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};require File::Path;my@dirs=File::Path::make_path($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("mkpath failed for $file: $message")}return@dirs}sub move {my ($self,$dst)=@_;return rename($self->[PATH],$dst)|| $self->_throw('rename',$self->[PATH]."' -> '$dst")}my%opens=(opena=>">>",openr=>"<",openw=>">",openrw=>"+<");while (my ($k,$v)=each%opens){no strict 'refs';*{$k}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);my ($binmode)=@args;$binmode=((caller(0))[10]|| {})->{'open' .substr($v,-1,1)}unless defined$binmode;$self->filehandle($args,$v,$binmode)};*{$k ."_raw"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw")};*{$k ."_utf8"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw:encoding(UTF-8)")}}sub parent {my ($self,$level)=@_;$level=1 unless defined$level && $level > 0;$self->_splitpath unless defined$self->[FILE];my$parent;if (length$self->[FILE]){if ($self->[FILE]eq '.' || $self->[FILE]eq ".."){$parent=path($self->[PATH]."/..")}else {$parent=path(_non_empty($self->[VOL].$self->[DIR]))}}elsif (length$self->[DIR]){if ($self->[DIR]=~ m{(?:^\.\./|/\.\./|/\.\.$)}){$parent=path($self->[VOL].$self->[DIR]."/..")}else {(my$dir=$self->[DIR])=~ s{/[^\/]+/$}{/};$parent=path($self->[VOL].$dir)}}else {$parent=path(_non_empty($self->[VOL]))}return$level==1 ? $parent : $parent->parent($level - 1)}sub _non_empty {my ($string)=shift;return ((defined($string)&& length($string))? $string : ".")}sub realpath {my$self=shift;$self=$self->_resolve_symlinks;require Cwd;$self->_splitpath if!defined$self->[FILE];my$check_parent=length$self->[FILE]&& $self->[FILE]ne '.' && $self->[FILE]ne '..';my$realpath=eval {local$SIG{__WARN__}=sub {};Cwd::realpath($check_parent ? $self->parent->[PATH]: $self->[PATH])};$self->_throw("resolving realpath")unless defined$realpath && length$realpath && -e $realpath;return ($check_parent ? path($realpath,$self->[FILE]): path($realpath))}sub relative {my ($self,$base)=@_;$base=path(defined$base && length$base ? $base : '.');$self=$self->absolute if$self->is_relative;$base=$base->absolute if$base->is_relative;$self=$self->absolute if!length$self->volume && length$base->volume;$base=$base->absolute if length$self->volume &&!length$base->volume;if (!_same($self->volume,$base->volume)){Carp::croak("relative() can't cross volumes: '$self' vs '$base'")}return path(".")if _same($self->[PATH],$base->[PATH]);if ($base->subsumes($self)){$base="" if$base->is_rootdir;my$relative="$self";$relative =~ s{\A\Q$base/}{};return path($relative)}my (@common,@self_parts,@base_parts);@base_parts=split /\//,$base->_just_filepath;if ($self->is_rootdir){@common=("");shift@base_parts}else {@self_parts=split /\//,$self->_just_filepath;while (@self_parts && @base_parts && _same($self_parts[0],$base_parts[0])){push@common,shift@base_parts;shift@self_parts}}if (my$new_base=$self->_resolve_between(\@common,\@base_parts)){return$self->relative($new_base)}my@new_path=(("..")x (0+ @base_parts),@self_parts);return path(@new_path)}sub _just_filepath {my$self=shift;my$self_vol=$self->volume;return "$self" if!length$self_vol;(my$self_path="$self")=~ s{\A\Q$self_vol}{};return$self_path}sub _resolve_between {my ($self,$common,$base)=@_;my$path=$self->volume .join("/",@$common);my$changed=0;for my$p (@$base){$path .= "/$p";if ($p eq '..'){$changed=1;if (-e $path){$path=path($path)->realpath->[PATH]}else {$path =~ s{/[^/]+/..$}{/}}}if (-l $path){$changed=1;$path=path($path)->realpath->[PATH]}}return$changed ? path($path): undef}sub remove {my$self=shift;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];return unlink($self->[PATH])|| $self->_throw('unlink')}sub remove_tree {my ($self,$args)=@_;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};$args->{safe}=1 unless defined$args->{safe};require File::Path;my$count=File::Path::remove_tree($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("remove_tree failed for $file: $message")}return$count}sub sibling {my$self=shift;return path($self->parent->[PATH],@_)}sub slurp {my$self=shift;my$args=_get_args(shift,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);if ((defined($binmode)? $binmode : "")eq ":unix" and my$size=-s $fh){my$buf;read$fh,$buf,$size;return$buf}else {local $/;return scalar <$fh>}}sub slurp_raw {$_[1]={binmode=>":unix" };goto&slurp}sub slurp_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){return Unicode::UTF8::decode_utf8(slurp($_[0],{binmode=>":unix" }))}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$_[1]={binmode=>":unix:utf8_strict" };goto&slurp}else {$_[1]={binmode=>":raw:encoding(UTF-8)" };goto&slurp}}sub spew {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close',$temp->[PATH]);return$temp->move($resolved_path)}sub spew_raw {splice @_,1,0,{binmode=>":unix" };goto&spew}sub spew_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){my$self=shift;spew($self,{binmode=>":unix" },map {Unicode::UTF8::encode_utf8($_)}map {ref eq 'ARRAY' ? @$_ : $_}@_)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){splice @_,1,0,{binmode=>":unix:utf8_strict" };goto&spew}else {splice @_,1,0,{binmode=>":unix:encoding(UTF-8)" };goto&spew}}sub stat {my$self=shift;require File::stat;return File::stat::stat($self->[PATH])|| $self->_throw('stat')}sub lstat {my$self=shift;require File::stat;return File::stat::lstat($self->[PATH])|| $self->_throw('lstat')}sub stringify {$_[0]->[PATH]}sub subsumes {my$self=shift;Carp::croak("subsumes() requires a defined, positive-length argument")unless defined $_[0];my$other=path(shift);if ($self->is_absolute &&!$other->is_absolute){$other=$other->absolute}elsif ($other->is_absolute &&!$self->is_absolute){$self=$self->absolute}if (length$self->volume &&!length$other->volume){$other=$other->absolute}elsif (length$other->volume &&!length$self->volume){$self=$self->absolute}if ($self->[PATH]eq '.'){return!!1}elsif ($self->is_rootdir){return$other->[PATH]=~ m{^\Q$self->[PATH]\E}}else {return$other->[PATH]=~ m{^\Q$self->[PATH]\E(?:/|$)}}}sub touch {my ($self,$epoch)=@_;if (!-e $self->[PATH]){my$fh=$self->openw;close$fh or $self->_throw('close')}if (defined$epoch){utime$epoch,$epoch,$self->[PATH]or $self->_throw("utime ($epoch)")}else {utime undef,undef,$self->[PATH]or $self->_throw("utime ()")}return$self}sub touchpath {my ($self)=@_;my$parent=$self->parent;$parent->mkpath unless$parent->exists;$self->touch}sub visit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);Carp::croak("Callback for visit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$next=$self->iterator($args);my$state={};while (my$file=$next->()){local $_=$file;my$r=$cb->($file,$state);last if ref($r)eq 'SCALAR' &&!$$r}return$state}sub volume {my ($self)=@_;$self->_splitpath unless defined$self->[VOL];return$self->[VOL]}package Path::Tiny::Error;our@CARP_NOT=qw/Path::Tiny/;use overload (q{""}=>sub {(shift)->{msg}},fallback=>1);sub throw {my ($class,$op,$file,$err)=@_;chomp(my$trace=Carp::shortmess);my$msg="Error $op on '$file': $err$trace\n";die bless {op=>$op,file=>$file,err=>$err,msg=>$msg },$class}1;
PATH_TINY

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;use strict;use warnings;our$VERSION='2.001004';$VERSION =~ tr/_//d;our%INFO;our%APPLIED_TO;our%COMPOSED;our%COMPOSITE_INFO;our@ON_ROLE_CREATE;BEGIN {*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0};*_WORK_AROUND_HINT_LEAKAGE ="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_MRO_MODULE="$]" < 5.010 ? sub(){"MRO/Compat.pm"}: sub(){"mro.pm"};*_CONSTANTS_DEFLATE="$]" >= 5.012 && "$]" < 5.020 ? sub(){1}: sub(){0}}sub _getglob {no strict 'refs';\*{$_[0]}}sub _getstash {no strict 'refs';\%{"$_[0]::"}}sub croak {require Carp;no warnings 'redefine';*croak=\&Carp::croak;goto&Carp::croak}sub Role::Tiny::__GUARD__::DESTROY {delete$INC{$_[0]->[0]}if @{$_[0]}}sub _load_module {my ($module)=@_;(my$file="$module.pm")=~ s{::}{/}g;return 1 if$INC{$file};return 1 if grep!/::\z/,keys %{_getstash($module)};my$guard=_WORK_AROUND_BROKEN_MODULE_STATE && bless([$file ],'Role::Tiny::__GUARD__');local %^H if _WORK_AROUND_HINT_LEAKAGE;require$file;pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;return 1}sub _all_subs {my ($me,$package)=@_;my$stash=_getstash($package);return {map {;no strict 'refs';${"${package}::${_}"}=${"${package}::${_}"}if _CONSTANTS_DEFLATE;$_=>\&{"${package}::${_}"}}grep exists &{"${package}::${_}"},grep!/::\z/,keys %$stash }}sub import {my$target=caller;my$me=shift;strict->import;warnings->import;my$non_methods=$me->_non_methods($target);$me->_install_subs($target,@_);$me->make_role($target);$me->_mark_new_non_methods($target,$non_methods)if$non_methods && %$non_methods;return}sub _mark_new_non_methods {my ($me,$target,$old_non_methods)=@_;my$non_methods=$INFO{$target}{non_methods};my$subs=$me->_all_subs($target);for my$sub (keys %$subs){if (exists$old_non_methods->{$sub}&& $non_methods->{$sub}!=$subs->{$sub}){$non_methods->{$sub}=$subs->{$sub}}}return}sub make_role {my ($me,$target)=@_;return if$me->is_role($target);$INFO{$target}{is_role}=1;my$non_methods=$me->_all_subs($target);delete @{$non_methods}{grep /\A\(/,keys %$non_methods};$INFO{$target}{non_methods}=$non_methods;$APPLIED_TO{$target}={$target=>undef };for my$hook (@ON_ROLE_CREATE){$hook->($target)}}sub _install_subs {my ($me,$target)=@_;return if$me->is_role($target);my%install=$me->_gen_subs($target);*{_getglob("${target}::${_}")}=$install{$_}for sort keys%install;return}sub _gen_subs {my ($me,$target)=@_;((map {;my$type=$_;$type=>sub {push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];return}}qw(before after around)),requires=>sub {push @{$INFO{$target}{requires}||=[]},@_;return},with=>sub {$me->apply_roles_to_package($target,@_);return},)}sub role_application_steps {qw(_install_methods _check_requires _install_modifiers _copy_applied_list)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);croak "This is apply_role_to_package" if ref($to);croak "${role} is not a Role::Tiny" unless$me->is_role($role);for my$step ($me->role_application_steps){$me->$step($to,$role)}}sub _copy_applied_list {my ($me,$to,$role)=@_;@{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}}=()}sub apply_roles_to_object {my ($me,$object,@roles)=@_;croak "No roles supplied!" unless@roles;my$class=ref($object);bless($_[1],$me->create_class_with_roles($class,@roles))}my$role_suffix='A000';sub _composite_name {my ($me,$superclass,@roles)=@_;my$new_name=join('__WITH__',$superclass,my$compose_name=join '__AND__',@roles);if (length($new_name)> 252){$new_name=$COMPOSED{abbrev}{$new_name}||= do {my$abbrev=substr$new_name,0,250 - length$role_suffix;$abbrev =~ s/(?<!:):$//;$abbrev.'__'.$role_suffix++}}return wantarray ? ($new_name,$compose_name): $new_name}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;croak "No roles supplied!" unless@roles;_load_module($superclass);{my%seen;if (my@dupes=grep 1==$seen{$_}++,@roles){croak "Duplicated roles: ".join(', ',@dupes)}}my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);croak "${role} is not a Role::Tiny" unless$me->is_role($role)}require(_MRO_MODULE);my$composite_info=$me->_composite_info_for(@roles);my%conflicts=%{$composite_info->{conflicts}};if (keys%conflicts){my$fail=join "\n",map {"Method name conflict for '$_' between roles " ."'".join("' and '",sort values %{$conflicts{$_}})."'" .", cannot apply these simultaneously to an object."}keys%conflicts;croak$fail}my@composable=map$me->_composable_package_for($_),reverse@roles;my@requires=grep {my$method=$_;!grep $_->can($method)&&!$COMPOSED{role}{$_}{modifiers_only}{$method},@composable}@{$composite_info->{requires}};$me->_check_requires($superclass,$compose_name,\@requires);*{_getglob("${new_name}::ISA")}=[@composable,$superclass ];@{$APPLIED_TO{$new_name}||={}}{map keys %{$APPLIED_TO{$_}},@roles }=();$COMPOSED{class}{$new_name}=1;return$new_name}sub apply_role_to_package {shift->apply_single_role_to_package(@_)}sub apply_roles_to_package {my ($me,$to,@roles)=@_;return$me->apply_role_to_package($to,$roles[0])if@roles==1;my%conflicts=%{$me->_composite_info_for(@roles)->{conflicts}};my@have=grep$to->can($_),keys%conflicts;delete@conflicts{@have};if (keys%conflicts){my$fail=join "\n",map {"Due to a method name conflict between roles " ."'".join(' and ',sort values %{$conflicts{$_}})."'" .", the method '$_' must be implemented by '${to}'"}keys%conflicts;croak$fail}my@role_methods=map$me->_concrete_methods_of($_),@roles;local @{$_}{@have}for@role_methods;delete @{$_}{@have}for@role_methods;if ($INFO{$to}){delete$INFO{$to}{methods}}our%BACKCOMPAT_HACK;if($me ne __PACKAGE__ and exists$BACKCOMPAT_HACK{$me}? $BACKCOMPAT_HACK{$me}: $BACKCOMPAT_HACK{$me}=$me->can('role_application_steps')==\&role_application_steps && $me->can('apply_single_role_to_package')!=\&apply_single_role_to_package){for my$role (@roles){$me->apply_single_role_to_package($to,$role)}}else {for my$step ($me->role_application_steps){for my$role (@roles){$me->$step($to,$role)}}}$APPLIED_TO{$to}{join('|',@roles)}=1}sub _composite_info_for {my ($me,@roles)=@_;$COMPOSITE_INFO{join('|',sort@roles)}||= do {for my$role (@roles){_load_module($role)}my%methods;for my$role (@roles){my$this_methods=$me->_concrete_methods_of($role);$methods{$_}{$this_methods->{$_}}=$role for keys %$this_methods}my%requires;@requires{map @{$INFO{$_}{requires}||[]},@roles}=();delete$requires{$_}for keys%methods;delete$methods{$_}for grep keys(%{$methods{$_}})==1,keys%methods;+{conflicts=>\%methods,requires=>[keys%requires]}}}sub _composable_package_name_for {my ($me,$role)=@_;'Role::Tiny::_COMPOSABLE::'.$role}sub _composable_package_for {my ($me,$role)=@_;my$composed_name=$me->_composable_package_name_for($role);return$composed_name if$COMPOSED{role}{$composed_name};$me->_install_methods($composed_name,$role);my$base_name=$composed_name.'::_BASE';_getstash($base_name);{no strict 'refs';@{"${composed_name}::ISA"}=($base_name)}my$modifiers=$INFO{$role}{modifiers}||[];my@mod_base;my@modifiers=grep!$composed_name->can($_),do {my%h;@h{map @{$_}[1..$#$_-1],@$modifiers}=();keys%h};for my$modified (@modifiers){push@mod_base,"sub ${modified} { shift->next::method(\@_) }"}my$e;{local $@;eval(my$code=join "\n","package ${base_name};",@mod_base);$e="Evaling failed: $@\nTrying to eval:\n${code}" if $@}die$e if$e;$me->_install_modifiers($composed_name,$role);$COMPOSED{role}{$composed_name}={modifiers_only=>{map {$_=>1}@modifiers },};return$composed_name}sub _check_requires {my ($me,$to,$name,$requires)=@_;return unless my@requires=@{$requires||$INFO{$name}{requires}||[]};if (my@requires_fail=grep!$to->can($_),@requires){if (my$to_info=$INFO{$to}){push @{$to_info->{requires}||=[]},@requires_fail}else {croak "Can't apply ${name} to ${to} - missing ".join(', ',@requires_fail)}}}sub _non_methods {my ($me,$role)=@_;my$info=$INFO{$role}or return {};my%non_methods=%{$info->{non_methods}|| {}};my%not_methods=reverse %{$info->{not_methods}|| {}};return \%non_methods unless keys%not_methods;my$subs=$me->_all_subs($role);for my$sub (grep!/\A\(/,keys %$subs){my$code=$subs->{$sub};if (exists$not_methods{$code}){$non_methods{$sub}=$code}}return \%non_methods}sub _concrete_methods_of {my ($me,$role)=@_;my$info=$INFO{$role};return$info->{methods}if$info && $info->{methods};my$non_methods=$me->_non_methods($role);my$subs=$me->_all_subs($role);for my$sub (keys %$subs){if (exists$non_methods->{$sub}&& $non_methods->{$sub}==$subs->{$sub}){delete$subs->{$sub}}}if ($info){$info->{methods}=$subs}return$subs}sub methods_provided_by {my ($me,$role)=@_;croak "${role} is not a Role::Tiny" unless$me->is_role($role);sort (keys %{$me->_concrete_methods_of($role)},@{$INFO{$role}->{requires}||[]})}sub _install_methods {my ($me,$to,$role)=@_;my$methods=$me->_concrete_methods_of($role);my%existing_methods;@existing_methods{keys %{$me->_all_subs($to)}}=();my$applied_to=$APPLIED_TO{$to};if ($applied_to && %$applied_to){require(_MRO_MODULE);my%isa=map +($_=>1),@{mro::get_linear_isa($to)};my@composed=grep $_ ne $role && $isa{$me->_composable_package_name_for($_)},keys %{$APPLIED_TO{$to}};for my$package (@composed){@existing_methods{keys %{$me->_concrete_methods_of($package)}}=()}}delete$INFO{$to}{methods}if$INFO{$to};for my$i (keys %$methods){next if exists$existing_methods{$i};my$glob=_getglob "${to}::${i}";*$glob=$methods->{$i};next unless$i =~ /^\(/ && ((defined&overload::nil && $methods->{$i}==\&overload::nil)|| (defined&overload::_nil && $methods->{$i}==\&overload::_nil));my$overload=${_getglob "${role}::${i}"};next unless defined$overload;*$glob=\$overload}$me->_install_does($to)}sub _install_modifiers {my ($me,$to,$name)=@_;return unless my$modifiers=$INFO{$name}{modifiers};my$info=$INFO{$to};my$existing=($info ? $info->{modifiers}: $COMPOSED{modifiers}{$to})||= [];my@modifiers=grep {my$modifier=$_;!grep $_==$modifier,@$existing}@{$modifiers||[]};push @$existing,@modifiers;if (!$info){for my$modifier (@modifiers){$me->_install_single_modifier($to,@$modifier)}}}my$vcheck_error;sub _install_single_modifier {my ($me,@args)=@_;defined($vcheck_error)or $vcheck_error=do {local $@;eval {require Class::Method::Modifiers;Class::Method::Modifiers->VERSION(1.05);1}? 0 : $@};$vcheck_error and die$vcheck_error;Class::Method::Modifiers::install_modifier(@args)}my$FALLBACK=sub {0};sub _install_does {my ($me,$to)=@_;return if$me->is_role($to);my$does=$me->can('does_role');*{_getglob "${to}::does"}=$does unless$to->can('does');return if$to->can('DOES')and $to->can('DOES')!=(UNIVERSAL->can('DOES')|| 0);my$existing=$to->can('DOES')|| $to->can('isa')|| $FALLBACK;my$new_sub=sub {my ($proto,$role)=@_;$proto->$does($role)or $proto->$existing($role)};no warnings 'redefine';return *{_getglob "${to}::DOES"}=$new_sub}sub does_role {my ($proto,$role)=@_;require(_MRO_MODULE);for my$class (@{mro::get_linear_isa(ref($proto)||$proto)}){return 1 if exists$APPLIED_TO{$class}{$role}}return 0}sub is_role {my ($me,$role)=@_;return!!($INFO{$role}&& ($INFO{$role}{is_role}|| $INFO{$role}{not_methods}|| $INFO{$role}{non_methods}))}1;
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;use strict;use warnings;our$VERSION='2.001004';$VERSION =~ tr/_//d;use Role::Tiny ();use Exporter 'import';our@EXPORT=qw(with);sub with {my$target=caller;Role::Tiny->apply_roles_to_package($target,@_)}1;
ROLE_TINY_WITH

$fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
  package String::ShellQuote;use strict;use vars qw($VERSION @ISA @EXPORT);require Exporter;$VERSION='1.04';@ISA=qw(Exporter);@EXPORT=qw(shell_quote shell_quote_best_effort shell_comment_quote);sub croak {require Carp;goto&Carp::croak}sub _shell_quote_backend {my@in=@_;my@err=();if (0){require RS::Handy;print RS::Handy::data_dump(\@in)}return \@err,'' unless@in;my$ret='';my$saw_non_equal=0;for (@in){if (!defined $_ or $_ eq ''){$_="''";next}if (s/\x00//g){push@err,"No way to quote string containing null (\\000) bytes"}my$escape=0;if (/=/){if (!$saw_non_equal){$escape=1}}else {$saw_non_equal=1}if (m|[^\w!%+,\-./:=@^]|){$escape=1}if ($escape || (!$saw_non_equal && /=/)){s/'/'\\''/g;s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;$_="'$_'";s/^''//;s/''$//}}continue {$ret .= "$_ "}chop$ret;return \@err,$ret}sub shell_quote {my ($rerr,$s)=_shell_quote_backend @_;if (@$rerr){my%seen;@$rerr=grep {!$seen{$_}++}@$rerr;my$s=join '',map {"shell_quote(): $_\n"}@$rerr;chomp$s;croak$s}return$s}sub shell_quote_best_effort {my ($rerr,$s)=_shell_quote_backend @_;return$s}sub shell_comment_quote {return '' unless @_;unless (@_==1){croak "Too many arguments to shell_comment_quote " ."(got " .@_ ." expected 1)"}local $_=shift;s/\n/\n#/g;return $_}1;
STRING_SHELLQUOTE

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;use strict;use warnings;use Exporter qw(import);use Scalar::Util qw(weaken);use Carp qw(croak);our$VERSION='2.006006';$VERSION=eval$VERSION;our@EXPORT=qw(defer_sub undefer_sub undefer_all);our@EXPORT_OK=qw(undefer_package defer_info);sub _getglob {no strict 'refs';\*{$_[0]}}BEGIN {my$no_subname;*_subname =defined&Sub::Util::set_subname ? \&Sub::Util::set_subname : defined&Sub::Name::subname ? \&Sub::Name::subname : (eval {require Sub::Util}&& defined&Sub::Util::set_subname)? \&Sub::Util::set_subname : (eval {require Sub::Name}&& defined&Sub::Name::subname)? \&Sub::Name::subname : ($no_subname=1,sub {$_[1]});*_CAN_SUBNAME=$no_subname ? sub(){0}: sub(){1}}sub _name_coderef {shift if @_ > 2;_CAN_SUBNAME ? _subname(@_): $_[1]}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}our%DEFERRED;sub undefer_sub {my ($deferred)=@_;my$info=$DEFERRED{$deferred}or return$deferred;my ($target,$maker,$options,$undeferred_ref,$deferred_sub)=@$info;if (!($deferred_sub && $deferred eq $deferred_sub || ${$undeferred_ref}&& $deferred eq ${$undeferred_ref})){return$deferred}return ${$undeferred_ref}if ${$undeferred_ref};${$undeferred_ref}=my$made=$maker->();if (defined($target)&& $deferred eq *{_getglob($target)}{CODE}||''){no warnings 'redefine';*{_getglob($target)}=$made}my$undefer_info=[$target,$maker,$options,$undeferred_ref ];$info->[5]=$DEFERRED{$made}=$undefer_info;weaken ${$undefer_info->[3]};return$made}sub undefer_all {undefer_sub($_)for keys%DEFERRED;return}sub undefer_package {my$package=shift;undefer_sub($_)for grep {my$name=$DEFERRED{$_}&& $DEFERRED{$_}[0];$name && $name =~ /^${package}::[^:]+$/}keys%DEFERRED;return}sub defer_info {my ($deferred)=@_;my$info=$DEFERRED{$deferred||''}or return undef;my ($target,$maker,$options,$undeferred_ref,$deferred_sub)=@$info;if (!($deferred_sub && $deferred eq $deferred_sub || ${$undeferred_ref}&& $deferred eq ${$undeferred_ref})){delete$DEFERRED{$deferred};return undef}[$target,$maker,$options,($undeferred_ref && $$undeferred_ref ? $$undeferred_ref : ()),]}sub defer_sub {my ($target,$maker,$options)=@_;my$package;my$subname;($package,$subname)=$target =~ /^(.*)::([^:]+)$/ or croak "$target is not a fully qualified sub name!" if$target;$package ||= $options && $options->{package}|| caller;my@attributes=@{$options && $options->{attributes}|| []};if (@attributes){/\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_" for@attributes}my$deferred;my$undeferred;my$deferred_info=[$target,$maker,$options,\$undeferred ];if (@attributes || $target &&!_CAN_SUBNAME){my$code =q[#line ].(__LINE__+2).q[ "].__FILE__.qq["\n] .qq[package $package;\n] .($target ? "sub $subname" : '+sub').join('',map " :$_",@attributes).q[ {
          package Sub::Defer;
          # uncoverable subroutine
          # uncoverable statement
          $undeferred ||= undefer_sub($deferred_info->[4]);
          goto &$undeferred; # uncoverable statement
          $undeferred; # fake lvalue return
        }]."\n" .($target ? "\\&$subname" : '');my$e;$deferred=do {no warnings qw(redefine closure);local $@;eval$code or $e=$@};die$e if defined$e}else {$deferred=sub {$undeferred ||= undefer_sub($deferred_info->[4]);goto &$undeferred};_install_coderef($target,$deferred)if$target}weaken($deferred_info->[4]=$deferred);weaken($DEFERRED{$deferred}=$deferred_info);return$deferred}sub CLONE {%DEFERRED=map {defined $_ ? ($_->[4]? ($_->[4]=>$_): ($_->[3]&& ${$_->[3]})? (${$_->[3]}=>$_): ()): ()}values%DEFERRED}1;
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;$Sub::Exporter::Progressive::VERSION='0.001013';use strict;use warnings;sub _croak {require Carp;&Carp::croak}sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';no warnings 'once';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (grep {length ref $_ or $_ !~ / \A [:-]? \w+ \z /xm}@args){_croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined((my ($num)=grep {m/^\d/}@args)[0])){_croak "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if (($setup||'')eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){_croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};_croak$too_complicated if grep {length ref $_}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){_croak$too_complicated if grep {length ref $_ or $_ =~ / \A - (?! all \b ) /x}@{$tagset}}@defaults=@{$tags{default}|| []}}else {_croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||= [@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;_croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Identify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_IDENTIFY';
  package Sub::Identify;use strict;use Exporter;BEGIN {our$VERSION='0.14';our@ISA=('Exporter');our%EXPORT_TAGS=(all=>[our@EXPORT_OK=qw(sub_name stash_name sub_fullname get_code_info get_code_location is_sub_constant) ]);our$IsPurePerl=1;unless ($ENV{PERL_SUB_IDENTIFY_PP}){if (eval {require XSLoader;XSLoader::load(__PACKAGE__,$VERSION);1}){$IsPurePerl=0}else {die $@ if $@ && $@ !~ /object version|loadable object/}}if ($IsPurePerl){require B;*get_code_info=sub ($) {my ($coderef)=@_;ref$coderef or return;my$cv=B::svref_2object($coderef);$cv->isa('B::CV')or return;$cv->GV->isa('B::SPECIAL')and return;return ($cv->GV->STASH->NAME,$cv->GV->NAME)};*get_code_location=sub ($) {my ($coderef)=@_;ref$coderef or return;my$cv=B::svref_2object($coderef);$cv->isa('B::CV')&& $cv->START->isa('B::COP')or return;return ($cv->START->file,$cv->START->line)}}if ($IsPurePerl || $] < 5.016){require B;*is_sub_constant=sub ($) {my ($coderef)=@_;ref$coderef or return 0;my$cv=B::svref_2object($coderef);$cv->isa('B::CV')or return 0;my$p=prototype$coderef;defined$p && $p eq "" or return 0;return ($cv->CvFLAGS & B::CVf_CONST())==B::CVf_CONST()}}}sub stash_name ($) {(get_code_info($_[0]))[0]}sub sub_name ($) {(get_code_info($_[0]))[1]}sub sub_fullname ($) {join '::',get_code_info($_[0])}1;
SUB_IDENTIFY

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;sub _clean_eval {eval $_[0]}use strict;use warnings;use Sub::Defer qw(defer_sub);use Scalar::Util qw(weaken);use Exporter qw(import);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Sub::Defer)}use B ();BEGIN {*_HAVE_IS_UTF8=defined&utf8::is_utf8 ? sub(){1}: sub(){0};*_HAVE_PERLSTRING=defined&B::perlstring ? sub(){1}: sub(){0};*_BAD_BACKSLASH_ESCAPE=_HAVE_PERLSTRING()&& "$]"==5.010_000 ? sub(){1}: sub(){0};*_HAVE_HEX_FLOAT=!$ENV{SUB_QUOTE_NO_HEX_FLOAT}&& "$]" >= 5.022 ? sub(){1}: sub(){0};my$nvsize=8 * length pack 'F',0;my$nvmantbits =$nvsize==16 ? 11 : $nvsize==32 ? 24 : $nvsize==64 ? 53 : $nvsize==80 ? 64 : $nvsize==128 ? 113 : $nvsize==256 ? 237 : 237 ;my$precision=int(log(2)/log(10)*$nvmantbits);*_NVSIZE=sub(){$nvsize};*_NVMANTBITS=sub(){$nvmantbits};*_FLOAT_PRECISION=sub(){$precision}}our$VERSION='2.006006';$VERSION =~ tr/_//d;our@EXPORT=qw(quote_sub unquote_sub quoted_from_sub qsub);our@EXPORT_OK=qw(quotify capture_unroll inlinify sanitize_identifier);our%QUOTED;my%escape;if (_BAD_BACKSLASH_ESCAPE){%escape=((map +(chr($_)=>sprintf '\x%02x',$_),0 .. 0x31,0x7f),"\t"=>"\\t","\n"=>"\\n","\r"=>"\\r","\f"=>"\\f","\b"=>"\\b","\a"=>"\\a","\e"=>"\\e",(map +($_=>"\\$_"),qw(" \ $ @)),)}sub quotify {my$value=$_[0];no warnings 'numeric';!defined$value ? 'undef()' : (!(_HAVE_IS_UTF8 && utf8::is_utf8($value))&& length((my$dummy='')& $value)&& 0 + $value eq $value)? ($value!=$value ? ($value eq (9**9**9*0)? '(9**9**9*0)' : '(-(9**9**9*0))'): $value==9**9**9 ? '(9**9**9)' : $value==-9**9**9 ? '(-9**9**9)' : $value==0 ? (sprintf('%g',$value)eq '-0' ? '-0.0' : '0',): $value !~ /[e.]/i ? ($value > 0 ? (sprintf '%u',$value): (sprintf '%d',$value)): do {my$float=$value;my$max_factor=int(log(abs($value))/ log(2))- _NVMANTBITS;my$ex_sign=$max_factor > 0 ? 1 : -1;FACTOR: for my$ex (0 .. abs($max_factor)){my$num=$value / 2**($ex_sign * $ex);for my$precision (_FLOAT_PRECISION .. _FLOAT_PRECISION+2){my$formatted=sprintf '%.'.$precision.'g',$num;$float=$formatted if$ex==0;if ($formatted==$num){if ($ex){$float =$formatted .($ex_sign==1 ? '*' : '/').($ex > _NVMANTBITS ? "2**$ex" : sprintf('%u',2**$ex))}last FACTOR}}if (_HAVE_HEX_FLOAT){$float=sprintf '%a',$value;last FACTOR}}"$float"}):!length($value)&& length((my$dummy2='')& $value)? '(!1)' : _BAD_BACKSLASH_ESCAPE && _HAVE_IS_UTF8 && utf8::is_utf8($value)? do {$value =~ s/(["\$\@\\[:cntrl:]]|[^\x00-\x7f])/
        $escape{$1} || sprintf('\x{%x}', ord($1))
      /ge;qq["$value"]}: _HAVE_PERLSTRING ? B::perlstring($value): qq["\Q$value\E"]}sub sanitize_identifier {my$name=shift;$name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;$name}sub capture_unroll {my ($from,$captures,$indent)=@_;join('',map {/^([\@\%\$])/ or croak "capture key should start with \@, \% or \$: $_";(' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n}}keys %$captures)}sub inlinify {my ($code,$args,$extra,$local)=@_;$args='()' if!defined$args;my$do='do { '.($extra||'');if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//){$do .= $1}if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms){my ($pre,$indent,$code_args)=($1,$2,$3);$do .= $pre;if ($code_args ne $args){$do .= $indent .'my ('.$code_args.') = ('.$args.'); '}}elsif ($local || $args ne '@_'){$do .= ($local ? 'local ' : '').'@_ = ('.$args.'); '}$do.$code.' }'}sub quote_sub {my$options=(ref($_[-1])eq 'HASH' and ref($_[-2])eq 'HASH')? pop : {};my$captures=ref($_[-1])eq 'HASH' ? pop : undef;undef($captures)if$captures &&!keys %$captures;my$code=pop;my$name=$_[0];if ($name){my$subname=$name;my$package=$subname =~ s/(.*)::// ? $1 : caller;$name=join '::',$package,$subname;croak qq{package name "$package" too long!} if length$package > 252;croak qq{package name "$package" is not valid!} unless$package =~ /^[^\d\W]\w*(?:::\w+)*$/;croak qq{sub name "$subname" too long!} if length$subname > 252;croak qq{sub name "$subname" is not valid!} unless$subname =~ /^[^\d\W]\w*$/}my@caller=caller(0);my ($attributes,$file,$line)=@{$options}{qw(attributes file line)};if ($attributes){/\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_" for @$attributes}my$quoted_info={name=>$name,code=>$code,captures=>$captures,package=>(exists$options->{package}? $options->{package}: $caller[0]),hints=>(exists$options->{hints}? $options->{hints}: $caller[8]),warning_bits=>(exists$options->{warning_bits}? $options->{warning_bits}: $caller[9]),hintshash=>(exists$options->{hintshash}? $options->{hintshash}: $caller[10]),($attributes ? (attributes=>$attributes): ()),($file ? (file=>$file): ()),($line ? (line=>$line): ()),};my$unquoted;weaken($quoted_info->{unquoted}=\$unquoted);if ($options->{no_defer}){my$fake=\my$var;local$QUOTED{$fake}=$quoted_info;my$sub=unquote_sub($fake);Sub::Defer::_install_coderef($name,$sub)if$name &&!$options->{no_install};return$sub}else {my$deferred=defer_sub(($options->{no_install}? undef : $name),sub {$unquoted if 0;unquote_sub($quoted_info->{deferred})},{($attributes ? (attributes=>$attributes): ()),($name ? (): (package=>$quoted_info->{package})),},);weaken($quoted_info->{deferred}=$deferred);weaken($QUOTED{$deferred}=$quoted_info);return$deferred}}sub _context {my$info=shift;$info->{context}||= do {my ($package,$hints,$warning_bits,$hintshash,$file,$line)=@{$info}{qw(package hints warning_bits hintshash file line)};$line ||= 1 if$file;my$line_mark='';if ($line){$line_mark="#line ".($line-1);if ($file){$line_mark .= qq{ "$file"}}$line_mark .= "\n"}$info->{context}="# BEGIN quote_sub PRELUDE\n" ."package $package;\n" ."BEGIN {\n" ."  \$^H = ".quotify($hints).";\n" ."  \${^WARNING_BITS} = ".quotify($warning_bits).";\n" ."  \%^H = (\n" .join('',map "    ".quotify($_)." => ".quotify($hintshash->{$_}).",\n",grep!(ref$hintshash->{$_}&& $hintshash->{$_}=~ /\A(?:\w+(?:::\w+)*=)?[A-Z]+\(0x[[0-9a-fA-F]+\)\z/),keys %$hintshash)."  );\n" ."}\n" .$line_mark ."# END quote_sub PRELUDE\n"}}sub quoted_from_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub||''}or return undef;my ($name,$code,$captures,$unquoted,$deferred)=@{$quoted_info}{qw(name code captures unquoted deferred)};$code=_context($quoted_info).$code;$unquoted &&= $$unquoted;if (($deferred && $deferred eq $sub)|| ($unquoted && $unquoted eq $sub)){return [$name,$code,$captures,$unquoted,$deferred ]}return undef}sub unquote_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub}or return undef;my$unquoted=$quoted_info->{unquoted};unless ($unquoted && $$unquoted){my ($name,$code,$captures,$package,$attributes)=@{$quoted_info}{qw(name code captures package attributes)};($package,$name)=$name =~ /(.*)::(.*)/ if$name;my%captures=$captures ? %$captures : ();$captures{'$_UNQUOTED'}=\$unquoted;$captures{'$_QUOTED'}=\$quoted_info;my$make_sub ="{\n" .capture_unroll("\$_[1]",\%captures,2)."  package ${package};\n" .($name ? "  no warnings 'closure';\n  sub ${name} " : "  \$\$_UNQUOTED = sub ").($attributes ? join('',map ":$_ ",@$attributes): '')."{\n" ."  (\$_QUOTED,\$_UNQUOTED) if 0;\n" ._context($quoted_info).$code ."  }".($name ? "\n  \$\$_UNQUOTED = \\&${name}" : '').";\n" ."}\n" ."1;\n";if (my$debug=$ENV{SUB_QUOTE_DEBUG}){if ($debug =~ m{^([^\W\d]\w*(?:::\w+)*(?:::)?)$}){my$filter=$1;my$match =$filter =~ /::$/ ? $package.'::' : $filter =~ /::/ ? $package.'::'.($name||'__ANON__'): ($name||'__ANON__');warn$make_sub if$match eq $filter}elsif ($debug =~ m{\A/(.*)/\z}s){my$filter=$1;warn$make_sub if$code =~ $filter}else {warn$make_sub}}{no strict 'refs';local *{"${package}::${name}"}if$name;my ($success,$e);{local $@;$success=_clean_eval($make_sub,\%captures);$e=$@}unless ($success){my$space=length($make_sub =~ tr/\n//);my$line=0;$make_sub =~ s/^/sprintf "%${space}d: ", ++$line/emg;croak "Eval went very, very wrong:\n\n${make_sub}\n\n$e"}weaken($QUOTED{$$unquoted}=$quoted_info)}}$$unquoted}sub qsub ($) {goto&quote_sub}sub CLONE {my@quoted=map {defined $_ ? ($_->{unquoted}&& ${$_->{unquoted}}? (${$_->{unquoted}}=>$_): (),$_->{deferred}? ($_->{deferred}=>$_): (),): ()}values%QUOTED;%QUOTED=@quoted;weaken($_)for values%QUOTED}1;
SUB_QUOTE

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.30';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}_subname(caller().'::try {...} '=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;_subname(caller().'::catch {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;_subname(caller().'::finally {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"Variable/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VARIABLE_MAGIC';
  package Variable::Magic;use 5.008;use strict;use warnings;our$VERSION;BEGIN {$VERSION='0.62'}BEGIN {require XSLoader;XSLoader::load(__PACKAGE__,$VERSION)}sub wizard {if (@_ % 2){require Carp;Carp::croak('Wrong number of arguments for wizard()')}my%opts=@_;my@keys=qw<op_info data get set len clear free copy dup>;push@keys,'local' if MGf_LOCAL;push@keys,qw<fetch store exists delete copy_key> if VMG_UVAR;my ($wiz,$err);{local $@;$wiz=eval {_wizard(map$opts{$_},@keys)};$err=$@}if ($err){$err =~ s/\sat\s+.*?\n//;require Carp;Carp::croak($err)}return$wiz}use base qw<Exporter>;our@EXPORT=();our%EXPORT_TAGS=('funcs'=>[qw<wizard cast getdata dispell> ],'consts'=>[qw<MGf_COPY MGf_DUP MGf_LOCAL VMG_UVAR VMG_COMPAT_SCALAR_LENGTH_NOLEN VMG_COMPAT_SCALAR_NOLEN VMG_COMPAT_ARRAY_PUSH_NOLEN VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID VMG_COMPAT_ARRAY_UNDEF_CLEAR VMG_COMPAT_HASH_DELETE_NOUVAR_VOID VMG_COMPAT_CODE_COPY_CLONE VMG_COMPAT_GLOB_GET VMG_PERL_PATCHLEVEL VMG_THREADSAFE VMG_FORKSAFE VMG_OP_INFO_NAME VMG_OP_INFO_OBJECT> ],);our@EXPORT_OK=map {@$_}values%EXPORT_TAGS;$EXPORT_TAGS{'all'}=[@EXPORT_OK ];1;
VARIABLE_MAGIC

$fatpacked{"Win32/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WIN32_SHELLQUOTE';
  package Win32::ShellQuote;use strict;use warnings FATAL=>'all';use base 'Exporter';use Carp;our$VERSION='0.003001';$VERSION=eval$VERSION;our@EXPORT_OK=qw(quote_native quote_cmd quote_system_list quote_system_string quote_system quote_system_cmd quote_literal cmd_escape unquote_native cmd_unescape);our%EXPORT_TAGS=(all=>[@EXPORT_OK]);sub quote_native {return join q{ },quote_system_list(@_)}sub quote_cmd {return cmd_escape(quote_native(@_))}sub quote_system_list {return map {quote_literal($_,1)}@_}sub quote_system_string {my$args=quote_native(@_);if (_has_shell_metachars($args)){$args=cmd_escape($args)}return$args}sub quote_system {if (@_ > 1){return quote_system_list(@_)}else {return quote_system_string(@_)}}sub quote_system_cmd {my$args=quote_native(@_);if (!_has_shell_metachars($args)){return '%PATH:~0,0%' .cmd_escape($args)}return cmd_escape($args)}sub cmd_escape {my$string=shift;if ($string =~ /[\r\n\0]/){croak "can't quote newlines to pass through cmd.exe"}$string =~ s/([()%!^"<>&|])/^$1/g;return$string}sub quote_literal {my ($text,$force)=@_;if (!$force && $text ne '' && $text !~ /[ \t\n\x0b"]/){}else {$text =~ s{(\\*)(?="|\z)}{$1$1}g;$text =~ s{"}{\\"}g;$text=qq{"$text"}}return$text}sub _has_shell_metachars {my$string=shift;return 1 if$string =~ /%/;$string =~ s/(['"]).*?(\1|\z)//sg;return$string =~ /[<>|]/}sub unquote_native {local ($_)=@_;my@argv;my$length=length or return@argv;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub cmd_unescape {my ($string)=@_;no warnings 'uninitialized';$string =~ s/\^(.?)|([^^"]+)|("[^"]*(?:"|\z))/$1$2$3/gs;return$string}1;
WIN32_SHELLQUOTE

$fatpacked{"YAML/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TINY';
  use 5.008001;use strict;use warnings;package YAML::Tiny;our$VERSION='1.73';use Exporter;our@ISA=qw{Exporter};our@EXPORT=qw{Load Dump};our@EXPORT_OK=qw{LoadFile DumpFile freeze thaw};sub Dump {return YAML::Tiny->new(@_)->_dump_string}sub Load {my$self=YAML::Tiny->_load_string(@_);if (wantarray){return @$self}else {return$self->[-1]}}BEGIN {*freeze=\&Dump;*thaw=\&Load}sub DumpFile {my$file=shift;return YAML::Tiny->new(@_)->_dump_file($file)}sub LoadFile {my$file=shift;my$self=YAML::Tiny->_load_file($file);if (wantarray){return @$self}else {return$self->[-1]}}sub new {my$class=shift;bless [@_ ],$class}sub read_string {my$self=shift;$self->_load_string(@_)}sub write_string {my$self=shift;$self->_dump_string(@_)}sub read {my$self=shift;$self->_load_file(@_)}sub write {my$self=shift;$self->_dump_file(@_)}my@UNPRINTABLE=qw(0 x01 x02 x03 x04 x05 x06 a b t n v f r x0E x0F x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x1A e x1C x1D x1E x1F);my%UNESCAPES=(0=>"\x00",z=>"\x00",N=>"\x85",a=>"\x07",b=>"\x08",t=>"\x09",n=>"\x0a",v=>"\x0b",f=>"\x0c",r=>"\x0d",e=>"\x1b",'\\'=>'\\',);my%QUOTE=map {$_=>1}qw{null true false};my$re_capture_double_quoted=qr/\"([^\\"]*(?:\\.[^\\"]*)*)\"/;my$re_capture_single_quoted=qr/\'([^\']*(?:\'\'[^\']*)*)\'/;my$re_capture_unquoted_key=qr/([^:]+(?::+\S(?:[^:]*|.*?(?=:)))*)(?=\s*\:(?:\s+|$))/;my$re_trailing_comment=qr/(?:\s+\#.*)?/;my$re_key_value_separator=qr/\s*:(?:\s+(?:\#.*)?|$)/;sub _load_file {my$class=ref $_[0]? ref shift : shift;my$file=shift or $class->_error('You did not specify a file name');$class->_error("File '$file' does not exist")unless -e $file;$class->_error("'$file' is a directory, not a file")unless -f _;$class->_error("Insufficient permissions to read '$file'")unless -r _;open(my$fh,"<:unix:encoding(UTF-8)",$file);unless ($fh){$class->_error("Failed to open file '$file': $!")}if (_can_flock()){flock($fh,Fcntl::LOCK_SH())or warn "Couldn't lock '$file' for reading: $!"}my$contents=eval {use warnings FATAL=>'utf8';local $/;<$fh>};if (my$err=$@){$class->_error("Error reading from file '$file': $err")}unless (close$fh){$class->_error("Failed to close file '$file': $!")}$class->_load_string($contents)}sub _load_string {my$class=ref $_[0]? ref shift : shift;my$self=bless [],$class;my$string=$_[0];eval {unless (defined$string){die \"Did not provide a string to load"}if (utf8::is_utf8($string)&&!utf8::valid($string)){die \<<'...'}utf8::upgrade($string);$string =~ s/^\x{FEFF}//;return$self unless length$string;my@lines=grep {!/^\s*(?:\#.*)?\z/}split /(?:\015{1,2}\012|\015|\012)/,$string;@lines and $lines[0]=~ /^\%YAML[: ][\d\.]+.*\z/ and shift@lines;my$in_document=0;while (@lines){if ($lines[0]=~ /^---\s*(?:(.+)\s*)?\z/){shift@lines;if (defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/){push @$self,$self->_load_scalar("$1",[undef ],\@lines);next}$in_document=1}if (!@lines or $lines[0]=~ /^(?:---|\.\.\.)/){push @$self,undef;while (@lines and $lines[0]!~ /^---/){shift@lines}$in_document=0}elsif (!$in_document && @$self){die \"YAML::Tiny failed to classify the line '$lines[0]'"}elsif ($lines[0]=~ /^\s*\-(?:\s|$|-+$)/){my$document=[];push @$self,$document;$self->_load_array($document,[0 ],\@lines)}elsif ($lines[0]=~ /^(\s*)\S/){my$document={};push @$self,$document;$self->_load_hash($document,[length($1)],\@lines)}else {die \"YAML::Tiny failed to classify the line '$lines[0]'"}}};my$err=$@;if (ref$err eq 'SCALAR'){$self->_error(${$err})}elsif ($err){$self->_error($err)}return$self}sub _unquote_single {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\'\'/\'/g;return$string}sub _unquote_double {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\\"/"/g;$string =~ s{\\([Nnever\\fartz0b]|x([0-9a-fA-F]{2}))}
  Read an invalid UTF-8 string (maybe mixed UTF-8 and 8-bit character set).
  Did you decode with lax ":utf8" instead of strict ":encoding(UTF-8)"?
  ...
           {(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}}gex;return$string}sub _load_scalar {my ($self,$string,$indent,$lines)=@_;$string =~ s/\s*\z//;return undef if$string eq '~';if ($string =~ /^$re_capture_single_quoted$re_trailing_comment\z/){return$self->_unquote_single($1)}if ($string =~ /^$re_capture_double_quoted$re_trailing_comment\z/){return$self->_unquote_double($1)}if ($string =~ /^[\'\"!&]/){die \"YAML::Tiny does not support a feature in line '$string'"}return {}if$string =~ /^{}(?:\s+\#.*)?\z/;return []if$string =~ /^\[\](?:\s+\#.*)?\z/;if ($string !~ /^[>|]/){die \"YAML::Tiny found illegal characters in plain scalar: '$string'" if$string =~ /^(?:-(?:\s|$)|[\@\%\`])/ or $string =~ /:(?:\s|$)/;$string =~ s/\s+#.*\z//;return$string}die \"YAML::Tiny failed to find multi-line scalar content" unless @$lines;$lines->[0]=~ /^(\s*)/;$indent->[-1]=length("$1");if (defined$indent->[-2]and $indent->[-1]<= $indent->[-2]){die \"YAML::Tiny found bad indenting in line '$lines->[0]'"}my@multiline=();while (@$lines){$lines->[0]=~ /^(\s*)/;last unless length($1)>= $indent->[-1];push@multiline,substr(shift(@$lines),$indent->[-1])}my$j=(substr($string,0,1)eq '>')? ' ' : "\n";my$t=(substr($string,1,1)eq '-')? '' : "\n";return join($j,@multiline).$t}sub _load_array {my ($self,$array,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"YAML::Tiny found bad indenting in line '$lines->[0]'"}if ($lines->[0]=~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/){my$indent2=length("$1");$lines->[0]=~ s/-/ /;push @$array,{};$self->_load_hash($array->[-1],[@$indent,$indent2 ],$lines)}elsif ($lines->[0]=~ /^\s*\-\s*\z/){shift @$lines;unless (@$lines){push @$array,undef;return 1}if ($lines->[0]=~ /^(\s*)\-/){my$indent2=length("$1");if ($indent->[-1]==$indent2){push @$array,undef}else {push @$array,[];$self->_load_array($array->[-1],[@$indent,$indent2 ],$lines)}}elsif ($lines->[0]=~ /^(\s*)\S/){push @$array,{};$self->_load_hash($array->[-1],[@$indent,length("$1")],$lines)}else {die \"YAML::Tiny failed to classify line '$lines->[0]'"}}elsif ($lines->[0]=~ /^\s*\-(\s*)(.+?)\s*\z/){shift @$lines;push @$array,$self->_load_scalar("$2",[@$indent,undef ],$lines)}elsif (defined$indent->[-2]and $indent->[-1]==$indent->[-2]){return 1}else {die \"YAML::Tiny failed to classify line '$lines->[0]'"}}return 1}sub _load_hash {my ($self,$hash,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"YAML::Tiny found bad indenting in line '$lines->[0]'"}my$key;if ($lines->[0]=~ s/^\s*$re_capture_single_quoted$re_key_value_separator//){$key=$self->_unquote_single($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_double_quoted$re_key_value_separator//){$key=$self->_unquote_double($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_unquoted_key$re_key_value_separator//){$key=$1;$key =~ s/\s+$//}elsif ($lines->[0]=~ /^\s*\?/){die \"YAML::Tiny does not support a feature in line '$lines->[0]'"}else {die \"YAML::Tiny failed to classify line '$lines->[0]'"}if (exists$hash->{$key}){warn "YAML::Tiny found a duplicate key '$key' in line '$lines->[0]'"}if (length$lines->[0]){$hash->{$key}=$self->_load_scalar(shift(@$lines),[@$indent,undef ],$lines)}else {shift @$lines;unless (@$lines){$hash->{$key}=undef;return 1}if ($lines->[0]=~ /^(\s*)-/){$hash->{$key}=[];$self->_load_array($hash->{$key},[@$indent,length($1)],$lines)}elsif ($lines->[0]=~ /^(\s*)./){my$indent2=length("$1");if ($indent->[-1]>= $indent2){$hash->{$key}=undef}else {$hash->{$key}={};$self->_load_hash($hash->{$key},[@$indent,length($1)],$lines)}}}}return 1}sub _dump_file {my$self=shift;require Fcntl;my$file=shift or $self->_error('You did not specify a file name');my$fh;if (_can_flock()){my$flags=Fcntl::O_WRONLY()|Fcntl::O_CREAT();sysopen($fh,$file,$flags)or $self->_error("Failed to open file '$file' for writing: $!");binmode($fh,":raw:encoding(UTF-8)");flock($fh,Fcntl::LOCK_EX())or warn "Couldn't lock '$file' for reading: $!";truncate$fh,0;seek$fh,0,0}else {open$fh,">:unix:encoding(UTF-8)",$file}print {$fh}$self->_dump_string;unless (close$fh){$self->_error("Failed to close file '$file': $!")}return 1}sub _dump_string {my$self=shift;return '' unless ref$self && @$self;my$indent=0;my@lines=();eval {for my$cursor (@$self){push@lines,'---';if (!defined$cursor){}elsif (!ref$cursor){$lines[-1].= ' ' .$self->_dump_scalar($cursor)}elsif (ref$cursor eq 'ARRAY'){unless (@$cursor){$lines[-1].= ' []';next}push@lines,$self->_dump_array($cursor,$indent,{})}elsif (ref$cursor eq 'HASH'){unless (%$cursor){$lines[-1].= ' {}';next}push@lines,$self->_dump_hash($cursor,$indent,{})}else {die \("Cannot serialize " .ref($cursor))}}};if (ref $@ eq 'SCALAR'){$self->_error(${$@})}elsif ($@){$self->_error($@)}join '',map {"$_\n"}@lines}sub _has_internal_string_value {my$value=shift;my$b_obj=B::svref_2object(\$value);return$b_obj->FLAGS & B::SVf_POK()}sub _dump_scalar {my$string=$_[1];my$is_key=$_[2];my$has_string_flag=_has_internal_string_value($string);return '~' unless defined$string;return "''" unless length$string;if (Scalar::Util::looks_like_number($string)){if ($is_key || $has_string_flag){return qq['$string']}else {return$string}}if ($string =~ /[\x00-\x09\x0b-\x0d\x0e-\x1f\x7f-\x9f\'\n]/){$string =~ s/\\/\\\\/g;$string =~ s/"/\\"/g;$string =~ s/\n/\\n/g;$string =~ s/[\x85]/\\N/g;$string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;$string =~ s/([\x7f-\x9f])/'\x' . sprintf("%X",ord($1))/ge;return qq|"$string"|}if ($string =~ /(?:^[~!@#%&*|>?:,'"`{}\[\]]|^-+$|\s|:\z)/ or $QUOTE{$string}){return "'$string'"}return$string}sub _dump_array {my ($self,$array,$indent,$seen)=@_;if ($seen->{refaddr($array)}++){die \"YAML::Tiny does not support circular references"}my@lines=();for my$el (@$array){my$line=('  ' x $indent).'-';my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"YAML::Tiny does not support $type references"}}@lines}sub _dump_hash {my ($self,$hash,$indent,$seen)=@_;if ($seen->{refaddr($hash)}++){die \"YAML::Tiny does not support circular references"}my@lines=();for my$name (sort keys %$hash){my$el=$hash->{$name};my$line=('  ' x $indent).$self->_dump_scalar($name,1).":";my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"YAML::Tiny does not support $type references"}}@lines}our$errstr='';sub _error {require Carp;$errstr=$_[1];$errstr =~ s/ at \S+ line \d+.*//;Carp::croak($errstr)}my$errstr_warned;sub errstr {require Carp;Carp::carp("YAML::Tiny->errstr and \$YAML::Tiny::errstr is deprecated")unless$errstr_warned++;$errstr}use B;my$HAS_FLOCK;sub _can_flock {if (defined$HAS_FLOCK){return$HAS_FLOCK}else {require Config;my$c=\%Config::Config;$HAS_FLOCK=grep {$c->{$_}}qw/d_flock d_fcntl_can_lock d_lockf/;require Fcntl if$HAS_FLOCK;return$HAS_FLOCK}}use Scalar::Util ();BEGIN {local $@;if (eval {Scalar::Util->VERSION(1.18)}){*refaddr=*Scalar::Util::refaddr}else {eval <<'END_PERL'}}delete$YAML::Tiny::{refaddr};1;
  # Scalar::Util failed to load or too old
  sub refaddr {
      my $pkg = ref($_[0]) or return undef;
      if ( !! UNIVERSAL::can($_[0], 'can') ) {
          bless $_[0], 'Scalar::Util::Fake';
      } else {
          $pkg = undef;
      }
      "$_[0]" =~ /0x(\w+)/;
      my $i = do { no warnings 'portable'; hex $1 };
      bless $_[0], $pkg if defined $pkg;
      $i;
  }
  END_PERL
YAML_TINY

$fatpacked{"namespace/autoclean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_AUTOCLEAN';
  use strict;use warnings;package namespace::autoclean;our$VERSION='0.29';use B::Hooks::EndOfScope 0.12;use List::Util qw(first);use namespace::clean 0.20;sub import {my ($class,%args)=@_;my$subcast=sub {my$i=shift;return$i if ref$i eq 'CODE';return sub {$_ =~ $i}if ref$i eq 'Regexp';return sub {$_ eq $i}};my$runtest=sub {my ($code,$method_name)=@_;local $_=$method_name;return$code->()};my$cleanee=exists$args{-cleanee}? $args{-cleanee}: scalar caller;my@also=map$subcast->($_),(exists$args{-also}? (ref$args{-also}eq 'ARRAY' ? @{$args{-also}}: $args{-also}): ());my@except=map$subcast->($_),(exists$args{-except}? (ref$args{-except}eq 'ARRAY' ? @{$args{-except}}: $args{-except}): ());on_scope_end {my$subs=namespace::clean->get_functions($cleanee);my$method_check=_method_check($cleanee);my@clean=grep {my$method=$_;!first {$runtest->($_,$method)}@except and (!$method_check->($method)or first {$runtest->($_,$method)}@also)}keys %$subs;namespace::clean->clean_subroutines($cleanee,@clean)}}sub _method_check {my$package=shift;if ((defined&Class::MOP::class_of and my$meta=Class::MOP::class_of($package))){my%methods=map +($_=>1),$meta->get_method_list;$methods{meta}=1 if$meta->isa('Moose::Meta::Role')&& Moose->VERSION < 0.90;return sub {$_[0]=~ /^\(/ || $methods{$_[0]}}}else {my$does=$package->can('does')? 'does' : $package->can('DOES')? 'DOES' : undef;require Sub::Identify;return sub {return 1 if $_[0]=~ /^\(/;my$coderef=do {no strict 'refs';\&{$package .'::' .$_[0]}};my$code_stash=Sub::Identify::stash_name($coderef);return 1 if$code_stash eq $package;return 1 if$code_stash eq 'constant';return 1 if$does && eval {$package->$does($code_stash)};return 0}}}1;
NAMESPACE_AUTOCLEAN

$fatpacked{"namespace/clean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_CLEAN';
  package namespace::clean;use warnings;use strict;our$VERSION='0.27';$VERSION=eval$VERSION if$VERSION =~ /_/;our$STORAGE_VAR='__NAMESPACE_CLEAN_STORAGE';use B::Hooks::EndOfScope 'on_scope_end';BEGIN {my$provider;if ("$]" < 5.008007){require Package::Stash::PP;$provider='Package::Stash::PP'}else {require Package::Stash;$provider='Package::Stash'}eval <<"EOS" or die $@}use namespace::clean::_Util qw(DEBUGGER_NEEDS_CV_RENAME DEBUGGER_NEEDS_CV_PIVOT);my$RemoveSubs=sub {my$cleanee=shift;my$store=shift;my$cleanee_stash=stash_for($cleanee);my$deleted_stash;SYMBOL: for my$f (@_){next SYMBOL if$store->{exclude}{$f };my$sub=$cleanee_stash->get_symbol("&$f")or next SYMBOL;my$need_debugger_fixup=(DEBUGGER_NEEDS_CV_RENAME or DEBUGGER_NEEDS_CV_PIVOT)&& $^P & 0x01 && defined&DB::sub && ref(my$globref=\$cleanee_stash->namespace->{$f})eq 'GLOB' && ($deleted_stash ||= stash_for("namespace::clean::deleted::$cleanee"));if (DEBUGGER_NEEDS_CV_RENAME and $need_debugger_fixup){namespace::clean::_Util::get_subname($sub)eq ($cleanee_stash->name ."::$f")and $deleted_stash->add_symbol("&$f",namespace::clean::_Util::set_subname($deleted_stash->name ."::$f",$sub),)}elsif (DEBUGGER_NEEDS_CV_PIVOT and $need_debugger_fixup){$deleted_stash->add_symbol("&$f",$sub)}my@symbols=map {my$name=$_ .$f;my$def=$cleanee_stash->get_symbol($name);defined($def)? [$name,$def]: ()}'$','@','%','';$cleanee_stash->remove_glob($f);DEBUGGER_NEEDS_CV_PIVOT and $need_debugger_fixup and *$globref=$deleted_stash->namespace->{$f};$cleanee_stash->add_symbol(@$_)for@symbols}};sub clean_subroutines {my ($nc,$cleanee,@subs)=@_;$RemoveSubs->($cleanee,{},@subs)}sub import {my ($pragma,@args)=@_;my (%args,$is_explicit);ARG: while (@args){if ($args[0]=~ /^\-/){my$key=shift@args;my$value=shift@args;$args{$key }=$value}else {$is_explicit++;last ARG}}my$cleanee=exists$args{-cleanee }? $args{-cleanee }: scalar caller;if ($is_explicit){on_scope_end {$RemoveSubs->($cleanee,{},@args)}}else {my$functions=$pragma->get_functions($cleanee);my$store=$pragma->get_class_store($cleanee);my$stash=stash_for($cleanee);my%except=map {($_=>1)}($args{-except }? (ref$args{-except }eq 'ARRAY' ? @{$args{-except }}: $args{-except }): ());for my$f (keys %$functions){next if$except{$f };next unless$stash->has_symbol("&$f");$store->{remove}{$f }=1}on_scope_end {$RemoveSubs->($cleanee,$store,keys %{$store->{remove}})};return 1}}sub unimport {my ($pragma,%args)=@_;my$cleanee=exists$args{-cleanee }? $args{-cleanee }: scalar caller;my$functions=$pragma->get_functions($cleanee);my$store=$pragma->get_class_store($cleanee);for my$f (keys %$functions){next if$store->{remove}{$f }or $store->{exclude}{$f };$store->{exclude}{$f }=1}return 1}sub get_class_store {my ($pragma,$class)=@_;my$stash=stash_for($class);my$var="%$STORAGE_VAR";$stash->add_symbol($var,{})unless$stash->has_symbol($var);return$stash->get_symbol($var)}sub get_functions {my ($pragma,$class)=@_;my$stash=stash_for($class);return {map {$_=>$stash->get_symbol("&$_")}$stash->list_all_symbols('CODE')}}'Danger! Laws of Thermodynamics may not apply.' 
  
  sub stash_for (\$) {
    $provider->new(\$_[0]);
  }
  
  1;
  
  EOS
NAMESPACE_CLEAN

$fatpacked{"namespace/clean/_Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_CLEAN__UTIL';
  package namespace::clean::_Util;use warnings;use strict;use base 'Exporter';our@EXPORT_OK=qw(DEBUGGER_NEEDS_CV_RENAME DEBUGGER_NEEDS_CV_PIVOT);use constant DEBUGGER_NEEDS_CV_RENAME=>(("$]" > 5.008_008)and ("$]" < 5.013_006));use constant DEBUGGER_NEEDS_CV_PIVOT=>((!DEBUGGER_NEEDS_CV_RENAME)and ("$]" < 5.015_005));BEGIN {DEBUGGER_NEEDS_CV_RENAME and (eval <<'EOS' or die $@)}1;
  {
    my( $sub_name_loaded, $sub_util_loaded );
  
    sub _namer_load_error {
      return '' if $sub_util_loaded or $sub_name_loaded;
  
      # if S::N is loaded first *and* so is B - then go with that, otherwise
      # prefer Sub::Util as S::U will provide a faster get_subname and will
      # not need further require() calls
      # this is rather arbitrary but remember this code exists only perls
      # between 5.8.9 ~ 5.13.5
  
      # when changing version also change in Makefile.PL
      my $sn_ver = 0.04;
  
      local $@;
      my $err = '';
  
      (
        ! (
          $INC{"B.pm"}
            and
          $INC{"Sub/Name.pm"}
            and
          eval { Sub::Name->VERSION($sn_ver) }
        )
          and
        eval { require Sub::Util }
          and
        # see https://github.com/moose/Moo/commit/dafa5118
        defined &Sub::Util::set_subname
          and
        $sub_util_loaded = 1
      )
        or
      (
        eval { require Sub::Name and Sub::Name->VERSION($sn_ver) }
          and
        $sub_name_loaded = 1
      )
        or
      $err = "When running under -d on this perl $], namespace::clean requires either Sub::Name $sn_ver or Sub::Util to be installed"
      ;
  
      $err;
    }
  
    sub set_subname {
      if( my $err = _namer_load_error() ) {
        die $err;
      }
      elsif( $sub_name_loaded ) {
        &Sub::Name::subname;
      }
      elsif( $sub_util_loaded ) {
        &Sub::Util::set_subname;
      }
      else {
        die "How the fuck did we get here? Read source and debug please!";
      }
    }
  
    sub get_subname {
      if(
        _namer_load_error()
          or
        ! $sub_util_loaded
      ) {
        require B;
        my $gv = B::svref_2object( $_[0] )->GV;
        join '::', $gv->STASH->NAME, $gv->NAME;
      }
      else {
        &Sub::Util::subname;
      }
    }
  }
  1;
  EOS
NAMESPACE_CLEAN__UTIL

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;use Moo::_strictures;use Moo::_Utils qw(_load_module);sub moo {print <<'EOMOO';exit 0}BEGIN {my$package;sub import {moo()if $0 eq '-';$package=$_[1]|| 'Class';if ($package =~ /^\+/){$package =~ s/^\+//;_load_module($package)}}use Filter::Simple sub {s/^/package $package;\nuse Moo;\n/}}1;
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
OO

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use Applify;
use Data::Dumper;
use CI::Repo;

version 0.01;
documentation __FILE__;

subcommand repo => 'Repo management' => sub {
    option bool => sync_upstream => "Sync upstream repos";
    option str => layer_list => "Path to reactive layer ", required => 1;
    option str => charm_list => "Path to charm list",      required => 1;
};

sub command_repo {
    print Dumper(@_);
    my ( $app, $action ) = @_;
    my $repo = CI::Repo->new(
        layer_list => $app->{layer_list},
        charm_list => $app->{charm_list}
    );
    $action =~ s/-/_/;
    $repo->$action if $repo->can($action);
    return 0;
}

app {
    my $self = shift;
    return 0;
};

__END__

=head1 NAME

monk - CLI for CI

=head1 SYNOPSIS

    # Sync upstream git repos
    $ monk repo --sync-upstream --layer-list my-layers.yaml --charm-list my-charms.yaml

=head1 AUTHOR

Adam Stokes - c<adamjs@cpan.org>

=cut
